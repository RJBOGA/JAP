This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
MANUAL_TESTING_GUIDE.md
QUICK_TEST_GUIDE.txt
README.md
requirements.txt
scripts/manual_test.py
scripts/quick_test.py
scripts/repair_indexes.py
scripts/seed_db.py
scripts/test_denormalized_schema.py
scripts/test_login.py
scripts/test_nl2gql_denormalized.py
scripts/test_schedule_smoke.py
scripts/test_smtp_config.py
scripts/test_workflow.py
src/.env
src/backend/.env
src/backend/app.py
src/backend/db.py
src/backend/errors.py
src/backend/models/user_models.py
src/backend/repository/application_repo.py
src/backend/repository/job_repo.py
src/backend/repository/user_repo.py
src/backend/resolvers/application_resolvers.py
src/backend/resolvers/job_resolvers.py
src/backend/resolvers/scheduling_resolvers.py
src/backend/resolvers/user_resolvers.py
src/backend/schema.graphql
src/backend/services/email_service.py
src/backend/services/nl2gql_service.py
src/backend/services/resume_parser_service.py
src/backend/services/scheduling_service.py
src/backend/validators/common_validators.py
src/frontend-react/.env.development
src/frontend-react/package.json
src/frontend-react/public/index.html
src/frontend-react/src/api.js
src/frontend-react/src/App.css
src/frontend-react/src/App.js
src/frontend-react/src/CompleteProfilePage.js
src/frontend-react/src/index.js
src/frontend-react/src/LoginPage.css
src/frontend-react/src/LoginPage.js
src/frontend-react/src/ResultsDisplay.css
src/frontend-react/src/ResultsDisplay.js
src/frontend-react/src/ResumeUploader.js
src/frontend-react/src/SchedulingPanel.js
WORKFLOW_DIAGRAM.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="MANUAL_TESTING_GUIDE.md">
# MANUAL TESTING GUIDE - Interview Workflow Automation
## Complete End-to-End Testing Scenarios

This guide provides step-by-step instructions to manually test all features of the job application system, including the new interview workflow automation with email notifications.

---

## PREREQUISITES

1. **Start MongoDB** (make sure it's running on localhost:27017)
2. **Start the Backend Server**:
   ```bash
   python src/backend/app.py
   ```
   Server should be running at: http://localhost:8000

3. **Seed the Database** (optional - creates test data):
   ```bash
   python scripts/seed_db.py
   ```

4. **Tools Needed**:
   - Terminal/PowerShell
   - API testing tool (Postman, Insomnia, or curl)
   - OR GraphQL Explorer at: http://localhost:8000/graphql

---

## SCENARIO 1: RECRUITER WORKFLOW

### Step 1.1: Create Recruiter Account

**Endpoint**: `POST http://localhost:8000/register`

**Request Body**:
```json
{
  "email": "jane.recruiter@techcorp.com",
  "password": "SecurePass123",
  "firstName": "Jane",
  "lastName": "Recruiter",
  "role": "Recruiter"
}
```

**Expected Response** (201 Created):
```json
{
  "message": "User registered successfully!",
  "UserID": 251
}
```

**Save the UserID** - you'll need it later!

---

### Step 1.2: Login as Recruiter

**Endpoint**: `POST http://localhost:8000/login`

**Request Body**:
```json
{
  "email": "jane.recruiter@techcorp.com",
  "password": "SecurePass123"
}
```

**Expected Response** (200 OK):
```json
{
  "message": "Login successful!",
  "user": {
    "UserID": 251,
    "firstName": "Jane",
    "lastName": "Recruiter",
    "role": "Recruiter",
    "email": "jane.recruiter@techcorp.com"
  }
}
```

**IMPORTANT**: For all subsequent GraphQL requests, add this header:
```
X-User-Role: Recruiter
```

---

### Step 1.3: Post a New Job

**Endpoint**: `POST http://localhost:8000/graphql`

**Headers**:
```
Content-Type: application/json
X-User-Role: Recruiter
```

**GraphQL Mutation**:
```graphql
mutation {
  createJob(input: {
    title: "Senior Full Stack Developer"
    company: "TechCorp"
    location: "San Francisco, CA"
    salaryRange: "$150k - $200k"
    skillsRequired: ["React", "Node.js", "TypeScript", "AWS"]
    description: "We are seeking an experienced full stack developer to join our innovative team. You will work on cutting-edge projects using modern technologies."
  }) {
    jobId
    title
    company
    location
    status
    postedAt
  }
}
```

**Expected Response**:
```json
{
  "data": {
    "createJob": {
      "jobId": 6,
      "title": "Senior Full Stack Developer",
      "company": "TechCorp",
      "location": "San Francisco, CA",
      "status": null,
      "postedAt": "2025-11-23"
    }
  }
}
```

**Save the jobId** (e.g., 6) - you'll need it!

---

### Step 1.4: View All Posted Jobs

**GraphQL Query**:
```graphql
{
  jobs(company: "TechCorp") {
    jobId
    title
    company
    location
    applicationCount
    status
  }
}
```

**Expected Response**:
```json
{
  "data": {
    "jobs": [
      {
        "jobId": 6,
        "title": "Senior Full Stack Developer",
        "company": "TechCorp",
        "location": "San Francisco, CA",
        "applicationCount": 0,
        "status": null
      }
    ]
  }
}
```

---

## SCENARIO 2: APPLICANT WORKFLOW

### Step 2.1: Create Applicant Account

**Endpoint**: `POST http://localhost:8000/register`

**Request Body**:
```json
{
  "email": "john.developer@email.com",
  "password": "DevPass123",
  "firstName": "John",
  "lastName": "Developer",
  "role": "Applicant"
}
```

**Expected Response** (201 Created):
```json
{
  "message": "User registered successfully!",
  "UserID": 252
}
```

**Save the UserID** (e.g., 252)!

---

### Step 2.2: Update Applicant Profile

**Endpoint**: `POST http://localhost:8000/graphql`

**Headers**:
```
Content-Type: application/json
X-User-Role: Applicant
```

**GraphQL Mutation** (use your UserID):
```graphql
mutation {
  updateUser(UserID: 252, input: {
    city: "San Francisco"
    country: "USA"
    professionalTitle: "Full Stack Developer"
    years_of_experience: 6
    skills: ["React", "Node.js", "TypeScript", "MongoDB", "AWS"]
    linkedin_profile: "https://linkedin.com/in/johndeveloper"
    highest_qualification: "Bachelor of Science in Computer Science"
  }) {
    UserID
    firstName
    lastName
    professionalTitle
    skills
    years_of_experience
  }
}
```

**Expected Response**:
```json
{
  "data": {
    "updateUser": {
      "UserID": 252,
      "firstName": "John",
      "lastName": "Developer",
      "professionalTitle": "Full Stack Developer",
      "skills": ["React", "Node.js", "TypeScript", "MongoDB", "AWS"],
      "years_of_experience": 6
    }
  }
}
```

---

### Step 2.3: Apply to the Job

**GraphQL Mutation**:
```graphql
mutation {
  apply(
    userName: "John Developer"
    jobTitle: "Senior Full Stack Developer"
    companyName: "TechCorp"
  ) {
    appId
    status
    submittedAt
    candidate {
      firstName
      lastName
      email
    }
    job {
      title
      company
    }
  }
}
```

**Expected Response**:
```json
{
  "data": {
    "apply": {
      "appId": 7,
      "status": "Applied",
      "submittedAt": "2025-11-23T05:15:00Z",
      "candidate": {
        "firstName": "John",
        "lastName": "Developer",
        "email": "john.developer@email.com"
      },
      "job": {
        "title": "Senior Full Stack Developer",
        "company": "TechCorp"
      }
    }
  }
}
```

**Save the appId** (e.g., 7)!

---

### Step 2.4: Add a Note to Your Application (Applicant)

**GraphQL Mutation**:
```graphql
mutation {
  addNoteToApplicationByJob(
    jobTitle: "Senior Full Stack Developer"
    companyName: "TechCorp"
    note: "I am particularly excited about this role because I have 6 years of experience with the exact tech stack you're using. I recently led a migration to TypeScript at my current company."
  ) {
    appId
    notes
  }
}
```

**Expected Response**:
```json
{
  "data": {
    "addNoteToApplicationByJob": {
      "appId": 7,
      "notes": "I am particularly excited about this role..."
    }
  }
}
```

---

## SCENARIO 3: RECRUITER REVIEWS APPLICATIONS

### Step 3.1: Switch Back to Recruiter

**IMPORTANT**: Change your header to:
```
X-User-Role: Recruiter
```

### Step 3.2: View All Applications for Your Job

**GraphQL Query** (use your jobId):
```graphql
{
  jobs(title: "Senior Full Stack Developer", company: "TechCorp") {
    jobId
    title
    applicationCount
    applicants {
      UserID
      firstName
      lastName
      email
      professionalTitle
      skills
      years_of_experience
    }
  }
}
```

**Expected Response**:
```json
{
  "data": {
    "jobs": [
      {
        "jobId": 6,
        "title": "Senior Full Stack Developer",
        "applicationCount": 1,
        "applicants": [
          {
            "UserID": 252,
            "firstName": "John",
            "lastName": "Developer",
            "email": "john.developer@email.com",
            "professionalTitle": "Full Stack Developer",
            "skills": ["React", "Node.js", "TypeScript", "MongoDB", "AWS"],
            "years_of_experience": 6
          }
        ]
      }
    ]
  }
}
```

---

### Step 3.3: View Application Details

**GraphQL Query**:
```graphql
{
  applications(jobId: 6) {
    appId
    status
    submittedAt
    notes
    candidate {
      firstName
      lastName
      email
      skills
    }
  }
}
```

---

## SCENARIO 4: INTERVIEW WORKFLOW (EMAIL NOTIFICATION)

### Step 4.1: Update Application Status to "Interviewing"

**CRITICAL**: This will **SEND AN EMAIL** to the candidate!

**GraphQL Mutation**:
```graphql
mutation {
  updateApplicationStatusByNames(
    userName: "John Developer"
    jobTitle: "Senior Full Stack Developer"
    companyName: "TechCorp"
    newStatus: "Interviewing"
  ) {
    appId
    status
    candidate {
      firstName
      lastName
      email
    }
    job {
      title
      company
    }
  }
}
```

**Expected Response**:
```json
{
  "data": {
    "updateApplicationStatusByNames": {
      "appId": 7,
      "status": "Interviewing",
      "candidate": {
        "firstName": "John",
        "lastName": "Developer",
        "email": "john.developer@email.com"
      },
      "job": {
        "title": "Senior Full Stack Developer",
        "company": "TechCorp"
      }
    }
  }
}
```

**‚úÖ CHECK**: 
1. Look at your backend console - you should see:
   ```
   Interview invitation sent to john.developer@email.com
   ```

2. Check your Resend dashboard at: https://resend.com/emails
   - You should see an email sent to: john.developer@email.com
   - Subject: "Interview Invitation for the Senior Full Stack Developer position at TechCorp"

---

### Step 4.2: Add Manager Notes After Interview

**GraphQL Mutation**:
```graphql
mutation {
  addManagerNoteToApplication(
    userName: "John Developer"
    jobTitle: "Senior Full Stack Developer"
    companyName: "TechCorp"
    note: "Excellent technical interview. Strong knowledge of React and Node.js. Good cultural fit. Recommend moving to final round."
  ) {
    appId
    notes
    candidate {
      firstName
      lastName
    }
  }
}
```

**Expected Response**:
```json
{
  "data": {
    "addManagerNoteToApplication": {
      "appId": 7,
      "notes": "I am particularly excited about this role...\n--- Recruiter Note (2025-11-23): Excellent technical interview. Strong knowledge of React and Node.js. Good cultural fit. Recommend moving to final round.",
      "candidate": {
        "firstName": "John",
        "lastName": "Developer"
      }
    }
  }
}
```

Notice the notes are **timestamped** and **appended**!

---

## SCENARIO 5: HIRING WORKFLOW (AUTOMATED JOB CLOSURE + MASS EMAILS)

### Step 5.1: Create Additional Applicants (for mass rejection test)

Let's create 2 more applicants who also applied:

**Applicant 2**:
```json
POST /register
{
  "email": "sarah.engineer@email.com",
  "password": "Pass123",
  "firstName": "Sarah",
  "lastName": "Engineer",
  "role": "Applicant"
}
```

**Applicant 3**:
```json
POST /register
{
  "email": "mike.coder@email.com",
  "password": "Pass123",
  "firstName": "Mike",
  "lastName": "Coder",
  "role": "Applicant"
}
```

### Step 5.2: Have Them Apply

**As Sarah** (X-User-Role: Applicant):
```graphql
mutation {
  apply(
    userName: "Sarah Engineer"
    jobTitle: "Senior Full Stack Developer"
    companyName: "TechCorp"
  ) {
    appId
    status
  }
}
```

**As Mike** (X-User-Role: Applicant):
```graphql
mutation {
  apply(
    userName: "Mike Coder"
    jobTitle: "Senior Full Stack Developer"
    companyName: "TechCorp"
  ) {
    appId
    status
  }
}
```

---

### Step 5.3: Hire John Developer

**CRITICAL**: This will:
1. Mark John as "Hired"
2. Close the job automatically
3. Send rejection emails to Sarah and Mike

**As Recruiter** (X-User-Role: Recruiter):
```graphql
mutation {
  updateApplicationStatusByNames(
    userName: "John Developer"
    jobTitle: "Senior Full Stack Developer"
    companyName: "TechCorp"
    newStatus: "Hired"
  ) {
    appId
    status
    candidate {
      firstName
      lastName
      email
    }
    job {
      jobId
      title
      status
    }
  }
}
```

**Expected Response**:
```json
{
  "data": {
    "updateApplicationStatusByNames": {
      "appId": 7,
      "status": "Hired",
      "candidate": {
        "firstName": "John",
        "lastName": "Developer",
        "email": "john.developer@email.com"
      },
      "job": {
        "jobId": 6,
        "title": "Senior Full Stack Developer",
        "status": "Closed"
      }
    }
  }
}
```

**‚úÖ CHECK**:
1. Backend console should show:
   ```
   Triggering side-effects for hired status on job 6...
   Rejection notification sent to sarah.engineer@email.com
   Rejection notification sent to mike.coder@email.com
   Hired status side-effects complete.
   ```

2. Check Resend dashboard: https://resend.com/emails
   - Should see 2 rejection emails sent
   - Subject: "Update on your application for Senior Full Stack Developer at TechCorp"

3. Verify job is closed:
   ```graphql
   {
     jobById(jobId: 6) {
       jobId
       title
       status
     }
   }
   ```
   Response should show: `"status": "Closed"`

---

## SCENARIO 6: NATURAL LANGUAGE TESTING

### Test Natural Language Commands

**Endpoint**: `POST http://localhost:8000/nl2gql?run=true`

**Headers**:
```
Content-Type: application/json
X-User-Role: Recruiter
```

### Example 1: Interview a Candidate

**Request Body**:
```json
{
  "query": "Interview Charlie Brown for the Senior Python Developer position at Google"
}
```

**Expected Response**:
```json
{
  "graphql": "mutation { updateApplicationStatusByNames(...) { ... } }",
  "result": {
    "data": {
      "updateApplicationStatusByNames": {
        "appId": 1,
        "status": "Interviewing",
        ...
      }
    }
  }
}
```

### Example 2: Add a Note

**Request Body**:
```json
{
  "query": "Add a note to Charlie Brown's Google application: Great technical skills, recommend final round"
}
```

### Example 3: Hire Someone

**Request Body**:
```json
{
  "query": "Hire Diana Prince for the Product Manager job at Meta"
}
```

---

## TESTING WITH SEEDED DATA

If you ran `python scripts/seed_db.py`, you have these test accounts:

### Recruiters:
- **Email**: recruiter@google.com | **Password**: password123
- **Email**: hiring@meta.com | **Password**: password123

### Applicants:
- **Charlie Brown** - charlie.brown@email.com | password123
- **Diana Prince** - diana.prince@email.com | password123  
- **Ethan Hunt** - ethan.hunt@email.com | password123
- **Frank Miller** - frank.miller@email.com | password123
- **Grace Hopper** - grace.hopper@email.com | password123

### Pre-existing Jobs:
1. Senior Python Developer @ Google
2. Senior UI/UX Designer @ Figma
3. Product Manager @ Meta
4. Data Scientist @ Netflix (has 3 applicants - perfect for mass rejection test!)
5. Frontend Engineer @ Vercel

### Quick Test with Seeded Data:

**Interview Charlie**:
```graphql
mutation {
  updateApplicationStatusByNames(
    userName: "Charlie Brown"
    jobTitle: "Senior Python Developer"
    companyName: "Google"
    newStatus: "Interviewing"
  ) {
    appId status
    candidate { email }
  }
}
```
Email sent to: charlie.brown@email.com ‚úÖ

**Hire Ethan (triggers mass rejection)**:
```graphql
mutation {
  updateApplicationStatusByNames(
    userName: "Ethan Hunt"
    jobTitle: "Data Scientist"
    companyName: "Netflix"
    newStatus: "Hired"
  ) {
    appId status
    job { status }
  }
}
```
- Job closed ‚úÖ
- Frank and Grace get rejection emails ‚úÖ

---

## EMAIL VERIFICATION CHECKLIST

After running the workflows above, verify in Resend Dashboard:

1. ‚úÖ Interview invitation to john.developer@email.com
2. ‚úÖ Rejection email to sarah.engineer@email.com
3. ‚úÖ Rejection email to mike.coder@email.com
4. ‚úÖ (If using seeded data) Email to charlie.brown@email.com
5. ‚úÖ (If using seeded data) Emails to frank.miller@email.com and grace.hopper@email.com

**Resend Dashboard**: https://resend.com/emails

---

## TROUBLESHOOTING

### No emails being sent?
1. Check backend console for error messages
2. Verify RESEND_API_KEY in `src/backend/.env`
3. Make sure you're using X-User-Role: Recruiter header
4. Check that status is exactly "Interviewing" or "Hired" (case-sensitive)

### GraphQL errors?
1. Verify you're using the correct X-User-Role header
2. Check that user/job names match exactly (case-sensitive)
3. Make sure the application exists before updating status

### Authorization errors?
- Only Recruiters can:
  - updateApplicationStatusByNames
  - addManagerNoteToApplication
- Applicants can:
  - addNoteToApplicationByJob (only their own applications)

---

## SUCCESS CRITERIA

After completing this guide, you should have:
- ‚úÖ Created recruiter and applicant accounts
- ‚úÖ Posted a job
- ‚úÖ Applied to a job
- ‚úÖ Updated application status to "Interviewing" (email sent)
- ‚úÖ Added manager notes
- ‚úÖ Hired a candidate (job closed, mass emails sent)
- ‚úÖ Verified emails in Resend dashboard
- ‚úÖ Tested natural language commands

**All features working perfectly!** üéâ
</file>

<file path="QUICK_TEST_GUIDE.txt">
# QUICK TESTING REFERENCE CARD

## Server Setup
```bash
# Start Backend
python src/backend/app.py
# Server: http://localhost:8000

# Seed Test Data (Optional)
python scripts/seed_db.py
```

---

## QUICK TESTS (Using Seeded Data)

### ‚úÖ Test 1: Interview Invitation Email
```graphql
# Header: X-User-Role: Recruiter
mutation {
  updateApplicationStatusByNames(
    userName: "Charlie Brown"
    jobTitle: "Senior Python Developer"
    companyName: "Google"
    newStatus: "Interviewing"
  ) {
    appId status
    candidate { email }
  }
}
```
**Expected**: Email sent to charlie.brown@email.com

---

### ‚úÖ Test 2: Manager Notes
```graphql
# Header: X-User-Role: Recruiter
mutation {
  addManagerNoteToApplication(
    userName: "Charlie Brown"
    jobTitle: "Senior Python Developer"
    companyName: "Google"
    note: "Excellent skills, recommend final round"
  ) {
    appId notes
  }
}
```
**Expected**: Timestamped note added

---

### ‚úÖ Test 3: Hire + Auto Job Closure + Mass Rejection
```graphql
# Header: X-User-Role: Recruiter  
mutation {
  updateApplicationStatusByNames(
    userName: "Ethan Hunt"
    jobTitle: "Data Scientist"
    companyName: "Netflix"
    newStatus: "Hired"
  ) {
    appId status
    job { status }
  }
}
```
**Expected**:
- Ethan hired ‚úÖ
- Job closed ‚úÖ
- Frank & Grace get rejection emails ‚úÖ

---

### ‚úÖ Test 4: Natural Language
```bash
POST http://localhost:8000/nl2gql?run=true
Header: X-User-Role: Recruiter
Body:
{
  "query": "Interview Diana Prince for Product Manager at Meta"
}
```
**Expected**: Diana's status updated, email sent

---

## Seeded Test Accounts

### Recruiters
- recruiter@google.com / password123
- hiring@meta.com / password123

### Applicants  
- charlie.brown@email.com / password123
- diana.prince@email.com / password123
- ethan.hunt@email.com / password123
- frank.miller@email.com / password123
- grace.hopper@email.com / password123

---

## Verify Emails
https://resend.com/emails

---

## GraphQL Explorer
http://localhost:8000/graphql

Remember to add header:
```
X-User-Role: Recruiter
```

---

## Complete Guide
See: MANUAL_TESTING_GUIDE.md (full step-by-step instructions)
</file>

<file path="scripts/manual_test.py">
import requests
import json

API_BASE = "http://localhost:8000"

# Test 1: Charlie Brown -> Interviewing
print("="*70)
print("TEST: Update Charlie to Interviewing")
print("="*70)

mutation = """
mutation {
  updateApplicationStatusByNames(
    userName: "Charlie Brown"
    jobTitle: "Senior Python Developer"
    companyName: "Google"
    newStatus: "Interviewing"
  ) {
    appId
    status
    candidate {
      firstName
      lastName
      email
    }
    job {
      title
      company
    }
  }
}
"""

response = requests.post(
    f"{API_BASE}/graphql",
    json={"query": mutation},
    headers={"X-User-Role": "Recruiter"}
)

result = response.json()
print("\nResponse:")
print(json.dumps(result, indent=2))

if "data" in result and result["data"]["updateApplicationStatusByNames"]:
    print("\n‚úÖ SUCCESS! Email should be sent to:", result["data"]["updateApplicationStatusByNames"]["candidate"]["email"])
</file>

<file path="scripts/quick_test.py">
"""
Simple Manual Test - Denormalized Schema Verification
Quick test to verify the denormalized fields work correctly
"""
import requests
import json

API_BASE = "http://localhost:8000"

print("="*70)
print("DENORMALIZED SCHEMA - QUICK VERIFICATION TEST")
print("="*70)

# Test 1: Charlie Brown -> Interviewing
print("\n1. Testing Status Update (Charlie Brown -> Interviewing)...")

mutation = """
mutation {
  updateApplicationStatusByNames(
    userName: "Charlie Brown"
    jobTitle: "Senior Python Developer"
    companyName: "Google"
    newStatus: "Interviewing"
  ) {
    appId
    userName
    jobTitle
    companyName
    status
    candidate { email }
  }
}
"""

response = requests.post(
    f"{API_BASE}/graphql",
    json={"query": mutation},
    headers={"X-User-Role": "Recruiter"}
)

result = response.json()

if "data" in result and result["data"]["updateApplicationStatusByNames"]:
    app = result["data"]["updateApplicationStatusByNames"]
    print(f"‚úÖ SUCCESS!")
    print(f"   App ID: {app['appId']}")
    print(f"   User: {app['userName']}")
    print(f"   Job: {app['jobTitle']} @ {app['companyName']}")
    print(f"   Status: {app['status']}")
    print(f"   Email: {app['candidate']['email']}")
else:
    print(f"‚ùå FAILED: {result}")

# Test 2: Add Manager Note
print("\n2. Testing Manager Notes...")

mutation2 = """
mutation {
  addManagerNoteToApplication(
    userName: "Charlie Brown"
    jobTitle: "Senior Python Developer"
    companyName: "Google"
    note: "Test note - strong candidate!"
  ) {
    appId
    userName
    notes
  }
}
"""

response2 = requests.post(
    f"{API_BASE}/graphql",
    json={"query": mutation2},
    headers={"X-User-Role": "Recruiter"}
)

result2 = response2.json()

if "data" in result2 and result2["data"]["addManagerNoteToApplication"]:
    app = result2["data"]["addManagerNoteToApplication"]
    print(f"‚úÖ SUCCESS!")
    print(f"   App ID: {app['appId']}")
    print(f"   User: {app['userName']}")
    print(f"   Notes: ...{app['notes'][-50:]}")  # Last 50 chars
else:
    print(f"‚ùå FAILED: {result2}")

# Test 3: Query to verify fields exist
print("\n3. Querying all applications...")

query = """
{
  applications {
    appId
    userName
    jobTitle
    companyName
    status
  }
}
"""

response3 = requests.post(
    f"{API_BASE}/graphql",
    json={"query": query},
    headers={"X-User-Role": "Recruiter"}
)

result3 = response3.json()

if "data" in result3:
    apps = result3["data"]["applications"]
    print(f"‚úÖ Found {len(apps)} applications")
    
    apps_with_fields = [a for a in apps if a.get("userName") and a.get("jobTitle")]
    print(f"   {len(apps_with_fields)}/{len(apps)} have denormalized fields")
    
    if apps_with_fields:
        print(f"\n   Sample applications:")
        for app in apps_with_fields[:3]:
            print(f"   - {app['userName']} ‚Üí {app['jobTitle']} @ {app.get('companyName', 'N/A')}")
else:
    print(f"‚ùå FAILED: {result3}")

print("\n" + "="*70)
print("‚úÖ DENORMALIZED SCHEMA WORKING!")
print("="*70)
</file>

<file path="scripts/repair_indexes.py">
import pymongo
import sys

# Configuration
MONGO_URI = "mongodb://localhost:27017/"
DB_NAME = "jobtracker"

def repair():
    print(f"Connecting to {MONGO_URI}...")
    try:
        client = pymongo.MongoClient(MONGO_URI)
        db = client[DB_NAME]
    except Exception as e:
        print(f"‚ùå Could not connect to MongoDB: {e}")
        return

    print(f"Repairing database: {DB_NAME}")

    # 1. Drop the corrupted 'interviews' collection
    # This deletes the bad 'InterviewID_1' index
    print("1. Dropping 'interviews' collection to clear bad indexes...")
    db.interviews.drop()
    print("   ‚úÖ Collection dropped.")

    # 2. Create the correct Unique Index on 'interviewId' (lowercase 'i')
    print("2. Creating correct index on 'interviewId'...")
    try:
        db.interviews.create_index("interviewId", unique=True)
        print("   ‚úÖ Index 'interviewId_1' created.")
    except Exception as e:
        print(f"   ‚ùå Failed to create index: {e}")

    # 3. Create the Double-Booking Protection Index
    print("3. Creating double-booking protection...")
    try:
        db.interviews.create_index([("recruiterId", 1), ("startTime", 1)], unique=True)
        print("   ‚úÖ Index 'recruiterId_1_startTime_1' created.")
    except Exception as e:
        print(f"   ‚ùå Failed to create index: {e}")

    print("\nüéâ REPAIR COMPLETE. You can now restart your backend.")

if __name__ == "__main__":
    repair()
</file>

<file path="scripts/seed_db.py">
# scripts/seed_db.py
import os
import sys
import bcrypt
from datetime import datetime
from faker import Faker

# --- Setup Project Path ---
# This allows the script to import modules from the 'src' directory
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Now we can import our backend modules
from src.backend.db import get_db, next_user_id, next_job_id
from src.backend.models.user_models import UserProfileType

# Initialize Faker to generate realistic data
fake = Faker()

def seed_database():
    """
    Clears and populates the database with sample users and jobs.
    """
    print("Connecting to the database...")
    db = get_db()
    
    # --- 1. Clear Existing Data ---
    print("Clearing existing collections (users, jobs, applications)...")
    db["users"].delete_many({})
    db["jobs"].delete_many({})
    db["applications"].delete_many({})
    
    # --- 2. Create Sample Users ---
    print("Creating sample users...")
    users_to_create = [
        # --- RECRUITERS ---
        {
            "UserID": next_user_id(), "email": "recruiter@google.com", "password": "password123",
            "firstName": "Alice", "lastName": "Jones", "role": UserProfileType.RECRUITER.value,
            "professionalTitle": "Senior Technical Recruiter", "createdAt": datetime.utcnow().isoformat(),
            # All other fields are null by default
        },
        {
            "UserID": next_user_id(), "email": "hiring@figma.com", "password": "password123",
            "firstName": "Bob", "lastName": "Smith", "role": UserProfileType.RECRUITER.value,
            "professionalTitle": "Hiring Manager", "createdAt": datetime.utcnow().isoformat(),
        },
        # --- APPLICANTS ---
        {
            "UserID": next_user_id(), "email": "applicant1@email.com", "password": "password123",
            "firstName": "Charlie", "lastName": "Brown", "role": UserProfileType.APPLICANT.value,
            "professionalTitle": "Software Engineer", "years_of_experience": 5,
            "skills": ["Python", "Flask", "React", "MongoDB"], "city": "San Francisco", "country": "USA",
            "linkedin_profile": "https://linkedin.com/in/charliebrown", "createdAt": datetime.utcnow().isoformat(),
        },
        {
            "UserID": next_user_id(), "email": "applicant2@email.com", "password": "password123",
            "firstName": "Diana", "lastName": "Prince", "role": UserProfileType.APPLICANT.value,
            "professionalTitle": "Product Manager", "years_of_experience": 8,
            "skills": ["Agile", "Product Strategy", "AI"], "city": "New York", "country": "USA",
            "linkedin_profile": "https://linkedin.com/in/dianaprince", "createdAt": datetime.utcnow().isoformat(),
        },
        {
            "UserID": next_user_id(), "email": "applicant3@email.com", "password": "password123",
            "firstName": "Ethan", "lastName": "Hunt", "role": UserProfileType.APPLICANT.value,
            "professionalTitle": "Data Scientist", "years_of_experience": 4,
            "skills": ["SQL", "Python", "Machine Learning", "PyTorch"], "city": "London", "country": "UK",
             "linkedin_profile": "https://linkedin.com/in/ethanhunt", "createdAt": datetime.utcnow().isoformat(),
        },
    ]

    for user_data in users_to_create:
        # Securely hash the password before insertion
        password = user_data.pop("password").encode('utf-8')
        user_data["password"] = bcrypt.hashpw(password, bcrypt.gensalt())
        
        # Initialize remaining fields to None if they don't exist
        user_model_fields = [
            "phone_number", "city", "state_province", "country", "linkedin_profile",
            "portfolio_url", "highest_qualification", "years_of_experience",
            "dob", "skills", "professionalTitle"
        ]
        for field in user_model_fields:
            if field not in user_data:
                user_data[field] = None
        
        db["users"].insert_one(user_data)
    print(f"  -> Successfully created {len(users_to_create)} users.")

    # --- 3. Create Sample Jobs ---
    print("Creating sample jobs...")
    jobs_to_create = [
        {
            "jobId": next_job_id(), "title": "Senior Python Developer", "company": "Google",
            "location": "Mountain View, CA", "skillsRequired": ["Python", "Django", "AWS", "Kubernetes"],
            "description": "Seeking an experienced backend developer to join our cloud infrastructure team.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
        {
            "jobId": next_job_id(), "title": "Senior UI/UX Designer", "company": "Figma",
            "location": "San Francisco, CA", "skillsRequired": ["Figma", "Prototyping", "User Research"],
            "description": "Design the future of collaborative tools with a world-class team.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
        {
            "jobId": next_job_id(), "title": "Product Manager, AI", "company": "Microsoft",
            "location": "Redmond, WA", "skillsRequired": ["Product Strategy", "Agile", "AI", "Machine Learning"],
            "description": "Lead the development of our next-generation AI Copilot features.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
        {
            "jobId": next_job_id(), "title": "Data Scientist", "company": "Netflix",
            "location": "Los Gatos, CA", "skillsRequired": ["SQL", "Python", "Machine Learning", "Statistics"],
            "description": "Analyze viewer data to drive content strategy and personalization algorithms.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
        {
            "jobId": next_job_id(), "title": "Frontend Engineer (React)", "company": "Vercel",
            "location": "Remote", "skillsRequired": ["React", "Next.js", "TypeScript", "CSS-in-JS"],
            "description": "Build beautiful and performant web experiences for a global audience.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
    ]
    db["jobs"].insert_many(jobs_to_create)
    print(f"  -> Successfully created {len(jobs_to_create)} jobs.")

    print("\n--- Seeding Complete! ---")
    print("You can now log in with the following test accounts:")
    print("  Recruiters:")
    print("    - Email: recruiter@google.com (Password: password123)")
    print("    - Email: hiring@figma.com (Password: password123)")
    print("  Applicants:")
    print("    - Email: applicant1@email.com (Password: password123)")
    print("    - Email: applicant2@email.com (Password: password123)")
    print("    - Email: applicant3@email.com (Password: password123)")
    print("-------------------------")

if __name__ == "__main__":
    seed_database()
</file>

<file path="scripts/test_denormalized_schema.py">
#!/usr/bin/env python3
"""
Comprehensive Test Suite for Denormalized Application Schema
Tests all workflow features with the new userName/jobTitle/companyName fields
"""
import requests
import json
import sys

# Configuration
API_BASE = "http://localhost:8000"
GRAPHQL_ENDPOINT = f"{API_BASE}/graphql"

# Test Results
test_results = []

def print_header(title):
    """Print a formatted test header"""
    print(f"\n{'='*70}")
    print(f"  {title}")
    print(f"{'='*70}\n")

def execute_graphql(query, user_role="Recruiter"):
    """Execute a GraphQL query"""
    headers = {
        "Content-Type": "application/json",
        "X-User-Role": user_role
    }
    response = requests.post(GRAPHQL_ENDPOINT, json={"query": query}, headers=headers)
    return response.json()

def test_apply_with_denormalized_fields():
    """TEST 1: Apply mutation should save denormalized fields"""
    print_header("TEST 1: Apply Mutation with Denormalized Fields")
    
    # First, create a test user and job
    register_user = requests.post(f"{API_BASE}/register", json={
        "email": "testuser@example.com",
        "password": "test123",
        "firstName": "Test",
        "last Name": "User",
        "role": "Applicant"
    })
    
    if register_user.status_code != 201:
        print(f"‚ùå Failed to create test user: {register_user.text}")
        return False
    
    # Create a test job
    create_job_mutation = """
    mutation {
      createJob(input: {
        title: "Test Engineer"
        company: "TestCorp"
        location: "Remote"
        description: "Test position"
        skillsRequired: ["Testing"]
      }) {
        jobId
        title
        company
      }
    }
    """
    
    job_result = execute_graphql(create_job_mutation, "Recruiter")
    if "errors" in job_result:
        print(f"‚ùå Failed to create job: {job_result['errors']}")
        return False
    
    print(f"‚úÖ Created job: {job_result['data']['createJob']['title']}")
    
    # Now apply to the job
    apply_mutation = """
    mutation {
      apply(
        userName: "Test User"
        jobTitle: "Test Engineer"
        companyName: "TestCorp"
      ) {
        appId
        userName
        jobTitle
        companyName
        status
        candidate {
          firstName
          lastName
        }
      }
    }
    """
    
    apply_result = execute_graphql(apply_mutation, "Applicant")
    
    if "errors" in apply_result:
        print(f"‚ùå Apply mutation failed: {apply_result['errors']}")
        return False
    
    app_data = apply_result["data"]["apply"]
    
    # Verify denormalized fields are saved
    checks = [
        (app_data.get("userName") == "Test User", "userName field"),
        (app_data.get("jobTitle") == "Test Engineer", "jobTitle field"),
        (app_data.get("companyName") == "TestCorp", "companyName field"),
        (app_data.get("status") == "Applied", "status field")
    ]
    
    all_passed = all(check[0] for check in checks)
    
    for passed, field in checks:
        status = "‚úÖ" if passed else "‚ùå"
        print(f"  {status} {field}: {app_data.get(field.split()[0])}")
    
    if all_passed:
        print(f"\n‚úÖ TEST 1 PASSED: All denormalized fields saved correctly!")
    else:
        print(f"\n‚ùå TEST 1 FAILED: Some fields missing or incorrect")
    
    return all_passed

def test_status_update_with_denormalized_query():
    """TEST 2: Status update should query by denormalized fields"""
    print_header("TEST 2: Status Update Using Denormalized Fields")
    
    mutation = """
    mutation {
      updateApplicationStatusByNames(
        userName: "Charlie Brown"
        jobTitle: "Senior Python Developer"
        companyName: "Google"
        newStatus: "Interviewing"
      ) {
        appId
        status
        userName
        jobTitle
        companyName
        candidate {
          firstName
          lastName
          email
        }
      }
    }
    """
    
    result = execute_graphql(mutation, "Recruiter")
    
    if "errors" in result:
        print(f"‚ùå Status update failed: {result['errors']}")
        return False
    
    app_data = result["data"]["updateApplicationStatusByNames"]
    
    # Verify the update worked (using denormalized fields)
    checks = [
        (app_data.get("userName") == "Charlie Brown", "userName matched"),
        (app_data.get("jobTitle") == "Senior Python Developer", "jobTitle matched"),
        (app_data.get("companyName") == "Google", "companyName matched"),
        (app_data.get("status") == "Interviewing", "status updated"),
        (app_data.get("candidate", {}).get("email") is not None, "candidate email present")
    ]
    
    all_passed = all(check[0] for check in checks)
    
    for passed, description in checks:
        status = "‚úÖ" if passed else "‚ùå"
        print(f"  {status} {description}")
    
    if app_data.get("candidate", {}).get("email"):
        print(f"\n  üìß Email should be sent to: {app_data['candidate']['email']}")
    
    if all_passed:
        print(f"\n‚úÖ TEST 2 PASSED: Status update works with denormalized fields!")
    else:
        print(f"\n‚ùå TEST 2 FAILED")
    
    return all_passed

def test_manager_notes_with_denormalized_query():
    """TEST 3: Manager notes should query by denormalized fields"""
    print_header("TEST 3: Manager Notes Using Denormalized Fields")
    
    mutation = """
    mutation {
      addManagerNoteToApplication(
        userName: "Charlie Brown"
        jobTitle: "Senior Python Developer"
        companyName: "Google"
        note: "Excellent interview performance. Strong technical skills."
      ) {
        appId
        notes
        userName
        jobTitle
        candidate {
          firstName
          lastName
        }
      }
    }
    """
    
    result = execute_graphql(mutation, "Recruiter")
    
    if "errors" in result:
        print(f"‚ùå Manager notes failed: {result['errors']}")
        return False
    
    app_data = result["data"]["addManagerNoteToApplication"]
    
    # Verify notes were added
    checks = [
        (app_data.get("userName") == "Charlie Brown", "userName matched"),
        (app_data.get("jobTitle") == "Senior Python Developer", "jobTitle matched"),
        ("Recruiter Note" in app_data.get("notes", ""), "note has timestamp prefix"),
        ("Excellent interview performance" in app_data.get("notes", ""), "note content saved")
    ]
    
    all_passed = all(check[0] for check in checks)
    
    for passed, description in checks:
        status = "‚úÖ" if passed else "‚ùå"
        print(f"  {status} {description}")
    
    print(f"\n  üìù Notes preview:")
    notes = app_data.get("notes", "")
    print(f"  {notes[:100]}..." if len(notes) > 100 else f"  {notes}")
    
    if all_passed:
        print(f"\n‚úÖ TEST 3 PASSED: Manager notes work with denormalized fields!")
    else:
        print(f"\n‚ùå TEST 3 FAILED")
    
    return all_passed

def test_hiring_workflow():
    """TEST 4: Hiring workflow should use denormalized fields"""
    print_header("TEST 4: Hiring Workflow (Job Closure + Mass Emails)")
    
    # First check how many applicants for Netflix
    query = """
    {
      jobs(title: "Data Scientist", company: "Netflix") {
        jobId
        title
        status
        applicationCount
      }
    }
    """
    
    job_result = execute_graphql(query, "Recruiter")
    
    if "errors" in job_result or not job_result.get("data", {}).get("jobs"):
        print(f"‚ùå Failed to query Netflix job")
        return False
    
    job = job_result["data"]["jobs"][0]
    initial_status = job.get("status")
    app_count = job.get("applicationCount", 0)
    
    print(f"  üìä Job Status (before): {initial_status}")
    print(f"  üìä Application Count: {app_count}")
    
    # Hire Ethan Hunt
    mutation = """
    mutation {
      updateApplicationStatusByNames(
        userName: "Ethan Hunt"
        jobTitle: "Data Scientist"
        companyName: "Netflix"
        newStatus: "Hired"
      ) {
        appId
        status
        userName
        jobTitle
        job {
          jobId
          title
          status
        }
      }
    }
    """
    
    result = execute_graphql(mutation, "Recruiter")
    
    if "errors" in result:
        print(f"‚ùå Hiring failed: {result['errors']}")
        return False
    
    app_data = result["data"]["updateApplicationStatusByNames"]
    
    # Verify the workflow
    checks = [
        (app_data.get("status") == "Hired", "candidate marked as Hired"),
        (app_data.get("job", {}).get("status") == "Closed", "job automatically closed"),
        (app_data.get("userName") == "Ethan Hunt", "correct candidate hired")
    ]
    
    all_passed = all(check[0] for check in checks)
    
    for passed, description in checks:
        status = "‚úÖ" if passed else "‚ùå"
        print(f"  {status} {description}")
    
    print(f"\n  ‚öôÔ∏è Background tasks triggered:")
    print(f"     - Job #{app_data['job']['jobId']} closed")
    print(f"     - Rejection emails sent to {app_count - 1} other candidate(s)")
    
    if all_passed:
        print(f"\n‚úÖ TEST 4 PASSED: Hiring workflow works correctly!")
    else:
        print(f"\n‚ùå TEST 4 FAILED")
    
    return all_passed

def test_query_applications_with_denormalized_fields():
    """TEST 5: Query applications and verify denormalized fields exist"""
    print_header("TEST 5: Query Applications with Denormalized Fields")
    
    query = """
    {
      applications(jobId: 1) {
        appId
        userName
        jobTitle
        companyName
        status
      }
    }
    """
    
    result = execute_graphql(query, "Recruiter")
    
    if "errors" in result:
        print(f"‚ùå Query failed: {result['errors']}")
        return False
    
    apps = result["data"]["applications"]
    
    if not apps:
        print(f"  ‚ö†Ô∏è No applications found for job #1")
        return True  # Not a failure, just no data
    
    print(f"  Found {len(apps)} application(s):")
    
    all_have_fields = True
    for app in apps:
        has_fields = all([
            app.get("userName"),
            app.get("jobTitle"),
            app.get("companyName")
        ])
        
        status = "‚úÖ" if has_fields else "‚ùå"
        print(f"  {status} App #{app['appId']}: {app.get('userName')} ‚Üí {app.get('jobTitle')} @ {app.get('companyName')}")
        
        if not has_fields:
            all_have_fields = False
    
    if all_have_fields:
        print(f"\n‚úÖ TEST 5 PASSED: All applications have denormalized fields!")
    else:
        print(f"\n‚ùå TEST 5 FAILED: Some applications missing fields")
    
    return all_have_fields

def run_all_tests():
    """Run all test cases"""
    print_header("COMPREHENSIVE TEST SUITE - Denormalized Application Schema")
    
    tests = [
        ("Apply with Denormalized Fields", test_apply_with_denormalized_fields),
        ("Status Update Query", test_status_update_with_denormalized_query),
        ("Manager Notes Query", test_manager_notes_with_denormalized_query),
        ("Hiring Workflow", test_hiring_workflow),
        ("Query Applications", test_query_applications_with_denormalized_fields),
    ]
    
    results = []
    
    for test_name, test_func in tests:
        try:
            passed = test_func()
            results.append((test_name, passed))
        except Exception as e:
            print(f"\n‚ùå TEST CRASHED: {test_name}")
            print(f"   Error: {e}")
            import traceback
            traceback.print_exc()
            results.append((test_name, False))
    
    # Print summary
    print_header("TEST SUMMARY")
    
    passed_count = sum(1 for _, passed in results if passed)
    total_count = len(results)
    
    for test_name, passed in results:
        status = "‚úÖ PASS" if passed else "‚ùå FAIL"
        print(f"  {status} - {test_name}")
    
    print(f"\n  Total: {passed_count}/{total_count} tests passed")
    
    if passed_count == total_count:
        print(f"\nüéâ ALL TESTS PASSED! Denormalized schema working perfectly!")
        print(f"\nüìß Check Resend dashboard for emails: https://resend.com/emails")
        return 0
    else:
        print(f"\n‚ö†Ô∏è Some tests failed. Review output above.")
        return 1

if __name__ == "__main__":
    try:
        exit_code = run_all_tests()
        sys.exit(exit_code)
    except requests.exceptions.ConnectionError:
        print("‚ùå ERROR: Cannot connect to backend server")
        print("   Make sure it's running: python src/backend/app.py")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n\nTests interrupted by user")
        sys.exit(130)
</file>

<file path="scripts/test_login.py">
import requests
import json

# Test login
response = requests.post(
    "http://localhost:8000/login",
    json={
        "email": "recruiter@google.com",
        "password": "password123"
    }
)

print(f"Status Code: {response.status_code}")
print(f"Response: {response.text}")

if response.status_code == 200:
    data = response.json()
    print(f"\nParsed JSON:")
    print(json.dumps(data, indent=2))
</file>

<file path="scripts/test_nl2gql_denormalized.py">
"""
Test Natural Language Understanding with Denormalized Fields
Verifies the AI can extract userName, jobTitle, companyName from natural language
"""
import requests
import json

API_BASE = "http://localhost:8000"

print("="*70)
print("NATURAL LANGUAGE - DENORMALIZED FIELDS TEST")
print("="*70)

test_queries = [
    {
        "name": "Interview with full details",
        "query": "Interview Charlie Brown for the Senior Python Developer position at Google",
        "expected_mutation": "updateApplicationStatusByNames",
        "expected_fields": {
            "userName": "Charlie Brown",
            "jobTitle": "Senior Python Developer",
            "companyName": "Google"
        }
    },
    {
        "name": "Add manager note",
        "query": "Add a note to Diana Prince's Product Manager application at Meta saying she was excellent",
        "expected_mutation": "addManagerNoteToApplication",
        "expected_fields": {
            "userName": "Diana Prince",
            "jobTitle": "Product Manager",
            "companyName": "Meta"
        }
    },
    {
        "name": "Apply to job",
        "query": "Apply Test User to the Test Engineer job at TestCorp",
        "expected_mutation": "apply",
        "expected_fields": {
            "userName": "Test User",
            "jobTitle": "Test Engineer",
            "companyName": "TestCorp"
        }
    },
    {
        "name": "Hire candidate",
        "query": "Hire Ethan Hunt for Data Scientist at Netflix",
        "expected_mutation": "updateApplicationStatusByNames",
        "expected_fields": {
            "userName": "Ethan Hunt",
            "jobTitle": "Data Scientist",
            "companyName": "Netflix",
            "newStatus": "Hired"
        }
    }
]

for i, test in enumerate(test_queries, 1):
    print(f"\n{i}. {test['name']}")
    print(f"   Query: \"{test['query']}\"")
    
    response = requests.post(
        f"{API_BASE}/nl2gql?run=false",  # Don't run, just generate
        json={"query": test["query"]},
        headers={"X-User-Role": "Recruiter"}
    )
    
    if response.status_code == 200:
        result = response.json()
        graphql = result.get("graphql", "")
        
        # Check if correct mutation
        has_mutation = test["expected_mutation"] in graphql
        
        # Check if all expected fields are present
        all_fields_present = all(
            field in graphql and value in graphql
            for field, value in test["expected_fields"].items()
        )
        
        if has_mutation and all_fields_present:
            print(f"   ‚úÖ PASS - Correct mutation and fields extracted")
            print(f"   Generated: {graphql[:80]}...")
        else:
            print(f"   ‚ùå FAIL")
            print(f"   Expected mutation: {test['expected_mutation']}")
            print(f"   Expected fields: {test['expected_fields']}")
            print(f"   Got: {graphql}")
    else:
        print(f"   ‚ùå ERROR: {response.text}")

print("\n" + "="*70)
print("Natural language processing test complete!")
print("="*70)
</file>

<file path="scripts/test_schedule_smoke.py">
import os
import sys
from datetime import datetime, timedelta
import traceback
from pprint import pprint

# Ensure project root is on sys.path (same approach as other scripts)
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.backend.services import scheduling_service
from src.backend.db import applications_collection, schedules_collection, users_collection, jobs_collection, next_application_id


def main():
    try:
        app = applications_collection().find_one()
        if not app:
            print("No application found in DB. Creating a test application...")
            # Find a job and an applicant user to create a minimal application
            job = jobs_collection().find_one()
            applicant = users_collection().find_one({"role": "Applicant"})
            if not job or not applicant:
                print("Could not find a job or an applicant user to create a test application. Aborting.")
                return
            job_id = job.get("jobId")
            candidate_id = applicant.get("UserID")
            app_doc = {
                "appId": next_application_id(),
                "userId": candidate_id,
                "jobId": job_id,
                "status": "Applied",
                "submittedAt": datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'),
                "notes": "",
                "userName": f"{applicant.get('firstName')} {applicant.get('lastName')}",
                "jobTitle": job.get('title'),
                "companyName": job.get('company')
            }
            applications_collection().insert_one(app_doc)
            app = app_doc
        else:
            job_id = app.get("jobId")
            candidate_id = app.get("userId")

        sched = schedules_collection().find_one()
        if not sched:
            print("No recruiter schedules found. Creating a simple schedule for an available recruiter...")
            recruiter = users_collection().find_one({"role": "Recruiter"})
            if not recruiter:
                print("No recruiter user found to create a schedule. Aborting.")
                return
            recruiter_id = recruiter.get("UserID")
            schedules_collection().insert_one({
                "recruiterId": recruiter_id,
                "availability": [
                    {"dayOfWeek": "Monday", "startTime": "09:00", "endTime": "17:00"},
                    {"dayOfWeek": "Tuesday", "startTime": "09:00", "endTime": "17:00"}
                ]
            })
            sched = schedules_collection().find_one({"recruiterId": recruiter_id})
        recruiter_id = sched.get("recruiterId")

        print(f"Found application: appId={app.get('appId')}, jobId={job_id}, candidateId={candidate_id}")
        print(f"Found recruiter schedule for recruiterId={recruiter_id}")

        start_date = datetime.utcnow()
        end_date = start_date + timedelta(days=7)

        print("Searching for open slots (next 7 days)...")
        open_slots = scheduling_service.find_open_slots(recruiter_id, candidate_id, start_date, end_date, duration_minutes=30)
        print(f"Open slots found: {len(open_slots)}")
        if not open_slots:
            print("No open slots available to book.")
            return

        # Pick the first available slot and book
        slot_iso = open_slots[0]
        start_time = datetime.fromisoformat(slot_iso)
        end_time = start_time + timedelta(minutes=30)

        print(f"Attempting to book interview at {start_time.isoformat()} - {end_time.isoformat()}")
        interview = scheduling_service.book_interview(job_id, candidate_id, recruiter_id, start_time, end_time)
        print("Interview booked:")
        pprint(interview)

    except Exception as e:
        print("Exception during smoke test:")
        traceback.print_exc()

if __name__ == '__main__':
    main()
</file>

<file path="scripts/test_smtp_config.py">
# scripts/test_smtp_config.py
import os
import smtplib
import ssl
from email.mime.text import MIMEText
from dotenv import load_dotenv

# --- 1. Load Environment Variables (Critical for isolation) ---
# We load the .env files explicitly to ensure config visibility
load_dotenv(os.path.join(os.path.dirname(__file__), '../src/.env'))
load_dotenv(os.path.join(os.path.dirname(__file__), '../src/backend/.env'))

# --- 2. Configuration & Test Data ---
SMTP_HOST = os.getenv("EMAIL_HOST")
SMTP_PORT = int(os.getenv("EMAIL_PORT", 587))
SMTP_USERNAME = os.getenv("EMAIL_USERNAME")
SMTP_PASSWORD = os.getenv("EMAIL_PASSWORD") # This is the App Password
SENDER_EMAIL = SMTP_USERNAME 
TEST_RECIPIENT = SMTP_USERNAME # Sending test email to self

def run_smtp_test():
    """Reads environment and attempts a connection/login/send test."""
    print("="*60)
    print("EMAIL CONFIGURATION & SMTP DIAGNOSTIC TEST")
    print("="*60)
    
    # Check 1: Verify Configuration Read
    if not all([SMTP_HOST, SMTP_USERNAME, SMTP_PASSWORD]):
        print("‚ùå CONFIGURATION FAILURE: One or more critical variables are missing.")
        print(f"  HOST: {SMTP_HOST}")
        print(f"  USER: {SMTP_USERNAME}")
        print(f"  PASS: {'SET' if SMTP_PASSWORD else 'NOT SET'}")
        print("="*60)
        return

    print("‚úÖ Configuration variables read successfully.")
    print(f"   HOST: {SMTP_HOST}:{SMTP_PORT}")
    print(f"   USER: {SMTP_USERNAME}")
    print(f"   RECIPIENT: {TEST_RECIPIENT}")
    print("-"*60)
    
    # Check 2: Attempt SMTP Connection and Authentication
    context = ssl.create_default_context()
    subject = "SMTP Diagnostic Test from JobChat.AI"
    html_body = "<p>If you received this email, your SMTP configuration is correct!</p>"
    
    message = MIMEText(html_body, 'html')
    message['Subject'] = subject
    message['From'] = SENDER_EMAIL
    message['To'] = TEST_RECIPIENT

    try:
        print("Attempting connection and login...")
        with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
            server.starttls(context=context)
            server.login(SMTP_USERNAME, SMTP_PASSWORD)
            server.sendmail(SENDER_EMAIL, TEST_RECIPIENT, message.as_string())
        
        print("\nüéâüéâüéâ TEST SUCCESS! üéâüéâüéâ")
        print("The test email should be in your inbox shortly.")
        print("Your SMTP configuration is CORRECT.")
        
    except smtplib.SMTPAuthenticationError:
        print("\n‚ùå AUTHENTICATION FAILURE!")
        print("  Reason: Incorrect App Password or Gmail settings are blocking the login.")
        print("  Action: GENERATE A NEW APP PASSWORD (see previous instructions).")
        
    except smtplib.SMTPServerDisconnected:
        print("\n‚ùå CONNECTION FAILURE: Server Disconnected.")
        print("  Reason: Host or Port might be incorrect, or a firewall is blocking port 587.")
        
    except Exception as e:
        print(f"\n‚ùå UNHANDLED SMTP ERROR: {type(e).__name__}: {e}")
        print("  Action: Check firewall or other network/server settings.")
        
    print("="*60)

if __name__ == "__main__":
    run_smtp_test()
</file>

<file path="scripts/test_workflow.py">
# scripts/test_workflow.py
"""
Comprehensive test script for Interview Workflow Automation
Tests all features: status updates, email notifications, job closure, and manager notes
"""
import os
import sys
import requests
import json

# Setup path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Configuration
API_BASE = "http://localhost:8000"
GRAPHQL_ENDPOINT = f"{API_BASE}/graphql"

# Test user credentials - note this app uses X-User-Role header, not tokens
RECRUITER_EMAIL = "recruiter@google.com"
RECRUITER_PASSWORD = "password123"

def print_section(title):
    """Print a formatted section header"""
    print(f"\n{'='*70}")
    print(f"  {title}")
    print(f"{'='*70}\n")

def execute_graphql(query, variables=None, user_role="Recruiter"):
    """Execute a GraphQL query with role-based auth"""
    headers = {
        "Content-Type": "application/json",
        "X-User-Role": user_role  # This app uses header-based auth
    }
    
    payload = {"query": query}
    if variables:
        payload["variables"] = variables
    
    response = requests.post(GRAPHQL_ENDPOINT, json=payload, headers=headers)
    return response.json()

def verify_credentials():
    """Verify recruiter credentials"""
    print("üîê Verifying recruiter credentials...")
    
    response = requests.post(
        f"{API_BASE}/login",
        json={
            "email": RECRUITER_EMAIL,
            "password": RECRUITER_PASSWORD
        }
    )
    
    if response.status_code != 200:
        print(f"‚ùå Login failed: {response.text}")
        return False
    
    result = response.json()
    user = result.get("user")
    
    print(f"‚úÖ Credentials verified: {user['firstName']} {user['lastName']} (Role: {user['role']})")
    print(f"   Using X-User-Role header for GraphQL requests\n")
    return True

def test_status_update_interviewing():
    """Test 1: Update application status to 'Interviewing' (triggers email)"""
    print_section("TEST 1: Status Update to 'Interviewing' (Email Notification)")
    
    mutation = """
    mutation {
      updateApplicationStatusByNames(
        userName: "Charlie Brown"
        jobTitle: "Senior Python Developer"
        companyName: "Google"
        newStatus: "Interviewing"
      ) {
        appId
        status
        candidate {
          firstName
          lastName
          email
        }
        job {
          title
          company
        }
      }
    }
    """
    
    print("üìù Updating Charlie Brown's application to 'Interviewing'...")
    result = execute_graphql(mutation, user_role="Recruiter")
    
    if "errors" in result:
        print(f"‚ùå Test failed: {result['errors']}")
        return False
    
    data = result["data"]["updateApplicationStatusByNames"]
    print(f"‚úÖ Status updated successfully!")
    print(f"   Application ID: {data['appId']}")
    print(f"   New Status: {data['status']}")
    print(f"   Candidate: {data['candidate']['firstName']} {data['candidate']['lastName']}")
    print(f"   Email: {data['candidate']['email']}")
    print(f"   Job: {data['job']['title']} at {data['job']['company']}")
    print(f"\nüìß Interview invitation email should be sent to: {data['candidate']['email']}")
    return True

def test_manager_notes():
    """Test 2: Add manager notes to an application"""
    print_section("TEST 2: Add Manager Notes")
    
    mutation = """
    mutation {
      addManagerNoteToApplication(
        userName: "Charlie Brown"
        jobTitle: "Senior Python Developer"
        companyName: "Google"
        note: "Excellent technical skills, great cultural fit. Recommend moving to final round."
      ) {
        appId
        notes
        candidate {
          firstName
          lastName
        }
      }
    }
    """
    
    print("üìù Adding manager note to Charlie Brown's application...")
    result = execute_graphql(mutation, user_role="Recruiter")
    
    if "errors" in result:
        print(f"‚ùå Test failed: {result['errors']}")
        return False
    
    data = result["data"]["addManagerNoteToApplication"]
    print(f"‚úÖ Note added successfully!")
    print(f"   Application ID: {data['appId']}")
    print(f"   Notes:\n{data['notes']}\n")
    return True

def test_hiring_workflow():
    """Test 3: Hire a candidate (triggers job closure + mass rejection emails)"""
    print_section("TEST 3: Hiring Workflow (Job Closure + Mass Notifications)")
    
    # First, check how many applications exist for Netflix job
    query = """
    {
      jobs(title: "Data Scientist", company: "Netflix") {
        jobId
        title
        company
        status
      }
    }
    """
    
    print("üìä Finding Netflix Data Scientist job...")
    result =execute_graphql(query, user_role="Recruiter")
    job = result["data"]["jobs"][0]
    job_id = job["jobId"]
    
    # Get applications for this job
    apps_query = f"""
    {{
      applications(jobId: {job_id}) {{
        appId
        status
        candidate {{
          firstName
          lastName
          email
        }}
      }}
    }}
    """
    
    apps_result = execute_graphql(apps_query, user_role="Recruiter")
    apps = apps_result["data"]["applications"]
    print(f"   Found {len(apps)} applications:")
    for app in apps:
        print(f"   - {app['candidate']['firstName']} {app['candidate']['lastName']} ({app['status']})")
    
    # Now hire Ethan Hunt
    mutation = """
    mutation {
      updateApplicationStatusByNames(
        userName: "Ethan Hunt"
        jobTitle: "Data Scientist"
        companyName: "Netflix"
        newStatus: "Hired"
      ) {
        appId
        status
        candidate {
          firstName
          lastName
          email
        }
        job {
          jobId
          title
          company
          status
        }
      }
    }
    """
    
    print(f"\nüìù Hiring Ethan Hunt for Data Scientist at Netflix...")
    result = execute_graphql(mutation, user_role="Recruiter")
    
    if "errors" in result:
        print(f"‚ùå Test failed: {result['errors']}")
        return False
    
    data = result["data"]["updateApplicationStatusByNames"]
    print(f"‚úÖ Candidate hired successfully!")
    print(f"   Hired: {data['candidate']['firstName']} {data['candidate']['lastName']}")
    print(f"   Job Status: {data['job']['status']}")
    print(f"\n‚öôÔ∏è Automated workflow triggered:")
    print(f"   1. Job marked as 'Closed'")
    print(f"   2. Rejection emails sent to other {len(apps) - 1} applicant(s):")
    for app in apps:
        if app['candidate']['firstName'] != 'Ethan':
            print(f"      - {app['candidate']['email']} ({app['candidate']['firstName']} {app['candidate']['lastName']})")
    
    # Verify job status changed
    job_query = f"""
    {{
      jobById(jobId: {job_id}) {{
        jobId
        title
        status
      }}
    }}
    """
    
    print(f"\nüîç Verifying job status...")
    job_result = execute_graphql(job_query, user_role="Recruiter")
    job = job_result["data"]["jobById"]
    print(f"   Job #{job['jobId']}: {job['title']}")
    print(f"   Status: {job['status']}")
    
    if job['status'] == 'Closed':
        print(f"   ‚úÖ Job successfully closed!")
    else:
        print(f"   ‚ùå Job status not updated!")
        return False
    
    return True

def test_natural_language():
    """Test 4: Natural language commands via NL2GQL"""
    print_section("TEST 4: Natural Language Commands")
    
    # Test updating status via NL
    nl_request = "Interview Diana Prince for the Product Manager position at Meta"
    
    print(f"üí¨ Natural Language: \"{nl_request}\"")
    response = requests.post(
        f"{API_BASE}/nl2gql?run=true",
        json={"query": nl_request},
        headers={"X-User-Role": "Recruiter"}
    )
    
    result = response.json()
    
    if "error" in result:
        print(f"‚ùå Test failed: {result['error']}")
        return False
    
    print(f"‚úÖ GraphQL Generated:")
    print(f"   {result.get('graphql', 'N/A')}")
    
    if "result" in result and "data" in result["result"]:
        data = result["result"]["data"]
        if "updateApplicationStatusByNames" in data:
            app_data = data["updateApplicationStatusByNames"]
            print(f"\n‚úÖ Status updated via natural language!")
            print(f"   Candidate: {app_data['candidate']['firstName']} {app_data['candidate']['lastName']}")
            print(f"   New Status: {app_data['status']}")
            print(f"   üìß Email sent to: {app_data['candidate']['email']}")
    
    return True

def run_all_tests():
    """Run all workflow tests"""
    print_section("INTERVIEW WORKFLOW AUTOMATION - COMPREHENSIVE TEST SUITE")
    
    # Step 1: Verify credentials
    if not verify_credentials():
        print("‚ùå Cannot proceed without valid credentials")
        return
    
    # Step 2: Run tests
    tests = [
        ("Status Update (Interviewing)", test_status_update_interviewing),
        ("Manager Notes", test_manager_notes),
        ("Hiring Workflow (Job Closure + Mass Rejection)", test_hiring_workflow),
        ("Natural Language Commands", test_natural_language),
    ]
    
    results = []
    for test_name, test_func in tests:
        try:
            success = test_func()
            results.append((test_name, success))
        except Exception as e:
            print(f"‚ùå Test '{test_name}' crashed: {e}")
            import traceback
            traceback.print_exc()
            results.append((test_name, False))
    
    # Step 3: Print summary
    print_section("TEST SUMMARY")
    passed = sum(1 for _, success in results if success)
    total = len(results)
    
    for test_name, success in results:
        status = "‚úÖ PASS" if success else "‚ùå FAIL"
        print(f"  {status} - {test_name}")
    
    print(f"\n  Total: {passed}/{total} tests passed")
    
    if passed == total:
        print(f"\nüéâ All tests passed! The workflow automation is working perfectly.")
    else:
        print(f"\n‚ö†Ô∏è Some tests failed. Please review the output above.")
    
    print(f"\nüìß Check your Resend dashboard to verify emails were sent:")
    print(f"   https://resend.com/emails")

if __name__ == "__main__":
    try:
        run_all_tests()
    except requests.exceptions.ConnectionError:
        print("‚ùå ERROR: Cannot connect to the backend server.")
        print("   Please make sure the Flask server is running on http://localhost:8000")
        print("   Run: python src/backend/app.py")
</file>

<file path="src/backend/models/user_models.py">
# JPA/src/backend/models/user_models.py

from enum import Enum

class UserProfileType(Enum):
    APPLICANT = "Applicant"
    RECRUITER = "Recruiter"

    @classmethod
    def from_str(cls, value: str):
        try:
            return cls(value.title())
        except ValueError:
            raise ValueError(f"Invalid ProfileType: {value}. Must be one of: Applicant, Recruiter")
            
def get_user_profile_types():
    return [e.value for e in UserProfileType]
</file>

<file path="src/backend/validators/common_validators.py">
import re
from typing import Optional, Dict, Any

DATE_RE = re.compile(r"^\d{4}-\d{2}-\d{2}$")

def require_non_empty_str(value: Optional[str], field: str) -> str:
    if value is None or (isinstance(value, str) and value.strip() == ""):
        raise ValueError(f"{field} must be a non-empty string")
    return value.strip()

def validate_date_str(value: Optional[str]) -> Optional[str]:
    if value is None or value == "":
        return None
    if not DATE_RE.match(value):
        raise ValueError("DateOfBirth must be in YYYY-MM-DD format")
    return value

def clean_update_input(input_data: Dict[str, Any]) -> Dict[str, Any]:
    return {k: v for k, v in (input_data or {}).items() if v is not None}
</file>

<file path="src/frontend-react/package.json">
{
  "name": "job-portal-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.6.8",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="src/frontend-react/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Job Seeker Chat</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
</file>

<file path="src/frontend-react/src/CompleteProfilePage.js">
// src/frontend-react/src/CompleteProfilePage.js
import React, { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import apiClient from './api';
import './App.css'; // Reuse styles

const CompleteProfilePage = () => {
  const { userId } = useParams(); // Get the UserID from the URL
  const navigate = useNavigate();
  const [file, setFile] = useState(null);
  const [status, setStatus] = useState('idle');
  const [errorMessage, setErrorMessage] = useState('');

  const handleFileChange = (e) => {
    setFile(e.target.files[0]);
  };

  const handleUpload = async () => {
    if (!file) {
      setErrorMessage('Please select a resume file to upload.');
      return;
    }

    const formData = new FormData();
    formData.append('resume', file);
    
    setStatus('uploading');
    setErrorMessage('');

    try {
      await apiClient.post(`/users/${userId}/resume`, formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      setStatus('success');
      alert('Success! Your profile is being updated with your resume details.');
      navigate('/login'); // Redirect to login after success
    } catch (error) {
      setStatus('error');
      const msg = error.response?.data?.error || 'Upload failed. Please try again.';
      setErrorMessage(msg);
    }
  };

  return (
    <div className="login-container">
      <div className="resume-uploader-panel" style={{ maxWidth: '500px' }}>
        <h2>Welcome! Your account is created.</h2>
        <p>Optionally, you can upload your resume now to auto-fill your profile details.</p>
        
        <div className="uploader-controls">
          <input type="file" onChange={handleFileChange} accept=".pdf,.docx" disabled={status === 'uploading'} />
          <button onClick={handleUpload} disabled={status === 'uploading'}>
            {status === 'uploading' ? 'Analyzing...' : 'Upload & Auto-Fill'}
          </button>
        </div>
        
        <button onClick={() => navigate('/login')} className="skip-button" style={{ marginTop: '20px' }}>
          Skip for Now
        </button>
        
        {status === 'error' && <p className="status-error" style={{ marginTop: '15px' }}>‚ùå {errorMessage}</p>}
      </div>
    </div>
  );
};

export default CompleteProfilePage;
</file>

<file path="src/frontend-react/src/LoginPage.css">
/* src/frontend-react/src/App.css */

/* --- Add these styles to the end of the file --- */

.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background-color: var(--background-color);
}

.login-form {
  padding: 40px;
  background-color: var(--card-background);
  border-radius: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  width: 100%;
  max-width: 400px;
  text-align: center;
}

.login-form h2 {
  margin-bottom: 25px;
  color: var(--text-color);
}

.input-group {
  margin-bottom: 20px;
  text-align: left;
}

.input-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: 600;
  color: var(--text-color);
}

.input-group input {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--border-color);
  border-radius: 5px;
  background-color: var(--input-bg);
  color: var(--text-color);
  box-sizing: border-box; /* Ensures padding doesn't affect width */
}

.login-button {
  width: 100%;
  padding: 12px;
  background-color: var(--button-bg);
  color: var(--button-text);
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  transition: background-color 0.2s;
}

.login-button:hover {
  background-color: #0b5cb0;
}

.toggle-form {
  margin-top: 20px;
  font-size: 14px;
}

.toggle-button {
  background: none;
  border: none;
  color: var(--button-bg);
  cursor: pointer;
  font-weight: bold;
  padding: 0 5px;
  font-size: 14px;
}

.input-group select {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--border-color);
  border-radius: 5px;
  background-color: var(--input-bg);
  color: var(--text-color);
  box-sizing: border-box;
  font-size: 16px; /* Match input font-size */
  font-family: inherit; /* Inherit font from parent */
  -webkit-appearance: none; /* Removes default browser styling on Safari/Chrome */
  -moz-appearance: none; /* Removes default browser styling on Firefox */
  appearance: none;
  background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23666%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
  background-repeat: no-repeat;
  background-position: right 1rem center;
  background-size: 0.65em auto;
}
</file>

<file path="src/frontend-react/src/ResumeUploader.js">
// src/frontend-react/src/ResumeUploader.js
import React, { useState } from 'react';
import apiClient from './api';
import './App.css'; // Reuse some styles

const ResumeUploader = ({ target, onComplete }) => {
  const [file, setFile] = useState(null);
  const [status, setStatus] = useState('idle'); // idle | uploading | success | error
  const [errorMessage, setErrorMessage] = useState('');

  const handleFileChange = (e) => {
    setFile(e.target.files[0]);
  };

  const handleUpload = async () => {
    if (!file) {
      setErrorMessage('Please select a file first.');
      return;
    }
    
    const formData = new FormData();
    formData.append('resume', file);
    
    setStatus('uploading');
    setErrorMessage('');

    try {
      await apiClient.post(`/applications/${target.appId}/resume`, formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      setStatus('success');
      // Automatically close the uploader after 2 seconds
      setTimeout(() => onComplete(), 2000);
    } catch (error) {
      setStatus('error');
      const msg = error.response?.data?.error || 'Upload failed. Please try again.';
      setErrorMessage(msg);
    }
  };

  return (
    <div className="resume-uploader-panel">
      <h4>Application for "{target.jobTitle}" successful!</h4>
      <p>Next, please upload your resume (PDF or DOCX).</p>
      
      {status !== 'success' && (
        <div className="uploader-controls">
          <input type="file" onChange={handleFileChange} accept=".pdf,.docx" disabled={status === 'uploading'} />
          <button onClick={handleUpload} disabled={status === 'uploading'}>
            {status === 'uploading' ? 'Uploading...' : 'Upload Resume'}
          </button>
          <button onClick={onComplete} className="skip-button" disabled={status === 'uploading'}>Skip for now</button>
        </div>
      )}
      
      {status === 'success' && <p className="status-success">‚úÖ Resume uploaded successfully!</p>}
      {status === 'error' && <p className="status-error">‚ùå {errorMessage}</p>}
    </div>
  );
};

export default ResumeUploader;
</file>

<file path="src/frontend-react/src/SchedulingPanel.js">
import React, { useState, useEffect } from 'react';
import apiClient from './api';
import './App.css'; // Reuses styles

const SchedulingPanel = ({ target, onClose, recruiterId }) => {
  const [slots, setSlots] = useState(null);
  const [status, setStatus] = useState('loading'); // loading | loaded | error | confirmed | confirming
  const [error, setError] = useState('');

  // --- Step 1: Fetch Available Slots on Load ---
  useEffect(() => {
    const fetchSlots = async () => {
      try {
        // Query the new resolver: findAvailableSlots
        const response = await apiClient.post('/graphql', {
          query: `
            query FindSlots($candidateId: Int!) {
              findAvailableSlots(candidateId: $candidateId, durationMinutes: 30, numDays: 7)
            }
          `,
          variables: { candidateId: target.candidateId },
        });

        const availableSlots = response.data.data.findAvailableSlots;
        setSlots(availableSlots || []);
        setStatus('loaded');
      } catch (err) {
        console.error("Error fetching slots:", err);
        setError("Failed to fetch slots. Is your Recruiter availability set?");
        setStatus('error');
      }
    };
    fetchSlots();
  }, [target.candidateId]);

  // --- Step 2: Book the Chosen Slot ---
  const handleBookSlot = async (startTimeISO) => {
    setStatus('confirming');
    setError('');
    const endTime = new Date(new Date(startTimeISO).getTime() + 30 * 60000).toISOString(); // Calculate +30 min

    try {
      const response = await apiClient.post('/graphql', {
        query: `
          mutation BookInterview($jobId: Int!, $candidateId: Int!, $startTime: String!, $endTime: String!) {
            bookInterview(
              jobId: $jobId,
              candidateId: $candidateId,
              startTime: $startTime,
              endTime: $endTime
            ) {
              interviewId
              startTime
              candidate { firstName }
            }
          }
        `,
        variables: {
          jobId: target.jobId,
          candidateId: target.candidateId,
          startTime: startTimeISO,
          endTime: endTime,
        },
      });

      if (response.data.errors) {
        throw new Error(response.data.errors[0].message);
      }

      setStatus('confirmed');
      // The email and status update are handled by the backend book_interview service now!

    } catch (err) {
      console.error("Booking Error:", err);
      setError(err.message && typeof err.message === 'string' && err.message.includes("Conflict detected") ? "Conflict: That slot was just booked or is unavailable!" : (err.message || 'Booking failed'));
      setStatus('loaded'); // Return to selection screen on soft error
    }
  };
  
  // Helper to format ISO string to readable time
  const formatTime = (isoString) => {
    return new Date(isoString).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  // Helper to format ISO string to readable date
  const formatDate = (isoString) => {
      return new Date(isoString).toLocaleDateString([], { weekday: 'short', month: 'short', day: 'numeric' });
  }

  // --- Render Logic ---
  return (
    <div className="scheduling-panel">
      <h3>Schedule Interview with {target.candidateName}</h3>
      <p>Role: {target.jobTitle}</p>

      {status === 'loading' && <p>Searching for conflict-free slots...</p>}
      
      {status === 'error' && <p className="status-error">‚ùå {error}</p>}

      {status === 'confirming' && <p>Booking selected slot...</p>}

      {status === 'confirmed' && (
        <div className="status-success">
          ‚úÖ Interview successfully booked and invitation sent!
        </div>
      )}

      {status === 'loaded' && (
        <>
          <p>Select an available 30-minute slot:</p>
          <div className="slot-list">
            {slots && slots.length > 0 ? (
              slots.map((slot, index) => (
                <button
                  key={index}
                  className="slot-button"
                  onClick={() => handleBookSlot(slot)}
                >
                  {formatDate(slot)} at {formatTime(slot)}
                </button>
              ))
            ) : (
              <p>No open slots found for the next 7 days. Please check Recruiter availability.</p>
            )}
          </div>
          {error && <p className="status-error" style={{marginTop: '10px'}}>‚ùå {error}</p>}
        </>
      )}
      
      <button onClick={onClose} className="skip-button" style={{ marginTop: '20px' }} disabled={status === 'confirming'}>
        {status === 'confirmed' ? 'Done' : 'Cancel'}
      </button>
    </div>
  );
};

export default SchedulingPanel;
</file>

<file path="WORKFLOW_DIAGRAM.txt">
# WORKFLOW VISUALIZATION - Interview Automation System

## COMPLETE USER JOURNEY MAP

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     RECRUITER JOURNEY                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. CREATE ACCOUNT
   POST /register
   { email, password, firstName, lastName, role: "Recruiter" }
   ‚Üì
2. LOGIN
   POST /login
   ‚Üí Receive user info (no token needed)
   ‚Üí Use X-User-Role: Recruiter header for all GraphQL requests
   ‚Üì
3. POST A JOB
   mutation { createJob(...) }
   ‚Üí Job created with status: null or "Open"
   ‚Üì
4. WAIT FOR APPLICATIONS
   ‚Üê Applicants apply to your job
   ‚Üì
5. REVIEW APPLICATIONS
   { jobs(...) { applicants { ... } } }
   { applications(jobId: X) { ... } }
   ‚Üì
6. INVITE TO INTERVIEW ‚≠ê [TRIGGERS EMAIL]
   mutation {
     updateApplicationStatusByNames(
       status: "Interviewing"
     )
   }
   ‚úâÔ∏è ‚Üí Interview invitation email sent to candidate
   ‚Üì
7. ADD MANAGER NOTES ‚≠ê [NEW FEATURE]
   mutation {
     addManagerNoteToApplication(
       note: "Great interview..."
     )
   }
   ‚Üí Timestamped note appended
   ‚Üì
8. HIRE CANDIDATE ‚≠ê [TRIGGERS AUTOMATION]
   mutation {
     updateApplicationStatusByNames(
       status: "Hired"
     )
   }
   ‚Üí ü§ñ AUTOMATED WORKFLOW:
      1. Mark application as "Hired"
      2. Close the job (status: "Closed")
      3. Find all other applicants for this job
      4. Send rejection emails to all unsuccessful candidates
   ‚úâÔ∏è ‚Üí Mass rejection emails sent (background thread)


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     APPLICANT JOURNEY                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. CREATE ACCOUNT
   POST /register
   { email, password, firstName, lastName, role: "Applicant" }
   ‚Üì
2. UPDATE PROFILE
   mutation {
     updateUser(
       skills: [...]
       years_of_experience: X
       professionalTitle: "..."
     )
   }
   ‚Üì
3. (OPTIONAL) UPLOAD RESUME
   POST /users/{userId}/resume
   ‚Üí PDF/DOCX parsed automatically
   ‚Üí Skills extracted and added to profile
   ‚Üì
4. SEARCH FOR JOBS
   { jobs(location: "...", title: "...") { ... } }
   ‚Üì
5. APPLY TO JOB
   mutation {
     apply(
       userName: "Your Name"
       jobTitle: "Job Title"
       companyName: "Company"
     )
   }
   ‚Üí Application created with status: "Applied"
   ‚Üì
6. ADD APPLICATION NOTE (Optional)
   mutation {
     addNoteToApplicationByJob(
       jobTitle: "..."
       note: "Why I'm interested..."
     )
   }
   ‚Üì
7. WAIT FOR RECRUITER DECISION
   ‚Üì
8. RECEIVE EMAIL ‚≠ê [AUTOMATED]
   
   If status ‚Üí "Interviewing":
   ‚úâÔ∏è Receive interview invitation email
   
   If someone else hired for same job:
   ‚úâÔ∏è Receive rejection notification email


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     EMAIL AUTOMATION FLOWS                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

FLOW 1: INTERVIEW INVITATION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Trigger: updateApplicationStatusByNames(newStatus: "Interviewing")
‚Üì
Check: newStatus == "Interviewing" ?
‚Üì YES
email_service.send_interview_invitation(
  to: candidate.email
  name: candidate.firstName
  job: job.title
  company: job.company
)
‚Üì
‚úâÔ∏è Email sent via Resend API
Subject: "Interview Invitation for {job} position at {company}"
Template: Congratulatory + next steps


FLOW 2: AUTOMATED JOB CLOSURE & MASS REJECTION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Trigger: updateApplicationStatusByNames(newStatus: "Hired")
‚Üì
Check: newStatus == "Hired" ?
‚Üì YES
Start Background Thread ‚Üí _handle_hired_status_side_effects()
‚îÇ
‚îú‚îÄ Step 1: Close the job
‚îÇ  job_repo.update_one(jobId, {status: "Closed"})
‚îÇ
‚îú‚îÄ Step 2: Find all other applications for this job
‚îÇ  applications = find({ jobId: X, userId: {$ne: hired_user_id} })
‚îÇ
‚îî‚îÄ Step 3: Send rejection emails to each
   for app in applications:
     if app.status not in ["Hired", "Rejected"]:
       email_service.send_rejection_notification(
         to: candidate.email
         name: candidate.firstName
         job: job.title
         company: job.company
       )
‚Üì
‚úâÔ∏è Multiple emails sent via Resend API
Subject: "Update on your application for {job} at {company}"
Template: Professional rejection + best wishes


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  AUTHORIZATION & SECURITY                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

All GraphQL requests use header-based auth:
  X-User-Role: "Recruiter" or "Applicant"

RECRUITER-ONLY MUTATIONS:
  ‚úì updateApplicationStatusByNames
  ‚úì addManagerNoteToApplication
  ‚úì updateJobByFields
  ‚úì deleteJobByFields

APPLICANT-ONLY MUTATIONS:
  ‚úì addNoteToApplicationByJob (only own applications)

SHARED MUTATIONS:
  ‚úì apply (anyone can apply)
  ‚úì updateUser (only own profile)


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  DATABASE STATE CHANGES                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

APPLICATION STATUS LIFECYCLE:
  Applied ‚Üí Interviewing ‚Üí Hired
  Applied ‚Üí Interviewing ‚Üí Rejected
  Applied ‚Üí Rejected

JOB STATUS LIFECYCLE:
  null/Open ‚Üí Closed (when someone hired)

NOTES FIELD (Applications):
  "Applicant note"
  ‚Üì (recruiter adds note)
  "Applicant note
   --- Recruiter Note (2025-11-23): Manager feedback here"
  ‚Üì (recruiter adds another note)
  "Applicant note
   --- Recruiter Note (2025-11-23): Manager feedback here
   --- Recruiter Note (2025-11-24): Follow-up feedback"


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  NATURAL LANGUAGE EXAMPLES                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

POST /nl2gql?run=true
Header: X-User-Role: Recruiter

Example Queries:
  "Interview Charlie Brown for the Google job"
  ‚Üí Generates: updateApplicationStatusByNames(...)
  
  "Hire Diana Prince for Product Manager at Meta"
  ‚Üí Generates: updateApplicationStatusByNames(..., newStatus: "Hired")
  ‚Üí Triggers: Email automation
  
  "Add note to Bob's application: Great coding skills"
  ‚Üí Generates: addManagerNoteToApplication(...)
  
  "Show me all applicants for the Netflix job"
  ‚Üí Generates: jobs(company: "Netflix") { applicants { ... } }


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  TESTING CHECKLIST                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚ñ° Recruiter can create account
‚ñ° Recruiter can post a job  
‚ñ° Applicant can create account
‚ñ° Applicant can update profile
‚ñ° Applicant can apply to job
‚ñ° Recruiter can view applications
‚ñ° Recruiter can update status to "Interviewing"
  ‚ñ° Email sent to candidate ‚úâÔ∏è
  ‚ñ° Email visible in Resend dashboard
‚ñ° Recruiter can add manager notes
  ‚ñ° Notes are timestamped
  ‚ñ° Multiple notes preserved
‚ñ° Recruiter can hire a candidate
  ‚ñ° Job automatically closed
  ‚ñ° Other applicants receive rejection emails ‚úâÔ∏è
  ‚ñ° All emails visible in Resend dashboard
‚ñ° Natural language commands work
  ‚ñ° Interview command works
  ‚ñ° Hire command works
  ‚ñ° Note command works

Email Dashboard: https://resend.com/emails
```
</file>

<file path="README.md">
# JobChat.AI - Conversational Job Portal

**JobChat.AI** is a modern web application that redefines how users interact with a job portal.  
It features a **conversational AI interface** allowing users to find jobs, manage applications, and query user data using plain English.  
The backend service translates natural language into **GraphQL** queries, offering a seamless and intuitive user experience.

---

## üöÄ Key Features

- **Conversational AI Interface**  
  A React-based chat UI where users can type requests like  
  _"show me all python jobs in San Francisco"_ or _"create a user named Jane Doe"_.

- **NL2GQL Service**  
  A powerful backend service that uses an LLM (Large Language Model) to translate natural language into executable GraphQL queries in real time.

- **Secure User Authentication**  
  Full registration and login system with REST endpoints. Passwords are securely hashed using `bcrypt`.

- **Rich Frontend Experience**  
  A responsive single-page application built with React, featuring:
  - Client-side routing with React Router (`/login`, `/chat`)
  - Session management to keep users logged in
  - Clean, formatted results display for database queries
  - Collapsible view to inspect raw GraphQL and JSON data
  - Dark/Light mode theme toggle

- **Robust Backend (Python + Flask)**  
  - GraphQL API for structured data access (`/graphql`)
  - REST endpoints for authentication (`/login`, `/register`)
  - Dedicated endpoint for the NL2GQL service (`/nl2gql`)

---

## üß† Tech Stack

### Backend
- **Framework:** Python, Flask  
- **API:** Ariadne (GraphQL), REST  
- **Database:** MongoDB (via PyMongo)  
- **Security:** bcrypt  
- **AI Service:** Ollama (or any compatible LLM endpoint)

### Frontend
- **Library:** React  
- **Routing:** React Router (`react-router-dom`)  
- **HTTP Client:** Axios  
- **Styling:** Plain CSS with theme variables  

---

## üìÅ Repository Layout

| Path | Description |
|------|--------------|
| `src/backend/app.py` | Main Flask app with REST and GraphQL endpoints |
| `src/backend/schema.graphql` | Defines the GraphQL schema |
| `src/backend/services/nl2gql_service.py` | Translates natural language ‚Üí GraphQL |
| `src/backend/repository/` | Data access layer for MongoDB collections (`accounts`, `jobs`, etc.) |
| `src/backend/resolvers/` | Business logic for the GraphQL API |
| `src/frontend-react/src/App.js` | Main React component with routing |
| `src/frontend-react/src/LoginPage.js` | Login and registration form |
| `src/frontend-react/src/ResultsDisplay.js` | Renders formatted query results in chat |

---

## ‚öôÔ∏è Prerequisites

- **Python 3.10+** and `pip`  
- **Node.js v16+** and `npm`  
- **MongoDB** (running instance)  
- **(Optional)** Git for cloning the repository  

---

## üß© Setup Instructions

### 1Ô∏è‚É£ Clone the Repository
```bash
git clone <your-repository-url>
cd <repository-folder>


2Ô∏è‚É£ Backend Setup
Create Virtual Environment
# For Unix/macOS
python3 -m venv .venv
source .venv/bin/activate

# For Windows
python -m venv .venv
.\.venv\Scripts\Activate.ps1

Install Dependencies
pip install -r requirements.txt

Configure Environment Variables

Create a file at src/backend/.env with the following:

# src/backend/.env

# MongoDB connection string
MONGO_URI=mongodb://localhost:2717/
DB_NAME=jobtracker

# LLM service endpoint and credentials
OLLAMA_HOST=https://ollama.com
OLLAMA_MODEL=your-chosen-model
OLLAMA_API_KEY=your-api-key

3Ô∏è‚É£ Frontend Setup

Navigate to the React app directory:

cd src/frontend-react


Install Node.js dependencies:

npm install


üí° If any dependencies are missing, check package.json and re-run npm install.

‚ñ∂Ô∏è Running the Application

You must have both backend and frontend servers running.

Start the Backend
python src/backend/app.py


Server will run at http://localhost:8000

Start the Frontend
cd src/frontend-react
npm start


The React app will open at http://localhost:3000

You‚Äôll be redirected to the chat page after login or sign-up.

ü§ù Contributing

Fork the repository

Create a feature branch (git checkout -b feature-name)

Add tests for new features or bug fixes

Submit a pull request with a clear description

üìú License & Author

This project is maintained by RJBOGA
Licensed under the MIT License
</file>

<file path="src/backend/errors.py">
from flask import jsonify
from werkzeug.exceptions import HTTPException
import traceback

def json_error(message: str, status: int):
    return {"error": {"message": message, "status": status}}, status

def handle_http_exception(e: HTTPException):
    message = getattr(e, "description", None) or getattr(e, "name", "HTTP Error")
    status = getattr(e, "code", None) or 500
    payload, status_code = json_error(message, status)
    return jsonify(payload), status_code

def handle_value_error(e: ValueError):
    payload, status_code = json_error(str(e), 400)
    return jsonify(payload), status_code

def handle_generic_exception(e: Exception):
    # --- PRINT FULL ERROR TO CONSOLE ---
    print("!!! UNHANDLED EXCEPTION !!!")
    traceback.print_exc()
    # -----------------------------------
    payload, status_code = json_error("Internal server error", 500)
    return jsonify(payload), status_code

def unwrap_graphql_errors(result: dict):
    if not result:
        return json_error("Empty GraphQL response", 500)

    errors = result.get("errors") if isinstance(result, dict) else None
    if errors:
        msgs = [str(err.get("message", err)) for err in errors]
        return json_error("; ".join(msgs), 400)

    return None
</file>

<file path="src/backend/repository/application_repo.py">
from typing import Optional, Dict, Any, List
from pymongo import ReturnDocument
from ..db import applications_collection

def find_applications(q: Dict[str, Any]) -> List[dict]:
    """Finds multiple applications in the database."""
    return list(applications_collection().find(q, {"_id": 0}))

def find_application_by_id(app_id: int) -> Optional[dict]:
    """Finds a single application by its unique appId."""
    return applications_collection().find_one({"appId": int(app_id)}, {"_id": 0})

def insert_application(doc: dict) -> None:
    """Inserts a new application document into the database."""
    applications_collection().insert_one(doc)

def update_one_application(q: Dict[str, Any], set_fields: Dict[str, Any]) -> Optional[dict]:
    """Finds one application and updates it."""
    return applications_collection().find_one_and_update(
        q,
        {"$set": set_fields},
        projection={"_id": 0},
        return_document=ReturnDocument.AFTER,
    )

def count_applications(query: Dict[str, Any]) -> int:
    """Counts the number of documents in the applications collection matching a query."""
    return applications_collection().count_documents(query)
</file>

<file path="src/backend/resolvers/scheduling_resolvers.py">
from ariadne import QueryType, MutationType, ObjectType
from datetime import datetime, timedelta
from ..services import scheduling_service
from ..repository import job_repo, user_repo
from ..db import to_user_output

query = QueryType()
mutation = MutationType()
interview = ObjectType("Interview") 

# --- Query Resolvers ---


@query.field("mySchedule")
def resolve_my_schedule(_, info):
    user_id = info.context.get("UserID")
    user_role = info.context.get("user_role")
    if not user_id or user_role != "Recruiter":
        raise PermissionError("Access denied: Only a Recruiter can view their schedule.")

    from ..db import schedules_collection
    schedule = schedules_collection().find_one({"recruiterId": user_id}) 
    return schedule.get("availability") if schedule else []


@query.field("findAvailableSlots")
def resolve_find_available_slots(_, info, candidateId, durationMinutes=30, numDays=14):
    user_id = info.context.get("UserID")
    user_role = info.context.get("user_role")
    if not user_id or user_role != "Recruiter":
        raise PermissionError("Access denied: Only a Recruiter can find available slots.")
        
    start_date = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
    end_date = start_date + timedelta(days=numDays or 14)
    
    slots = scheduling_service.find_open_slots(
        recruiter_id=user_id,
        candidate_id=candidateId,
        start_date=start_date,
        end_date=end_date,
        duration_minutes=durationMinutes or 30
    )
    return slots

# --- Mutation Resolvers ---
@mutation.field("setMyAvailability")
def resolve_set_my_availability(_, info, availability):
    user_id = info.context.get("UserID")
    user_role = info.context.get("user_role")
    if not user_id or user_role != "Recruiter":
        raise PermissionError("Access denied: Only a Recruiter can set their availability.")
        
    return scheduling_service.set_recruiter_availability(user_id, availability)


@mutation.field("bookInterview")
def resolve_book_interview(_, info, jobId, candidateId, startTime, endTime):
    user_id = info.context.get("UserID")
    user_role = info.context.get("user_role")
    if not user_id or user_role != "Recruiter":
        raise PermissionError("Access denied: Only a Recruiter can book interviews.")
        
    # --- FIX: Handle ISO strings with Z and validate duration ---
    try:
        # Handle 'Z' manually for older Python versions
        if startTime.endswith('Z'): startTime = startTime[:-1]
        start_time_dt = datetime.fromisoformat(startTime)
        
        # We calculate end time strictly as +30 mins to prevent malicious blocking
        # ignoring the client-provided endTime for logic, but we could validate it matches.
        end_time_dt = start_time_dt + timedelta(minutes=30)
        
    except ValueError:
        raise ValueError("Invalid time format. Use ISO 8601 format.")
    
    booked_interview = scheduling_service.book_interview(
        job_id=jobId,
        candidate_id=candidateId,
        recruiter_id=user_id,
        start_time=start_time_dt,
        end_time=end_time_dt
    )
    return booked_interview

# --- Field resolvers for the Interview type ---
@interview.field("job")
def resolve_interview_job(interview_obj, _):
    return job_repo.to_job_output(job_repo.find_job_by_id(interview_obj.get("jobId")))

@interview.field("candidate")
def resolve_interview_candidate(interview_obj, _):
    return user_repo.to_user_output(user_repo.find_one_by_id(interview_obj.get("candidateId")))
</file>

<file path="src/backend/services/scheduling_service.py">
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

# Helper to handle ISO strings safely
def parse_iso(date_str):
    if not date_str: return None
    if date_str.endswith('Z'): date_str = date_str[:-1]
    return datetime.fromisoformat(date_str)

def set_recruiter_availability(recruiter_id: int, availability_data: list):
    from ..db import schedules_collection
    schedules_collection().update_one(
        {"recruiterId": recruiter_id},
        {"$set": {"availability": availability_data, "recruiterId": recruiter_id}},
        upsert=True
    )
    return True

def find_open_slots(recruiter_id: int, candidate_id: int, start_date: datetime, end_date: datetime, duration_minutes: int = 30):
    from ..db import schedules_collection, interviews_collection
    
    # 1. Get Schedule
    schedule = schedules_collection().find_one({"recruiterId": recruiter_id})
    if not schedule or not schedule.get("availability"):
        return [] # No availability set

    # 2. Get Bookings
    booked = list(interviews_collection().find({
        "$or": [{"recruiterId": recruiter_id}, {"candidateId": candidate_id}],
        "startTime": {"$gte": start_date.isoformat()},
        "endTime": {"$lte": end_date.isoformat()}
    }))
    
    booked_slots = []
    for b in booked:
        try:
            booked_slots.append((parse_iso(b.get("startTime")), parse_iso(b.get("endTime"))))
        except: continue

    # 3. Generate Slots
    open_slots = []
    day_map = {0: "Monday", 1: "Tuesday", 2: "Wednesday", 3: "Thursday", 4: "Friday", 5: "Saturday", 6: "Sunday"}
    current = start_date
    now = datetime.utcnow()

    while current <= end_date:
        day_name = day_map[current.weekday()]
        
        for rule in schedule["availability"]:
            if rule.get("dayOfWeek", "").lower() != day_name.lower(): continue
            
            try:
                s_time = datetime.strptime(rule["startTime"], "%H:%M").time()
                e_time = datetime.strptime(rule["endTime"], "%H:%M").time()
                
                slot_start = datetime.combine(current.date(), s_time)
                limit = datetime.combine(current.date(), e_time)
                
                while slot_start + timedelta(minutes=duration_minutes) <= limit:
                    slot_end = slot_start + timedelta(minutes=duration_minutes)
                    
                    # Skip past slots and conflicts
                    if slot_start > now:
                        conflict = any(bs < slot_end and be > slot_start for bs, be in booked_slots)
                        if not conflict:
                            open_slots.append(slot_start.isoformat())
                    
                    slot_start += timedelta(minutes=duration_minutes)
            except Exception as e:
                logger.error(f"Error processing slot: {e}")
                continue
                
        current += timedelta(days=1)
        
    return open_slots

def book_interview(job_id, candidate_id, recruiter_id, start_time, end_time):
    from ..db import interviews_collection, next_interview_id
    from ..repository.application_repo import update_one_application
    from ..repository import user_repo, job_repo
    from ..services.email_service import send_interview_invitation
    
    # Conflict Check
    conflict = interviews_collection().find_one({
        "$or": [{"recruiterId": recruiter_id}, {"candidateId": candidate_id}],
        "startTime": {"$lt": end_time.isoformat()},
        "endTime": {"$gt": start_time.isoformat()}
    })
    
    if conflict: raise ValueError("Conflict detected. Slot unavailable.")

    doc = {
        "interviewId": next_interview_id(),
        "jobId": job_id, "candidateId": candidate_id, "recruiterId": recruiter_id,
        "startTime": start_time.isoformat(), "endTime": end_time.isoformat()
    }
    interviews_collection().insert_one(doc)
    
    # Update Status & Email
    app = update_one_application({"userId": candidate_id, "jobId": job_id}, {"status": "Interviewing"})
    cand = user_repo.find_one_by_id(candidate_id)
    job = job_repo.find_job_by_id(job_id)
    
    if cand and job:
        send_interview_invitation(cand["email"], cand["firstName"], job["title"], job["company"], app["appId"] if app else 0)
        
    return doc
</file>

<file path="src/frontend-react/.env.development">
# Frontend environment variables
REACT_APP_NL2GQL_ENDPOINT=http://localhost:8000/nl2gql

MONGO_URI=mongodb://localhost:27017/
DB_NAME=jobtracker

# Alternative: If using Ollama cloud service, uncomment and configure:
OLLAMA_HOST=https://ollama.com
OLLAMA_MODEL=gpt-oss:120b-cloud  
OLLAMA_API_KEY=2a5870ffa8ab469b879ab02999b684db.28nZHl4ZWnBXzrvzWFpiJ7DT
</file>

<file path="src/frontend-react/src/api.js">
// src/frontend-react/src/api.js
import axios from 'axios';

const API_ENDPOINT = process.env.REACT_APP_API_ENDPOINT || 'http://localhost:8000';

// Create an axios instance
const apiClient = axios.create({
  baseURL: API_ENDPOINT,
});

// Use an interceptor to dynamically add the user's role to every request
apiClient.interceptors.request.use(config => {
  try {
    const sessionJSON = localStorage.getItem('session');
    if (sessionJSON) {
      const session = JSON.parse(sessionJSON);
      const userRole = session.user?.role;
      const userId = session.user?.UserID;
      const firstName = session.user?.firstName;
      const lastName = session.user?.lastName;

      if (userRole) {
        // Add the role to a custom header for our GraphQL endpoint
        config.headers['X-User-Role'] = userRole;
      }

      if (userId) {
        config.headers['X-User-ID'] = userId;
        config.headers['X-User-FirstName'] = firstName || '';
        config.headers['X-User-LastName'] = lastName || '';
      }
    }
  } catch (e) {
    console.error("Could not parse session data for API interceptor", e);
  }
  return config;
}, error => {
  return Promise.reject(error);
});

export default apiClient;
</file>

<file path="src/frontend-react/src/index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
      <BrowserRouter>  {/* Wrap App with BrowserRouter */}
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

// Note: A real setup would also need an HTML file (index.html) 
// and potentially CSS, but 'react-scripts start' handles index.html creation.
</file>

<file path=".gitignore">
Python specific files

pycache/
*.pyc
.pytest_cache/
.coverage

Dependency directories

venv/
node_modules/
dist/
build/

IDE files

.idea/
.vscode/

/src/backend/resumes/
/src/backend/.env/
/src/.env/
</file>

<file path="src/backend/services/resume_parser_service.py">
# src/backend/services/resume_parser_service.py
import os
import json
from typing import Optional, Dict
import pypdf
import docx

from .nl2gql_service import OLLAMA_HOST, OLLAMA_MODEL, OLLAMA_API_KEY # Reuse existing config
from ..repository import user_repo
import requests

def _extract_text_from_pdf(file_path: str) -> str:
    """Extracts text content from a PDF file."""
    with open(file_path, 'rb') as f:
        reader = pypdf.PdfReader(f)
        text = "".join(page.extract_text() for page in reader.pages)
    return text

def _extract_text_from_docx(file_path: str) -> str:
    """Extracts text content from a DOCX file."""
    doc = docx.Document(file_path)
    return "\n".join(para.text for para in doc.paragraphs)

def _get_llm_parsed_data(resume_text: str) -> Optional[dict]:
    """Sends resume text to the LLM for structured data extraction."""
    # --- UPDATED, MORE DETAILED PROMPT ---
    prompt = (
        "You are an expert HR assistant. Analyze the following resume text and extract the "
        "specified fields into a valid JSON object. The fields are: "
        "'skills' (a list of key technical skills), "
        "'years_of_experience' (an integer, calculated if necessary), "
        "'is_us_citizen' (a boolean, infer this from phrases like 'US Citizen' or work authorization, default to false if unclear), "
        "'highest_degree_year' (an integer representing the graduation year of the highest degree mentioned), "
        "'professionalTitle' (the user's most recent job title, e.g., 'Software Engineer'), "
        "'city' (the user's city of residence), "
        "'country' (the user's country of residence), and "
        "'highest_qualification' (the name of the user's highest degree, e.g., 'Master of Science in Computer Science'). "
        "Respond ONLY with the JSON object and nothing else.\n\n"
        f"Resume Text:\n---\n{resume_text}"
    )
    
    headers = {"Authorization": f"Bearer {OLLAMA_API_KEY}"}
    api_url = f"{OLLAMA_HOST}/api/generate"

    try:
        response = requests.post(
            api_url,
            json={"model": OLLAMA_MODEL, "prompt": prompt, "stream": False, "format": "json"},
            headers=headers,
            timeout=120,
        )
        response.raise_for_status()
        
        json_string = response.json().get("response", "{}")
        return json.loads(json_string)
    except (requests.RequestException, json.JSONDecodeError) as e:
        print(f"Error parsing resume with LLM: {e}")
        return None

def parse_resume_and_update_user(file_path: str, user_id: int):
    """
    Orchestrates the resume parsing process and updates the user profile.
    """
    print(f"Starting resume parsing for user {user_id} from file {file_path}...")
    try:
        _, file_extension = os.path.splitext(file_path)
        raw_text = ""
        if file_extension.lower() == '.pdf':
            raw_text = _extract_text_from_pdf(file_path)
        elif file_extension.lower() == '.docx':
            raw_text = _extract_text_from_docx(file_path)
        else:
            print(f"Unsupported file type: {file_extension}")
            return

        if not raw_text:
            print("Could not extract text from resume.")
            return

        parsed_data = _get_llm_parsed_data(raw_text)
        if not parsed_data:
            print("LLM parsing failed or returned no data.")
            return
            
        # --- UPDATED: Allow more fields to be updated ---
        update_doc = {k: v for k, v in parsed_data.items() if k in [
            'skills', 'years_of_experience', 'is_us_citizen', 'highest_degree_year',
            'professionalTitle', 'city', 'country', 'highest_qualification'
        ]}

        if update_doc:
            if 'skills' in update_doc and isinstance(update_doc['skills'], list):
                user_repo.add_skills_to_user(user_id, update_doc.pop('skills'))

            if update_doc:
                user_repo.update_one({"UserID": user_id}, update_doc)
            
            print(f"Successfully updated user {user_id} profile from resume with data: {update_doc}")

    except Exception as e:
        print(f"An unexpected error occurred during resume processing: {e}")
</file>

<file path="requirements.txt">
# requirements.txt
Flask
ariadne
pymongo
python-dotenv
requests
streamlit
bcrypt
Faker
pypdf
python-docx
</file>

<file path="src/.env">
MONGO_URI=mongodb://localhost:27017/
DB_NAME=jobtracker

# Alternative: If using Ollama cloud service, uncomment and configure:
OLLAMA_HOST=https://ollama.com
OLLAMA_MODEL=gpt-oss:120b-cloud  
OLLAMA_API_KEY=2a5870ffa8ab469b879ab02999b684db.28nZHl4ZWnBXzrvzWFpiJ7DT

RESEND_API_KEY=re_PAfdoM9e_FQu3ZGn7hKWJ2U6iaG7BiuNf

# --- NEW: GMAIL/SMTP EMAIL CONFIGURATION ---
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USERNAME=raju.boga18@gmail.com
EMAIL_PASSWORD=pwdjrlxaxzsaxnqh
</file>

<file path="src/backend/.env">
MONGO_URI=mongodb://localhost:27017/
DB_NAME=jobtracker

# Alternative: If using Ollama cloud service, uncomment and configure:
OLLAMA_HOST=https://ollama.com
OLLAMA_MODEL=gpt-oss:120b-cloud  
OLLAMA_API_KEY=2a5870ffa8ab469b879ab02999b684db.28nZHl4ZWnBXzrvzWFpiJ7DT

RESEND_API_KEY=re_PAfdoM9e_FQu3ZGn7hKWJ2U6iaG7BiuNf

# --- NEW: GMAIL/SMTP EMAIL CONFIGURATION ---
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USERNAME=raju.boga18@gmail.com
EMAIL_PASSWORD=pwdjrlxaxzsaxnqh
</file>

<file path="src/backend/db.py">
# db.py
import os
from datetime import datetime
from dotenv import load_dotenv
from pymongo import MongoClient, ReturnDocument

# ... (no changes to MONGO_URI, DB_NAME, _client, _db, get_db)
load_dotenv(os.path.join(os.path.dirname(__file__), '../../config/.env'))
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017/")
DB_NAME = os.getenv("DB_NAME", "jobtracker")
_client = MongoClient(MONGO_URI)
_db = _client[DB_NAME]
def get_db():
    return _db


# --- Collection Helpers ---
def users_collection():
    return _db["users"]

def jobs_collection():
    return _db["jobs"]

def applications_collection(): # New
    return _db["applications"]

def counters_collection():
    return _db["counters"]


# --- NEW: Scheduling Collections ---
def schedules_collection():
    return _db["schedules"]

def interviews_collection():
    return _db["interviews"]


# --- Counters (User, Job, and new Application counter) ---
def _ensure_counter(counter_id: str):
    counters_collection().update_one(
        {"_id": counter_id},
        {"$setOnInsert": {"sequence_value": 0}},
        upsert=True,
    )

def _next_id(counter_id: str):
    result = counters_collection().find_one_and_update(
        {"_id": counter_id},
        {"$inc": {"sequence_value": 1}},
        return_document=ReturnDocument.AFTER,
        upsert=True,
    )
    return int(result["sequence_value"])

def ensure_user_counter():
    _ensure_counter("UserID")

def next_user_id():
    return _next_id("UserID")

def ensure_job_counter():
    _ensure_counter("jobId")

def next_job_id():
    return _next_id("jobId")

def ensure_application_counter(): # New
    _ensure_counter("appId")

def next_application_id(): # New
    return _next_id("appId")


# --- NEW: Interview Counters ---
def ensure_interview_counter():
    _ensure_counter("interviewId")

def next_interview_id():
    return _next_id("interviewId")


# --- Output Formatting (no changes to user/job, new for application) ---
def to_user_output(doc: dict): # ... no changes
    if not doc:
        return None
    return {
        "UserID": int(doc.get("UserID")) if doc.get("UserID") is not None else None,
        "FirstName": doc.get("FirstName"),
        "LastName": doc.get("LastName"),
        "DateOfBirth": doc.get("DateOfBirth"),
        "ProfessionalTitle": doc.get("ProfessionalTitle"),
        "Summary": doc.get("Summary"),
    }

def to_job_output(doc: dict): # ... no changes
    if not doc:
        return None
    return {
        "jobId": int(doc.get("jobId")) if doc.get("jobId") is not None else None,
        "title": doc.get("title"),
        "company": doc.get("company"),
        "location": doc.get("location"),
        "salaryRange": doc.get("salaryRange"),
        "skillsRequired": doc.get("skillsRequired"),
        "description": doc.get("description"),
        "postedAt": doc.get("postedAt"),
    }

def to_application_output(doc: dict): # New
    if not doc:
        return None
    return {
        "appId": int(doc.get("appId")) if doc.get("appId") is not None else None,
        "userId": int(doc.get("userId")) if doc.get("userId") is not None else None,
        "jobId": int(doc.get("jobId")) if doc.get("jobId") is not None else None,
        "status": doc.get("status"),
        "submittedAt": doc.get("submittedAt"),
        "notes": doc.get("notes"),
        "userName": doc.get("userName"),
        "jobTitle": doc.get("jobTitle"),
        "companyName": doc.get("companyName"),
        "emailSent": doc.get("emailSent"), # <-- NEW
    }
</file>

<file path="src/backend/resolvers/job_resolvers.py">
# src/backend/resolvers/job_resolvers.py
from datetime import datetime
from ariadne import QueryType, MutationType
from ..validators.common_validators import require_non_empty_str, clean_update_input
from ..repository.job_repo import (
    build_job_filter,
    find_jobs,
    find_job_by_id,
    insert_job,
    update_one_job,
    delete_one_job,
    to_job_output,
    add_skills_to_job,
)
from ..db import next_job_id

query = QueryType()
mutation = MutationType()

# --- READ Operations (Publicly Accessible) ---

@query.field("jobs")
def resolve_jobs(obj, info, limit=None, skip=None, company=None, location=None, title=None, posterUserId=None):
    # No authorization check needed here. Anyone can search for jobs.
    q = build_job_filter(company, location, title, posterUserId)
    docs = find_jobs(q, skip, limit)
    return [to_job_output(d) for d in docs]

@query.field("jobById")
def resolve_job_by_id(obj, info, jobId):
    # No authorization check needed here. Anyone can view a specific job.
    doc = find_job_by_id(int(jobId))
    if not doc:
        raise ValueError(f"Job with ID {jobId} not found.")
    return to_job_output(doc)

# --- MUTATION Operations (Protected for Recruiters) ---

@mutation.field("createJob")
def resolve_create_job(obj, info, input):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to post a job.")

    title = require_non_empty_str(input.get("title"), "title")
    
    # Get the logged-in recruiter's information
    user_id = info.context.get("UserID")
    user_first_name = info.context.get("firstName", "")
    user_last_name = info.context.get("lastName", "")
    poster_name = f"{user_first_name} {user_last_name}".strip()
    
    doc = {
        "jobId": next_job_id(),
        "title": title,
        "company": input.get("company"),
        "location": input.get("location"),
        "salaryRange": input.get("salaryRange"),
        "skillsRequired": input.get("skillsRequired", []),
        "description": input.get("description"),
        "postedAt": datetime.utcnow().strftime('%Y-%m-%d'),
        "status": "Open",
        "posterUserId": user_id,
        "posterName": poster_name if poster_name else None,
    }
    insert_job(doc)
    return to_job_output(doc)

@mutation.field("updateJob")
def resolve_update_job(obj, info, jobId, input):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to update a job.")

    if "title" in input and input["title"] is not None:
        require_non_empty_str(input["title"], "title")

    set_fields = clean_update_input(input)
    if not set_fields:
        raise ValueError("No fields provided to update.")

    updated = update_one_job({"jobId": int(jobId)}, set_fields)
    if not updated:
        raise ValueError(f"Job with ID {jobId} not found for update.")
    return to_job_output(updated)

@mutation.field("deleteJob")
def resolve_delete_job(obj, info, jobId):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to delete a job.")

    count = delete_one_job({"jobId": int(jobId)})
    if count == 0:
        raise ValueError(f"Job with ID {jobId} not found for deletion.")
    return True

@mutation.field("addSkillsToJob")
def resolve_add_skills_to_job(obj, info, jobId, skills):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to modify a job.")

    if not skills:
        raise ValueError("The 'skills' list cannot be empty.")

    # Call our new repository function
    updated_job = add_skills_to_job(jobId, skills)
    
    if not updated_job:
        raise ValueError(f"Job with ID {jobId} not found.")
        
    return to_job_output(updated_job)

@mutation.field("updateJobByFields")
def resolve_update_job_by_fields(obj, info, title, input, company=None):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to update a job.")

    # Validate the title field in input if provided
    if "title" in input and input["title"] is not None:
        require_non_empty_str(input["title"], "title")

    set_fields = clean_update_input(input)
    if not set_fields:
        raise ValueError("No fields provided to update.")

    # Build a filter to find the job
    q = build_job_filter(company, None, title)
    
    # --- SAFETY CHECK ---
    # Before updating, find how many jobs match the criteria.
    matching_jobs = find_jobs(q, None, None)
    
    if len(matching_jobs) == 0:
        raise ValueError(f"No job found with title '{title}' at company '{company or 'any company'}'.")
    if len(matching_jobs) > 1:
        raise ValueError("Multiple jobs matched this criteria. Please be more specific or use a Job ID.")
        
    # If exactly one job matches, proceed with update
    updated = update_one_job(q, set_fields)
    if not updated:
        raise ValueError(f"Failed to update job with title '{title}'.")
    return to_job_output(updated)

@mutation.field("deleteJobByFields")
def resolve_delete_job_by_fields(obj, info, title, company=None):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to delete a job.")

    # Build a filter to find the job(s)
    q = build_job_filter(company, None, title)
    
    # --- SAFETY CHECK ---
    # Before deleting, find how many jobs match the criteria.
    matching_jobs = find_jobs(q, None, None)
    
    if len(matching_jobs) == 0:
        raise ValueError(f"No job found with title '{title}' at company '{company or ''}'.")
    if len(matching_jobs) > 1:
        raise ValueError("Multiple jobs matched this criteria. Please be more specific or use a Job ID.")
        
    # If exactly one job matches, proceed with deletion
    count = delete_one_job(q)
    return count == 1
</file>

<file path="src/backend/services/email_service.py">
# src/backend/services/email_service.py
import os
import smtplib
import ssl
from email.mime.text import MIMEText
from dotenv import load_dotenv
from ..repository import application_repo 
import logging

logger = logging.getLogger(__name__)
# --- IMPORTS FOR AUDIT ---
# Note: The application_repo relies on the MongoDB connection setup in db.py, 
# but this file only needs the import to use the update_one_application function.
from ..repository import application_repo 
# -----------------------------

# --- Load Env Vars (Ensure visibility) ---
# Explicitly load necessary env files relative to this script's location
load_dotenv(os.path.join(os.path.dirname(__file__), '../.env'))
load_dotenv(os.path.join(os.path.dirname(__file__), '../../.env'))

# --- Configuration ---
SMTP_HOST = os.getenv("EMAIL_HOST")
SMTP_PORT = int(os.getenv("EMAIL_PORT", 587))
SMTP_USERNAME = os.getenv("EMAIL_USERNAME")
SMTP_PASSWORD = os.getenv("EMAIL_PASSWORD")
SENDER_EMAIL = SMTP_USERNAME 

def _send_email(to_email: str, subject: str, html_body: str) -> bool:
    """Internal helper to connect to SMTP and send the email."""
    # If this check fails, we still want to log it
    if not all([SMTP_HOST, SMTP_USERNAME, SMTP_PASSWORD]):
        logger.error("FATAL CONFIG ERROR: SMTP credentials missing in .env")
        return False

    # This print MUST show up if the function is executed.
    print(f"ULTIMATE_DEBUG: Attempting SMTP login with {SMTP_USERNAME} to {SMTP_HOST}:{SMTP_PORT}") 

    message = MIMEText(html_body, 'html', 'utf-8')
    message['Subject'] = subject
    message['From'] = SENDER_EMAIL
    message['To'] = to_email

    context = ssl.create_default_context()
    
    try:
        logger.debug(f"DEBUG_E: Attempting connection to {SMTP_HOST}:{SMTP_PORT}...")
        with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
            server.starttls(context=context)
            server.login(SMTP_USERNAME, SMTP_PASSWORD)
            server.sendmail(SENDER_EMAIL, to_email, message.as_string().encode('utf-8')) 
        
        print(f"ULTIMATE_DEBUG: SMTP SUCCESS to {to_email}")
        return True
        
    except Exception as e:
        # Re-raise the exception after printing for a full traceback
        print(f"ULTIMATE_DEBUG: SMTP FAILURE - {type(e).__name__}: {e}")
        # Don't re-raise here to avoid crashing background threads or resolvers.
        logger.error(f"SMTP FAILURE: {type(e).__name__}: {e}")
        return False

# def _send_email(to_email: str, subject: str, html_body: str) -> bool:
#     """Internal helper to connect to SMTP and send the email."""
#     if not all([SMTP_HOST, SMTP_USERNAME, SMTP_PASSWORD]):
#         logger.warning("SMTP credentials not fully configured. Skipping email.")
#         logger.debug(f"Host={SMTP_HOST}, User={SMTP_USERNAME}, Pass_Set={bool(SMTP_PASSWORD)}") # <-- Use logger.debug
#         print("WARNING: SMTP credentials not fully configured. Skipping email.")
#         return False
    
#     # MIME message construction
#     message = MIMEText(html_body, 'html')
#     message['Subject'] = subject
#     message['From'] = SENDER_EMAIL
#     message['To'] = to_email

#     context = ssl.create_default_context()
    
#     try:
#         # Use starttls for port 587
#         with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
#             server.starttls(context=context)
#             server.login(SMTP_USERNAME, SMTP_PASSWORD)
#             server.sendmail(SENDER_EMAIL, to_email, message.as_string())
        
#         print(f"SMTP Success: Email sent to {to_email}")
#         return True
        
#     except Exception as e:
#         print(f"SMTP ERROR: Failed to send email to {to_email}. Error: {type(e).__name__}: {e}")
#         logger.error(f"SMTP ERROR: Failed to send email to {to_email}. Error: {type(e).__name__}: {e}") # <-- Use logger.error
#         return False

def _audit_email_success(app_id: int, event_type: str):
    """Updates the application with the successful email event type."""
    try:
        application_repo.update_one_application(
            {"appId": app_id}, 
            {"emailSent": event_type}
        )
        logger.info(f"AUDIT Success: Application {app_id} marked as {event_type} email sent.") # <-- Use logger.info
        print(f"AUDIT Success: Application {app_id} marked as {event_type} email sent.")
        
    except Exception as e:
        logger.error(f"AUDIT ERROR: Failed to update application {app_id} emailSent field. Error: {e}") # <-- Use logger.error
        print(f"AUDIT ERROR: Failed to update application {app_id} emailSent field. Error: {e}")

def send_interview_invitation(to_email: str, candidate_name: str, job_title: str, company: str, app_id: int):
    """Sends an interview invitation email and audits success."""
    subject = f"Interview Invitation for the {job_title} position at {company}"
    html_body = f"""
    <p>Hi {candidate_name},</p>
    <p>Congratulations! We would like to invite you for an interview for the <strong>{job_title}</strong> role at <strong>{company}</strong>.</p>
    <p>Our hiring team will be in touch shortly to coordinate a time that works for you.</p>
    <p>Best regards,<br/>The Hiring Team at {company}</p>
    """
    if _send_email(to_email, subject, html_body):
        _audit_email_success(app_id, "Interview")

def send_rejection_notification(to_email: str, candidate_name: str, job_title: str, company: str, app_id: int):
    """Sends a rejection email to unsuccessful applicants and audits success."""
    subject = f"Update on your application for {job_title} at {company}"
    html_body = f"""
    <p>Hi {candidate_name},</p>
    <p>Thank you for your interest in the <strong>{job_title}</strong> role at <strong>{company}</strong>.</p>
    <p>We received a large number of qualified applications, and after careful consideration, we have decided to move forward with other candidates whose experience more closely matches our current needs.</p>
    <p>We appreciate you taking the time to apply and wish you the best of luck in your job search.</p>
    <p>Best regards,<br/>The Hiring Team at {company}</p>
    """
    if _send_email(to_email, subject, html_body):
        _audit_email_success(app_id, "Rejected")
</file>

<file path="src/frontend-react/src/LoginPage.js">
// src/frontend-react/src/LoginPage.js
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import './LoginPage.css';

const API_ENDPOINT = process.env.REACT_APP_API_ENDPOINT || 'http://localhost:8000';

function LoginPage() {
  const [email, setEmail] = useState('');
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [password, setPassword] = useState('');
  const [role, setRole] = useState('Applicant');
  const [isLogin, setIsLogin] = useState(true);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (isLogin) {
      // --- Sign-In Logic with Persistent Session ---
      try {
        const payload = { email, password };
        const response = await axios.post(`${API_ENDPOINT}/login`, payload);
        
        const expirationTime = new Date().getTime() + (48 * 60 * 60 * 1000); // 48 hours in milliseconds
        const sessionData = {
          user: response.data.user,
          expiresAt: expirationTime,
        };

        localStorage.setItem('session', JSON.stringify(sessionData));
        navigate('/chat');

      } catch (error) {
        if (error.response && error.response.data.error) {
          alert(`Login failed: ${error.response.data.error}`);
        } else {
          alert('Login failed: An unknown error occurred.');
        }
        console.error('Login error:', error);
      }
    } else {
      // --- UPDATED Registration Logic ---
      try {
        const payload = { email, firstName, lastName, password, role };
        const response = await axios.post(`${API_ENDPOINT}/register`, payload);

        // On success, get the new UserID from the response
        const newUserId = response.data.UserID;
        
        // Redirect to the new profile completion page, passing the ID in the URL
        navigate(`/complete-profile/${newUserId}`);

      } catch (error) {
        if (error.response && error.response.data.error) {
          alert(`Registration failed: ${error.response.data.error}`);
        } else {
          alert('Registration failed: An unknown error occurred.');
        }
        console.error('Registration error:', error);
      }
    }
  };

  return (
    <div className="login-container">
      <form onSubmit={handleSubmit} className="login-form">
        <h2>{isLogin ? 'Sign In to JobChat.AI' : 'Create Your Account'}</h2>
        
        {!isLogin && (
          <>
            <div className="input-group">
              <label>First Name</label>
              <input type="text" value={firstName} onChange={(e) => setFirstName(e.target.value)} required />
            </div>
            <div className="input-group">
              <label>Last Name</label>
              <input type="text" value={lastName} onChange={(e) => setLastName(e.target.value)} required />
            </div>
            <div className="input-group">
              <label>I am a</label>
              <select value={role} onChange={(e) => setRole(e.target.value)} required>
                <option value="Applicant">User / Applicant</option>
                <option value="Recruiter">Recruiter</option>
              </select>
            </div>
          </>
        )}

        <div className="input-group">
          <label>Email</label>
          <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} required />
        </div>

        <div className="input-group">
          <label>Password</label>
          <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} required />
        </div>
        
        <button type="submit" className="login-button">
          {isLogin ? 'Sign In' : 'Sign Up'}
        </button>
        
        <p className="toggle-form">
          {isLogin ? "Don't have an account?" : "Already have an account?"}
          <button type="button" onClick={() => setIsLogin(!isLogin)} className="toggle-button">
            {isLogin ? 'Sign Up' : 'Sign In'}
          </button>
        </p>
      </form>
    </div>
  );
}

export default LoginPage;
</file>

<file path="src/backend/repository/job_repo.py">
# src/backend/repository/job_repo.py
import re
from typing import Optional, Dict, Any, List
from pymongo import ReturnDocument
from ..db import jobs_collection

def to_job_output(doc: dict) -> dict:
    if not doc: return None
    return {
        "jobId": int(doc.get("jobId")) if doc.get("jobId") is not None else None,
        "title": doc.get("title"), "company": doc.get("company"), "location": doc.get("location"),
        "salaryRange": doc.get("salaryRange"), "skillsRequired": doc.get("skillsRequired"),
        "description": doc.get("description"), "postedAt": doc.get("postedAt"),
        "requires_us_citizenship": doc.get("requires_us_citizenship"),
        "minimum_degree_year": doc.get("minimum_degree_year"),
        "status": doc.get("status"),
        "posterUserId": doc.get("posterUserId"),
        "posterName": doc.get("posterName"),
    }

def build_job_filter(company: Optional[str], location: Optional[str], title: Optional[str], poster_user_id: Optional[int] = None) -> Dict[str, Any]:
    q: Dict[str, Any] = {}
    if company: q["company"] = {"$regex": f"^{re.escape(company)}$", "$options": "i"}
    if location: q["location"] = {"$regex": f"^{re.escape(location)}$", "$options": "i"}
    if title: q["title"] = {"$regex": f".*{re.escape(title)}.*", "$options": "i"}
    if poster_user_id is not None: q["posterUserId"] = int(poster_user_id)
    return q

def find_jobs(q: Dict[str, Any], skip: Optional[int], limit: Optional[int]) -> List[dict]:
    cursor = jobs_collection().find(q, {"_id": 0})
    if skip is not None: cursor = cursor.skip(int(skip))
    if limit is not None: cursor = cursor.limit(int(limit))
    return list(cursor)

def find_job_by_id(job_id: int) -> Optional[dict]:
    return jobs_collection().find_one({"jobId": int(job_id)}, {"_id": 0})

def insert_job(doc: dict) -> None:
    jobs_collection().insert_one(doc)

def update_one_job(q: Dict[str, Any], set_fields: Dict[str, Any]) -> Optional[dict]:
    return jobs_collection().find_one_and_update(
        q, {"$set": set_fields}, projection={"_id": 0}, return_document=ReturnDocument.AFTER
    )

def delete_one_job(q: Dict[str, Any]) -> int:
    res = jobs_collection().delete_one(q)
    return int(res.deleted_count)

def add_skills_to_job(job_id: int, skills: List[str]) -> Optional[dict]:
    return jobs_collection().find_one_and_update(
        {"jobId": int(job_id)},
        {"$addToSet": {"skillsRequired": {"$each": skills}}},
        projection={"_id": 0},
        return_document=ReturnDocument.AFTER,
    )
</file>

<file path="src/frontend-react/src/App.css">
/* src/frontend-react/src/App.css */
html, body, #root {
  height: 100%;
}

/* --- Global Variables (Themes) --- */
:root {
    /* Light Theme Defaults */
    --background-color: #f0f2f5;
    --text-color: #1c1e21;
    --card-background: #ffffff;
    --border-color: #ccc;
    --user-bubble-bg: #dcf8c6;
    --assistant-bubble-bg: #e5e5e5;
    --input-bg: #ffffff;
    --button-bg: #1877f2;
    --button-text: #ffffff;
}

/* Dark Theme Overrides */
[data-theme='dark'] {
    --background-color: #18191a;
    --text-color: #e4e6eb;
    --card-background: #242526;
    --border-color: #3a3b3c;
    --user-bubble-bg: #324e2c; /* Darker green */
    --assistant-bubble-bg: #3a3b3c;
    --input-bg: #3a3b3c;
    --button-bg: #2d88ff;
    --button-text: #ffffff;
}

/* --- Base Layout --- */
body {
    background-color: var(--background-color);
    color: var(--text-color);
    transition: background-color 0.3s, color 0.3s;
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.App {
    max-width: 1000px; /* Make it wider */
    height: 90vh; /* Make it 90% of the viewport height */
    margin: 40px auto;
    padding: 20px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--card-background);
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    
    /* Add these properties to enable flexbox */
    display: flex;
    flex-direction: column;
}

/* --- Header --- */
.header-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.header-controls {
    display: flex;
    align-items: center;
    gap: 15px; /* Adds space between header elements */
}

.theme-toggle {
    background: none;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 5px;
    font-size: 14px; /* For emoji consistency */
    line-height: 1; /* Aligns emoji better */
    transition: background-color 0.3s, border-color 0.3s;
}

.theme-toggle:hover {
    background-color: var(--assistant-bubble-bg);
}

/* --- Message Area --- */
.message-container {
    flex: 1; /* This makes the container grow to fill available space */
    min-height: 0; /* Prevents flexbox overflow issues */
    overflow-y: auto;
    border: 1px solid var(--border-color);
    padding: 10px;
    margin-bottom: 20px;
    border-radius: 8px;
    background-color: var(--card-background);
}

/* --- Chat Bubbles --- */
.message {
    display: flex;
    margin-bottom: 15px;
    flex-direction: column;
}

.user-message {
    align-items: flex-end;
}

.assistant-message {
    align-items: flex-start;
}

.message-bubble {
    padding: 12px;
    border-radius: 18px;
    max-width: 80%;
    word-wrap: break-word;
    white-space: pre-wrap;
    line-height: 1.5;
}

.user-message .message-bubble {
    background-color: var(--user-bubble-bg);
    color: var(--text-color);
}

.assistant-message .message-bubble {
    background-color: var(--assistant-bubble-bg);
    color: var(--text-color);
}

.message-bubble strong {
    font-weight: 600;
    margin-bottom: 5px;
    display: block;
}

/* --- Input Form --- */
.input-form {
    display: flex;
    gap: 10px;
}

.input-form input {
    flex-grow: 1;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    background-color: var(--input-bg);
    color: var(--text-color);
    outline: none;
    font-size: 16px;
}

.input-form button {
    padding: 12px 25px;
    background-color: var(--button-bg);
    color: var(--button-text);
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.2s;
}

.input-form button:hover:not(:disabled) {
    background-color: #0b5cb0; /* Slightly darker blue */
}

.input-form button:disabled {
    background-color: var(--border-color);
    cursor: not-allowed;
}

/* --- Code Blocks in Assistant Messages --- */
.message-bubble pre {
    background-color: rgba(0, 0, 0, 0.05);
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto;
    margin-top: 10px;
}

[data-theme='dark'] .message-bubble pre {
    background-color: rgba(255, 255, 255, 0.1);
}

/* --- User Greeting and Logout Button Styles --- */
.user-greeting {
  font-weight: 600;
  color: var(--text-color);
  margin-right: 10px;
}

.logout-button {
  background-color: #e4e6eb;
  color: #1c1e21;
  border: 1px solid var(--border-color);
  padding: 8px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
  transition: background-color 0.2s, color 0.2s;
}

.logout-button:hover {
  background-color: #d1d3d6;
}

[data-theme='dark'] .logout-button {
  background-color: #3a3b3c;
  color: #e4e6eb;
}

[data-theme='dark'] .logout-button:hover {
  background-color: #4e4f50;
}

.recruiter-panel {
  padding: 10px 15px;
  background-color: var(--assistant-bubble-bg);
  border-radius: 8px;
  margin-bottom: 20px;
  text-align: center;
  font-style: italic;
}

.resume-uploader-panel {
  padding: 20px;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  margin-bottom: 20px;
  text-align: center;
  background-color: var(--card-background);
}

.resume-uploader-panel h4 {
  margin-top: 0;
}

.uploader-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 15px;
  margin-top: 15px;
}

.uploader-controls button {
  padding: 8px 16px;
  border-radius: 5px;
  cursor: pointer;
  border: 1px solid transparent;
}

.uploader-controls .skip-button {
  background-color: transparent;
  color: var(--text-color);
  border-color: var(--border-color);
}

.status-success {
  color: #2e7d32;
  font-weight: bold;
}

.status-error {
  color: #c62828;
  font-weight: bold;
}

/* Scheduling panel styles */
.scheduling-panel {
  padding: 20px;
  border: 2px solid var(--border-color);
  border-radius: 8px;
  margin-bottom: 20px;
  background-color: var(--card-background);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
}

.slot-list {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 15px;
}

.slot-button {
  background-color: var(--button-bg);
  color: var(--button-text);
  padding: 8px 15px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.slot-button:hover {
  background-color: #0b5cb0;
}

.action-button { /* For the initial invite button */
  padding: 6px 12px;
  background-color: var(--button-bg);
  color: var(--button-text);
  border: none;
  border-radius: 5px;
  cursor: pointer;
  margin-left: 10px;
  font-size: 0.9em;
  font-weight: 600;
}
</file>

<file path="src/backend/repository/user_repo.py">
# src/backend/repository/user_repo.py
import re
from typing import Optional, Dict, Any, List
from pymongo import ReturnDocument
from ..db import users_collection

def find_user_by_email(email: str) -> Optional[dict]:
    return users_collection().find_one({"email": {"$regex": f"^{email}$", "$options": "i"}})

def to_user_output(doc: dict) -> Optional[dict]:
    if not doc: return None
    return {
        "UserID": doc.get("UserID"), "email": doc.get("email"), "firstName": doc.get("firstName"),
        "lastName": doc.get("lastName"), "role": doc.get("role"), "phone_number": doc.get("phone_number"),
        "city": doc.get("city"), "state_province": doc.get("state_province"), "country": doc.get("country"),
        "linkedin_profile": doc.get("linkedin_profile"), "portfolio_url": doc.get("portfolio_url"),
        "highest_qualification": doc.get("highest_qualification"), "years_of_experience": doc.get("years_of_experience"),
        "createdAt": doc.get("createdAt"), "dob": doc.get("dob"), "skills": doc.get("skills"),
        "professionalTitle": doc.get("professionalTitle"), "is_us_citizen": doc.get("is_us_citizen"),
        "highest_degree_year": doc.get("highest_degree_year")
    }

def build_filter(first_name: Optional[str], last_name: Optional[str], dob: Optional[str], skills: Optional[List[str]] = None, is_us_citizen: Optional[bool] = None, years_of_experience_gte: Optional[int] = None) -> Dict[str, Any]:
    q = {}
    if first_name: q["firstName"] = {"$regex": f"^{re.escape(first_name)}$", "$options": "i"}
    if last_name: q["lastName"] = {"$regex": f"^{re.escape(last_name)}$", "$options": "i"}
    if dob: q["dob"] = dob
    if skills: q["skills"] = {"$all": skills}
    if is_us_citizen is not None: q["is_us_citizen"] = is_us_citizen
    if years_of_experience_gte is not None: q["years_of_experience"] = {"$gte": years_of_experience_gte}
    return q

def find_users(q: Dict[str, Any], skip: Optional[int], limit: Optional[int]) -> List[dict]:
    cursor = users_collection().find(q, {"_id": 0, "password": 0})
    if skip is not None: cursor = cursor.skip(int(skip))
    if limit is not None: cursor = cursor.limit(int(limit))
    return list(cursor)

def find_one_by_id(user_id: int) -> Optional[dict]:
    return users_collection().find_one({"UserID": int(user_id)}, {"_id": 0, "password": 0})

def insert_user(doc: dict) -> None:
    users_collection().insert_one(doc)

def update_one(q: Dict[str, Any], set_fields: Dict[str, Any]) -> Optional[dict]:
    return users_collection().find_one_and_update(q, {"$set": set_fields}, projection={"_id": 0, "password": 0}, return_document=ReturnDocument.AFTER)

def delete_one(q: Dict[str, Any]) -> int:
    return users_collection().delete_one(q).deleted_count

def add_skills_to_user(user_id: int, skills: List[str]) -> Optional[dict]:
    return users_collection().find_one_and_update({"UserID": int(user_id)}, {"$addToSet": {"skills": {"$each": skills}}}, projection={"_id": 0, "password": 0}, return_document=ReturnDocument.AFTER)
</file>

<file path="src/backend/resolvers/user_resolvers.py">
# src/backend/resolvers/user_resolvers.py
from ariadne import QueryType, MutationType
from datetime import datetime
from ..validators.common_validators import require_non_empty_str, validate_date_str, clean_update_input
from ..repository import user_repo
from ..db import next_user_id

query = QueryType()
mutation = MutationType()

@query.field("users")
def resolve_users(*_, limit=None, skip=None, firstName=None, lastName=None, dob=None, skills=None, isUSCitizen=None, yearsOfExperience_gte=None):
    if dob: dob = validate_date_str(dob)
    q = user_repo.build_filter(firstName, lastName, dob, skills, is_us_citizen=isUSCitizen, years_of_experience_gte=yearsOfExperience_gte)
    docs = user_repo.find_users(q, skip, limit)
    return [user_repo.to_user_output(d) for d in docs]

@query.field("userById")
def resolve_user_by_id(*_, UserID):
    doc = user_repo.find_one_by_id(int(UserID))
    return user_repo.to_user_output(doc)

@mutation.field("createUser")
def resolve_create_user(*_, input):
    email = require_non_empty_str(input.get("email"), "email")
    if user_repo.find_user_by_email(email): raise ValueError(f"A user with the email '{email}' already exists.")
    doc = {"UserID": next_user_id(), "email": email.lower(), "password": None, "firstName": require_non_empty_str(input.get("firstName"), "firstName"), "lastName": require_non_empty_str(input.get("lastName"), "lastName"), "role": require_non_empty_str(input.get("role"), "role"), "createdAt": datetime.utcnow().isoformat(), "phone_number": input.get("phone_number"), "city": input.get("city"), "state_province": input.get("state_province"), "country": input.get("country"), "linkedin_profile": input.get("linkedin_profile"), "portfolio_url": input.get("portfolio_url"), "highest_qualification": input.get("highest_qualification"), "years_of_experience": input.get("years_of_experience"), "dob": validate_date_str(input.get("dob")), "skills": input.get("skills", []), "professionalTitle": input.get("professionalTitle"), "is_us_citizen": input.get("is_us_citizen"), "highest_degree_year": input.get("highest_degree_year")}
    user_repo.insert_user(doc)
    return user_repo.to_user_output(doc)

@mutation.field("updateUser")
def resolve_update_user(*_, UserID, input):
    if "dob" in input and input.get("dob") is not None: input["dob"] = validate_date_str(input["dob"])
    set_fields = clean_update_input(input)
    if not set_fields: raise ValueError("No fields provided to update")
    updated = user_repo.update_one({"UserID": int(UserID)}, set_fields)
    if not updated: raise ValueError(f"User with ID {UserID} not found for update.")
    return user_repo.to_user_output(updated)

@mutation.field("updateUserByName")
def resolve_update_user_by_name(*_, firstName=None, lastName=None, input=None):
    q = user_repo.build_filter(firstName, lastName, None)
    if not q: raise ValueError("Provide firstName and/or lastName to identify the user")
    matches = user_repo.find_users(q, None, None)
    if len(matches) == 0: raise ValueError("No user matched the provided name filter")
    if len(matches) > 1: raise ValueError("Multiple users matched; please be more specific to target a single user")
    set_fields = clean_update_input(input or {})
    if not set_fields: raise ValueError("No fields provided to update")
    updated = user_repo.update_one({"UserID": matches[0]["UserID"]}, set_fields)
    return user_repo.to_user_output(updated)

@mutation.field("deleteUser")
def resolve_delete_user(*_, UserID):
    return user_repo.delete_one({"UserID": int(UserID)}) == 1

@mutation.field("deleteUserByFields")
def resolve_delete_user_by_fields(*_, firstName=None, lastName=None, dob=None):
    q = user_repo.build_filter(firstName, lastName, dob)
    if not q: raise ValueError("Provide at least one filter: firstName, lastName, or dob")
    matches = user_repo.find_users(q, None, None)
    if len(matches) == 0: return False
    if len(matches) > 1: raise ValueError("Multiple users matched; add more filters to target a single user")
    return user_repo.delete_one(q) == 1

@mutation.field("addSkillsToUser")
def resolve_add_skills_to_user(obj, info, UserID, skills):
    logged_in_user = info.context.get("user")
    user_role = info.context.get("user_role")
    if not (logged_in_user and logged_in_user.get("UserID") == UserID) and user_role != "Recruiter":
        raise ValueError("Permission denied: You can only add skills to your own profile.")
    if not skills: raise ValueError("The 'skills' list cannot be empty.")
    updated_user = user_repo.add_skills_to_user(UserID, skills)
    if not updated_user: raise ValueError(f"User with ID {UserID} not found.")
    return user_repo.to_user_output(updated_user)
</file>

<file path="src/frontend-react/src/ResultsDisplay.css">
/* src/frontend-react/src/ResultsDisplay.css */

/* --- Card Container --- */
.result-item {
    background-color: var(--card-background);
    padding: 20px; /* Increased padding */
    border-radius: 12px;
    border: 1px solid var(--border-color);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    gap: 10px; /* Consistent spacing between elements */
    position: relative;
    transition: transform 0.2s;
}

.result-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

/* --- Header Section --- */
.item-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

.item-title {
    font-size: 1.2em;
    font-weight: 700;
    color: var(--text-color);
}

.item-subtitle {
    color: #666;
    font-size: 0.95em;
    font-weight: 500;
    margin-bottom: 5px;
}

/* --- Skills Tags --- */
.item-skills {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin: 8px 0;
}

.skill-tag {
    background-color: var(--background-color);
    border: 1px solid var(--border-color);
    padding: 4px 10px;
    border-radius: 15px;
    font-size: 0.85em;
    color: var(--text-color);
}

/* --- Links Row (LinkedIn, Portfolio, Resume) --- */
.item-links {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid var(--border-color);
}

.item-links a {
    text-decoration: none;
    color: var(--button-bg);
    font-size: 0.9em;
    font-weight: 600;
}

.item-links a:hover {
    text-decoration: underline;
}

/* Specific style for the Resume Button to make it pop slightly */
.resume-link {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    background-color: #fff3e0;
    color: #e65100 !important; /* Override default link color */
    padding: 6px 12px;
    border-radius: 20px;
    border: 1px solid #ffe0b2;
    text-decoration: none !important;
    transition: background-color 0.2s;
}

.resume-link:hover {
    background-color: #ffe0b2;
}

/* Dark mode adjustment for resume link */
[data-theme='dark'] .resume-link {
    background-color: #3e2723;
    color: #ffcc80 !important;
    border-color: #5d4037;
}

/* --- Main Action Button (Schedule / Scheduled) --- */
.action-button {
    margin-top: 15px;
    width: 100%; /* Full width for better mobile touch target */
    padding: 10px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    font-size: 0.95em;
    transition: background-color 0.2s;
}

/* Invite Button (Blue) */
.invite-button {
    background-color: var(--button-bg);
    color: #ffffff;
}

.invite-button:hover {
    filter: brightness(1.1);
}

/* Disabled Button (Gray/Green tint) */
.action-button.disabled-button {
    background-color: #e8f5e9; /* Very light green background */
    color: #2e7d32; /* Green text */
    border: 1px solid #c8e6c9;
    cursor: default;
}

/* If rejected */
.action-button.disabled-button:contains('Rejected') { 
    /* CSS :contains is pseudo-code, React logic handles class assignment usually, 
       but for now the generic disabled style is fine. */
    background-color: #ffebee;
    color: #c62828;
    border-color: #ffcdd2;
}

[data-theme='dark'] .action-button.disabled-button {
    background-color: #1b5e20;
    color: #a5d6a7;
    border-color: #2e7d32;
}

/* --- Decision Buttons (Hire/Reject) --- */
.action-area {
    margin-top: 15px;
    width: 100%;
}

.decision-buttons {
    display: flex;
    gap: 10px;
    width: 100%;
}

.decision-btn {
    flex: 1;
    padding: 10px;
    border: none;
    border-radius: 8px;
    font-weight: 700;
    cursor: pointer;
    font-size: 0.95em;
    transition: transform 0.1s, filter 0.2s;
}

.decision-btn:hover {
    transform: translateY(-2px);
    filter: brightness(1.1);
}

.hire-btn {
    background-color: #2e7d32; /* Green */
    color: white;
}

.reject-btn {
    background-color: #c62828; /* Red */
    color: white;
}
</file>

<file path="src/backend/services/nl2gql_service.py">
# src/backend/services/nl2gql_service.py
import os
import requests
import json
from typing import Optional
from dotenv import load_dotenv

env_path = os.path.join(os.path.dirname(__file__), '../../.env')
load_dotenv(dotenv_path=env_path)

from ..errors import json_error, unwrap_graphql_errors

OLLAMA_HOST = os.getenv("OLLAMA_HOST", "https://ollama.com")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gpt-oss:120b-cloud")
OLLAMA_API_KEY = os.getenv("OLLAMA_API_KEY")
OLLAMA_GENERATE_URL = f"{OLLAMA_HOST}/api/generate"


# --- RESTORED: The more comprehensive small talk handler ---
def handle_small_talk(user_text: str):
    """
    Checks for a wide range of conversational phrases (greetings, idioms, etc.)
    and returns a predefined friendly response to bypass the LLM.
    """
    clean_text = user_text.lower().strip()
    words = clean_text.split()
    
    # --- Category 1: Direct Matches (Greetings, Gratitude, Interjections) ---
    small_talk_map = {
        "hi": "Hello there! How can I assist with your job data today?",
        "hello": "Hi! I'm ready to convert your requests into GraphQL. What can I do?",
        "hey": "Hey! Let me know what data you need to query or update.",
        "greetings": "Greetings! I'm here to help with your job portal data via NL2GQL.",
        "thanks": "You're welcome! I'm happy to help.",
        "thank you": "My pleasure! Just ask if you have more queries.",
        "wow": "Glad to impress! Do you have a query for me?",
        "cool": "I think so too! Ready for your next command.",
        "awesome": "I strive for excellence! Ready for a command.",
        "oops": "Mistakes happen! Please try your query again.",
        "sorry": "No worries at all. What is your request?",
        "how are you": "I'm a GraphQL assistant, operating perfectly! What query can I run for you?",
        "what's up": "Just monitoring the database for your requests. What can I do for you?",
        "how are you doing today": "I'm a GraphQL assistant, operating perfectly! What query can I run for you?",
    }
    
    # --- Category 2: Idioms, Common Phrases & Discourse Markers (Keyword Matching) ---
    keyword_responses = {
        "by the way": "Interesting point. Do you have a job or user query for me?",
        "i mean": "I understand. Please formulate your query clearly.",
        "just saying": "Got it. I'm waiting for a command that maps to GraphQL.",
        "you know": "I know what you mean. Focus on what data you need.",
        "hold on": "Okay, I'll hold. Let me know when you have a request.",
        "excuse me": "No problem. How can I help with the data?",
        "can you help me": "Absolutely! I can help by converting your request into a GraphQL query.",
        "can i ask": "You can ask. I can answer if it involves querying or mutating job portal data.",
    }
    
    default_response_payload = {
        "graphql": "Small talk handled by service logic", 
        "result": {
            "response": (
                "Hello! I'm your GraphQL assistant. I can help with job portal data. "
                "Try asking me to:\n- **Find** jobs: *find jobs for Java developer in London*\n"
                "- **Update** your profile: *update my professional title to Senior Developer*"
            )
        }
    }
    
    # 1. Check for Direct Matches
    if clean_text in small_talk_map:
        return {"graphql": "Small talk handled by service logic", "result": {"response": small_talk_map[clean_text]}}, 200
        
    # 2. Check for Keyword Matches
    for key, response in keyword_responses.items():
        if key in clean_text:
            return {"graphql": "Small talk handled by service logic", "result": {"response": response}}, 200

    # 3. Check for short multi-word greetings or questions to the bot
    if words:
        is_greeting = words[0] in ["hi", "hello", "hey"]
        is_vocative = "assistant" in words or "bot" in words or "jobchat" in words
        
        if (is_greeting or is_vocative) and len(words) <= 5:
            # Return the default, guiding response for these cases
            return default_response_payload, 200
        
    return None

# --- UPDATED Prompt Builder (Keeps the userContext logic) ---
def build_nl2gql_prompt(user_text: str, schema_sdl: str, user_context: Optional[dict]) -> str:
    context_str = ""
    if user_context and user_context.get("UserID"):
        user_id = user_context["UserID"]
        first_name = user_context.get("firstName", "the user")
        context_str = (
            f"\n\nContext:\n"
            f"- The request is from a logged-in user named '{first_name}' with UserID: {user_id}.\n"
            f"- When the user refers to 'me', 'my', or 'I', you MUST use their UserID ({user_id}) to target the operation (e.g., in an `updateUser` mutation).\n"
        )

    return (
        "You are an expert GraphQL assistant. Your task is to convert the user's natural language request "
        "into a single, valid GraphQL operation that adheres strictly to the provided schema. "
        "Return ONLY the GraphQL operation with no explanations or markdown fences."
        f"{context_str}"
        "\n\nKey Instructions:\n"
        "- To filter users by experience, use the `yearsOfExperience_gte: Int` argument. For '5 years of experience', use `users(yearsOfExperience_gte: 5)`.\n"
        "- To filter users by citizenship, use the `isUSCitizen: Boolean` argument. For 'who are US citizens', use `users(isUSCitizen: true)`.\n"
        "- When a user wants to **ADD** skills to **their own profile**, you **MUST** use the `addSkillsToUser` mutation. For all other user profile updates, use `updateUser`.\n"
        "- When a user asks about **'my applications'**, you **MUST** use the `applications` query and filter it using the `userId` from the context.\n"
        "- When a user wants to **'add a note'** to their application, you **MUST** use the `addNoteToApplicationByJob` mutation.\n"
        "- When a user asks **'how many applications'** or for a **'count of applicants'**, you **MUST** query the relevant job and include the `applicationCount` field.\n"
        "- When a user wants to **UPDATE the STATUS** of an application (e.g., 'interview', 'reject', 'hire'), you **MUST** use the `updateApplicationStatusByNames` mutation. **For this mutation, you MUST extract the candidate's full name, the exact job title, and the company name.**\n" # <--- UPDATED INSTRUCTION
        "- When a user wants to see **applicants**, **candidates**, or people who **applied** for a job, you **MUST** query the `jobs` field. **You MUST select `jobId`, `title`, and `company` for the Job itself.** Then request the nested `applicants` field. **For every applicant, you MUST select:** `firstName`, `lastName`, `professionalTitle`, `skills`, `city`, `country`, `applicationStatus`, `resume_url`, `interviewTime`, and `UserID`.\n\n"
        "- When a user wants to **ADD** skills to a job, you **MUST** use the `addSkillsToJob` mutation. For all other job updates, use the `updateJob` mutation.\n"
        "- When a user wants to **UPDATE** a job by its title and company (e.g., 'update the Senior Python Developer job at Google'), you **MUST** use the `updateJobByFields` mutation with the title and company as identifiers.\n"
        "- To set a **citizenship requirement** for a job, use `updateJobByFields(..., input: {requires_us_citizenship: true})` or `updateJob(..., input: {requires_us_citizenship: true})`.\n"
        "- To set a **minimum degree year** for a job, use `updateJobByFields(..., input: {minimum_degree_year: 2015})` or `updateJob(..., input: {minimum_degree_year: 2015})`.\n"
        "- When the user wants to 'apply' a person to a job, ALWAYS use the `apply` mutation.\n"
        "- When a user wants to **DELETE** or **REMOVE** a job using its title and company, you **MUST** use the `deleteJobByFields` mutation.\n"
        "- For other actions, use the appropriate query or mutation.\n"
        "- If the user's request cannot be mapped to any field in the schema, return the single word: INVALID.\n"
        "- Do not make up fields or assume logic not present in the schema.\n\n"
        "Schema:\n"
        f"{schema_sdl}\n\n"
        "User request:\n"
        f"\"{user_text}\""
    )

def extract_graphql(text: str) -> str:
    """Extracts a GraphQL query from a markdown block or plain text."""
    if "```" in text:
        parts = text.split("```")
        for part in parts:
            if "query" in part or "mutation" in part or "{" in part:
                return part.replace("graphql", "").strip()
    return text.strip()

# --- UPDATED Service Processor (Keeps the userContext logic) ---
def process_nl2gql_request(user_text: str, schema_sdl: str, run_graphql: bool, graphql_executor_fn, user_context: Optional[dict]):
    small_talk_response = handle_small_talk(user_text)
    if small_talk_response:
        return small_talk_response
    
    if not OLLAMA_API_KEY:
        return json_error("NL2GQL Service Error: OLLAMA_API_KEY is missing in environment configuration.", 500)
        
    prompt = build_nl2gql_prompt(user_text, schema_sdl, user_context)

    headers = {"Authorization": f"Bearer {OLLAMA_API_KEY}"}

    try:
        resp = requests.post(
            OLLAMA_GENERATE_URL,
            json={"model": OLLAMA_MODEL, "prompt": prompt, "stream": False},
            headers=headers,
            timeout=90,
        )
    except requests.exceptions.RequestException as e:
        return json_error(f"Ollama network error: {e}", 502)

    if not resp.ok:
        try:
            err_details = resp.json().get("error", resp.text)
            return json_error(f"LLM Error {resp.status_code}: {err_details}", 502)
        except (json.JSONDecodeError, ValueError):
            return json_error(f"Ollama returned a non-JSON error (Status: {resp.status_code}).", 502)

    try:
        gen_body = resp.json()
        gen = gen_body.get("response", "")
        gql = extract_graphql(gen)
    except (ValueError, IndexError):
        return json_error("Failed to parse the response from the LLM.", 502)

    if not gql or gql.strip().upper() == "INVALID":
        return json_error("Your request could not be mapped to a valid operation. Please try rephrasing.", 400)

    if not run_graphql:
        return {"graphql": gql}, 200

    success, result = graphql_executor_fn({"query": gql})
    
    wrapped_error = unwrap_graphql_errors(result)
    if wrapped_error:
        return wrapped_error 

    return {"graphql": gql, "result": result}, (200 if success else 400)
</file>

<file path="src/frontend-react/src/ResultsDisplay.js">
// src/frontend-react/src/ResultsDisplay.js
import React, { useState } from 'react';
import apiClient from './api'; // <--- IMPORT THIS
import './ResultsDisplay.css';

// A small helper component to render a single Job
const JobResult = ({ job }) => (
  <div className="result-item">
    <div className="item-header">
      <span className="item-title">{job.title || 'N/A'}</span>
      <span className="item-location">{job.location || 'N/A'}</span>
    </div>
    <div className="item-company">{job.company || 'N/A'}</div>
    {job.skillsRequired && job.skillsRequired.length > 0 && (
      <div className="item-skills">
        {job.skillsRequired.map(skill => <span key={skill} className="skill-tag">{skill}</span>)}
      </div>
    )}
  </div>
);

// An enhanced component to render a single, detailed User profile
const UserResult = ({ user, onInviteClick, currentUserRole }) => {
    // Local state to update UI immediately after clicking Hire/Reject
    const [localStatus, setLocalStatus] = useState(user.applicationStatus);
    const [loading, setLoading] = useState(false);

    // Normalize status
    const status = localStatus ? localStatus.toLowerCase() : '';
    const isScheduled = status.includes('interview');
    const isHired = status === 'hired';
    const isRejected = status === 'rejected';

    // Time Check Logic
    let isInterviewPassed = false;
    let buttonText = 'Schedule Interview';

    if (isScheduled) {
        if (user.interviewTime) {
            const interviewDate = new Date(user.interviewTime);
            const now = new Date();
            if (now > interviewDate) {
                isInterviewPassed = true;
            }
            const dateStr = interviewDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const timeStr = interviewDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            buttonText = `‚úÖ Interview: ${dateStr} at ${timeStr}`;
        } else {
            buttonText = '‚úÖ Interview Scheduled';
        }
    }
    if (isHired) buttonText = 'üéâ Hired';
    if (isRejected) buttonText = '‚ùå Rejected';

    // --- NEW: Handle Hire/Reject Clicks ---
    const handleDecision = async (newStatus) => {
        if (!window.confirm(`Are you sure you want to mark this candidate as ${newStatus}? This will send an email.`)) return;
        
        setLoading(true);
        try {
            await apiClient.post('/graphql', {
                query: `
                  mutation UpdateStatus($userName: String!, $jobTitle: String!, $newStatus: String!) {
                    updateApplicationStatusByNames(
                      userName: $userName,
                      jobTitle: $jobTitle,
                      newStatus: $newStatus
                    ) {
                      status
                    }
                  }
                `,
                variables: {
                    userName: `${user.firstName} ${user.lastName}`,
                    jobTitle: user.jobTitle,
                    newStatus: newStatus
                }
            });
            setLocalStatus(newStatus);
        } catch (err) {
            alert("Failed to update status. Check console.");
            console.error(err);
        } finally {
            setLoading(false);
        }
    };
    // --------------------------------------

    // --- NEW: Security Check ---
    const isRecruiter = currentUserRole === 'Recruiter';

    return (
        <div className="result-item">
            {/* Header / Info Sections (Same as before) */}
            <div className="item-header">
                <span className="item-title">{user.firstName} {user.lastName}</span>
                {localStatus && <StatusBadge status={localStatus} />} 
                {user.is_us_citizen && <span className="citizen-badge">‚úÖ US Citizen</span>}
                <span className="item-location">{user.city && user.country ? `${user.city}, ${user.country}` : ''}</span>
            </div>
            
            <div className="item-subtitle">{user.professionalTitle || '------------'}</div>

            {/* Skills & Details (Same as before) */}
            {user.years_of_experience != null && <div><strong>Experience:</strong> {user.years_of_experience} years</div>}
            {user.highest_qualification && <div><strong>Qualification:</strong> {user.highest_qualification}</div>}
            
            {user.skills && user.skills.length > 0 && (
                <div className="item-skills">
                    {user.skills.map(skill => <span key={skill} className="skill-tag">{skill}</span>)}
                </div>
            )}

            
                        <div className="item-links">
                            {user.linkedin_profile && <a href={user.linkedin_profile} target="_blank" rel="noopener noreferrer">LinkedIn</a>}
                            {user.portfolio_url && <a href={user.portfolio_url} target="_blank" rel="noopener noreferrer">Portfolio</a>}
                            {user.resume_url ? (
                                <a href={`http://localhost:8000${user.resume_url}`} target="_blank" rel="noopener noreferrer" className="resume-link">üìÑ View Resume</a>
                            ) : (
                                <span className="no-resume">No Resume</span>
                            )}
                        </div>

                        {/* --- ACTION AREA: ONLY SHOW FOR RECRUITERS --- */}
            {isRecruiter && (
                <div className="action-area">
                    {isScheduled && isInterviewPassed && !loading ? (
                        <div className="decision-buttons">
                            <button className="decision-btn hire-btn" onClick={() => handleDecision("Hired")}>
                                üéâ Hire
                            </button>
                            <button className="decision-btn reject-btn" onClick={() => handleDecision("Rejected")}>
                                ‚ùå Reject
                            </button>
                        </div>
                    ) : (
                        onInviteClick && user.jobId && user.UserID && (
                            <button 
                                className={`action-button ${isScheduled || isRejected || isHired ? 'disabled-button' : 'invite-button'}`}
                                disabled={isScheduled || isRejected || isHired || loading}
                                onClick={() => onInviteClick(user.UserID, user.jobId, `${user.firstName} ${user.lastName}`, user.jobTitle)}
                            >
                                {loading ? 'Updating...' : buttonText}
                            </button>
                        )
                    )}
                </div>
            )}
        </div>
    );
};

// A helper component to render an application card (for user's own applications)
const ApplicationResult = ({ app }) => (
    <div className="result-item">
        <div className="item-header">
            <span className="item-title">{app.job?.title || 'N/A'}</span>
            <span className="item-status">{app.status}</span>
        </div>
        <div className="item-company">{app.job?.company || 'N/A'}</div>
        {app.notes && (
            <div className="item-notes">
                <strong>Your Notes:</strong> {app.notes}
            </div>
        )}
    </div>
);


const ResultsDisplay = ({ rawGql, rawJson, onInviteClick, currentUserRole }) => {
  const [detailsVisible, setDetailsVisible] = useState(false);

  let resultsContent = null;
  const resultData = rawJson?.data;

  // Check for different types of data and prepare the display content
  if (resultData) {
      // Handles a list of the user's own applications
      if (resultData.applications && Array.isArray(resultData.applications)) {
          resultsContent = (
              <div className="result-item job-applicant-container">
                  <h3 className="container-title">Your Applications</h3>
                  {resultData.applications.length > 0 ? (
                      resultData.applications.map(app => <ApplicationResult key={app.appId} app={app} />)
                  ) : (
                      <p>You have not applied to any jobs yet.</p>
                  )}
              </div>
          );
      }
      // Handles the result of updating an application status or adding a note
      else if (resultData.updateApplicationStatusByNames || resultData.addNoteToApplicationByJob) {
          const app = resultData.updateApplicationStatusByNames || resultData.addNoteToApplicationByJob;
          resultsContent = <ApplicationResult app={app} />;
      }
      // Handles a request for jobs that includes an application count
      else if (resultData.jobs && Array.isArray(resultData.jobs) && resultData.jobs[0]?.applicationCount !== undefined) {
          resultsContent = resultData.jobs.map(job => (
              <div key={job.jobId} className="result-item application-count-result">
                  The job "{job.title}" at {job.company} has {job.applicationCount} application's.
              </div>
          ));
      }
      // Handles a request for jobs with nested applicants
      else if (resultData.jobs && Array.isArray(resultData.jobs) && resultData.jobs[0]?.applicants) {
          resultsContent = resultData.jobs.map(job => (
              <div key={job.jobId} className="result-item job-applicant-container">
                  <h3 className="container-title">Applicants for: {job.title} at {job.company}</h3>
                      {job.applicants.length > 0 ? (
                      job.applicants.map(applicant => <UserResult key={applicant.UserID} user={{...applicant, jobId: job.jobId, jobTitle: job.title}} onInviteClick={onInviteClick} />)
                  ) : (
                      <p>No applicants found for this job yet.</p>
                  )}
              </div>
          ));
      }
      // Handles a simple list of jobs
      else if (resultData.jobs && Array.isArray(resultData.jobs)) {
          resultsContent = resultData.jobs.length > 0
            ? resultData.jobs.map(job => <JobResult key={job.jobId} job={job} />)
            : <p>No jobs found matching your criteria.</p>;
      
      // Handles a list of users
            } else if (resultData.users && Array.isArray(resultData.users)) {
                    resultsContent = resultData.users.length > 0
                        ? resultData.users.map(user => <UserResult key={user.UserID} user={user} onInviteClick={onInviteClick} />)
                        : <p>No users found matching your criteria.</p>;

      // Handles a single user lookup
      } else if (resultData.userById) {
          resultsContent = <UserResult user={resultData.userById} onInviteClick={onInviteClick} />;

      // Handles a successful user creation or update
      } else if (resultData.createUser || resultData.updateUser || resultData.addSkillsToUser) {
                    const user = resultData.createUser || resultData.updateUser || resultData.addSkillsToUser;
                    resultsContent = (
                        <div>
                            <p>‚úÖ Success! User profile updated:</p>
                            <UserResult user={user} onInviteClick={onInviteClick} />
                        </div>
                    );
      }
  }
  
  // Fallback for successful operations that don't return a known data structure
  if (!resultsContent && rawJson?.data) {
      resultsContent = <p>‚úÖ The operation was successful. View details for the raw response.</p>;
  // Fallback for GraphQL errors
  } else if (!resultsContent && rawJson?.errors) {
      resultsContent = <p>‚ùå An error occurred. See details for more information.</p>;
  }

  return (
    <div className="results-display">
      <div className="results-summary">
        {resultsContent}
      </div>
      
      <div className="details-toggle">
        <button onClick={() => setDetailsVisible(!detailsVisible)}>
          {detailsVisible ? 'Hide GraphQL & JSON' : 'Show GraphQL & JSON'}
        </button>
      </div>

      {detailsVisible && (
        <div className="raw-details">
          <strong>Generated GraphQL:</strong>
          <pre>{rawGql}</pre>
          
          <strong>Result JSON:</strong>
          <pre>{JSON.stringify(rawJson, null, 2)}</pre>
        </div>
      )}
    </div>
  );
};

// Helper function to render a status badge
const StatusBadge = ({ status }) => {
    let className = 'item-status';
    if (status === 'Hired') className += ' status-hired';
    else if (status === 'Interviewing' || status === 'interview') className += ' status-interviewing';
    else if (status === 'Rejected') className += ' status-rejected';
    else className += ' status-applied';

    return <span className={className}>{status.charAt(0).toUpperCase() + status.slice(1)}</span>;
};

export default ResultsDisplay;
</file>

<file path="src/backend/resolvers/application_resolvers.py">
# src/backend/resolvers/application_resolvers.py
from datetime import datetime
from ariadne import QueryType, MutationType, ObjectType
from ..db import next_application_id, to_application_output, interviews_collection
from ..validators.common_validators import clean_update_input
from ..repository import user_repo, job_repo, application_repo
from ..services import email_service
import threading
import logging # <-- NEW IMPORT

logger = logging.getLogger(__name__) # <-- NEW LOGGER INSTANCE

query = QueryType()
mutation = MutationType()
application = ObjectType("Application")
job = ObjectType("Job")

# --- CORE WORKFLOW HELPER FUNCTIONS ---

def _handle_hired_status_side_effects(job_id, hired_user_id):
    """
    This function runs in a background thread to:
    1. Close the job.
    2. Notify all other unsuccessful applicants.
    """
    print(f"Triggering side-effects for hired status on job {job_id}...")
    job_repo.update_one_job({"jobId": job_id}, {"status": "Closed"})
    
    # Find all other applications for this job (excluding the hired user)
    other_apps = application_repo.find_applications({"jobId": job_id, "userId": {"$ne": hired_user_id}})
    job = job_repo.find_job_by_id(job_id)
    if not job: 
        print(f"ERROR: Could not find job {job_id} for rejection emails.")
        return

    for app in other_apps:
        # Only notify if status is Applied or Interviewing (i.e., not already Rejected)
        if app.get("status") in ["Applied", "Interviewing"]:
            candidate = user_repo.find_one_by_id(app["userId"])
            if candidate:
                email_service.send_rejection_notification(
                    to_email=candidate["email"], candidate_name=candidate["firstName"],
                    job_title=job["title"], company=job["company"],
                    app_id=app["appId"] # Correctly passes app_id
                )
                # OPTIONAL: Mark them as Rejected so they don't get processed again
                application_repo.update_one_application({"appId": app["appId"]}, {"status": "Rejected"})
                
    print("Hired status side-effects complete. Job is Closed, mass rejections sent.")

# --- FIELD RESOLVERS ---
@job.field("applicants") 
def resolve_job_applicants(job_obj, info):
    # --- SECURITY CHECK ---
    # If the user is NOT a recruiter, return an empty list or None
    if info.context.get("user_role") != "Recruiter":
        return []
    # ----------------------

    job_id = job_obj.get("jobId")
    if not job_id: return []
    
    # 1. Find all applications for the job
    applications = application_repo.find_applications({"jobId": job_id})
    if not applications: return []
    
    # 2. Get all unique UserIDs
    user_ids = [app.get("userId") for app in applications]
    user_id_to_status = {app.get("userId"): app.get("status") for app in applications} # Map for status lookup
    user_id_to_resume = {app.get("userId"): app.get("resume_url") for app in applications}

    # --- NEW: Fetch Interview Times ---
    interviews = list(interviews_collection().find({
        "jobId": job_id,
        "candidateId": {"$in": user_ids}
    }))
    user_id_to_time = {i.get("candidateId"): i.get("startTime") for i in interviews}
    # ----------------------------------

    if not user_ids: return []
    
    # 3. Fetch User documents
    applicant_docs = user_repo.find_users({"UserID": {"$in": user_ids}}, None, None)
    
    # 4. Attach status and format output
    output_users = []
    for doc in applicant_docs:
        user_output = user_repo.to_user_output(doc)
        # --- NEW: Inject application status into the User object for display ---
        user_output['applicationStatus'] = user_id_to_status.get(doc.get("UserID"), 'Applied') 
        user_output['resume_url'] = user_id_to_resume.get(doc.get("UserID"))
        
        # Inject Interview Time
        user_output['interviewTime'] = user_id_to_time.get(doc.get("UserID")) # <--- ADD THIS
        output_users.append(user_output)
        
    return output_users # Now each User object has an 'applicationStatus' field
    
@job.field("applicationCount")
def resolve_job_application_count(job_obj, info):
    job_id = job_obj.get("jobId")
    if not job_id: return 0
    return application_repo.count_applications({"jobId": job_id})

@query.field("applications")
def resolve_applications(obj, info, userId=None, jobId=None, status=None):
    q = {}
    # Security: If Applicant is requesting, restrict to their ID unless an ID is explicitly passed
    if info.context.get("user_role") == "Applicant" and not userId:
        userId = info.context.get("UserID")
    
    if userId: q["userId"] = int(userId)
    if jobId: q["jobId"] = int(jobId)
    if status: q["status"] = status
    
    docs = application_repo.find_applications(q)
    return [to_application_output(d) for d in docs]

@query.field("applicationById")
def resolve_application_by_id(*_, appId):
    doc = application_repo.find_application_by_id(int(appId))
    if not doc: raise ValueError(f"Application with ID {appId} not found.")
    return to_application_output(doc)

@application.field("candidate")
def resolve_application_candidate(app_obj, _):
    return user_repo.to_user_output(user_repo.find_one_by_id(app_obj.get("userId")))

@application.field("job")
def resolve_application_job(app_obj, _):
    return job_repo.to_job_output(job_repo.find_job_by_id(app_obj.get("jobId")))

# --- MUTATIONS ---

@mutation.field("createApplication")
def resolve_create_application(*_, input):
    user_id, job_id = input.get("userId"), input.get("jobId")
    if not user_repo.find_one_by_id(user_id): raise ValueError(f"Validation failed: User with ID {user_id} does not exist.")
    if not job_repo.find_job_by_id(job_id): raise ValueError(f"Validation failed: Job with ID {job_id} does not exist.")
    
    # Check for duplicate application
    existing_app = application_repo.find_applications({"userId": user_id, "jobId": job_id})
    if existing_app:
         raise ValueError(f"Duplicate application: This user has already applied to this job (AppID: {existing_app[0]['appId']}).")

    doc = {
        "appId": next_application_id(), "userId": user_id, "jobId": job_id,
        "status": "Applied", "submittedAt": datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'),
        "notes": input.get("notes"),
        # Denormalized fields are passed from resolve_apply and correctly inserted
        "userName": input.get("userName"),
        "jobTitle": input.get("jobTitle"),
        "companyName": input.get("companyName"),
    }
    application_repo.insert_application(doc)
    return to_application_output(doc)

@mutation.field("apply")
def resolve_apply(obj, info, userName, jobTitle, companyName=None):
    name_parts = userName.strip().split()
    first_name, last_name = (name_parts[0], " ".join(name_parts[1:])) if len(name_parts) > 1 else (name_parts[0], None)
    if not first_name: raise ValueError("User name cannot be empty.")

    # 1. FIND USER
    user_filter = user_repo.build_filter(first_name, last_name, None, None)
    matching_users = user_repo.find_users(user_filter, None, None)
    if len(matching_users) == 0: raise ValueError(f"Could not find a user named '{userName}'.")
    if len(matching_users) > 1: raise ValueError(f"Found multiple users named '{userName}'. Please be more specific.")
    user = matching_users[0]
    
    # 2. FIND JOB
    job_filter = job_repo.build_job_filter(companyName, None, jobTitle)
    matching_jobs = job_repo.find_jobs(job_filter, None, None)
    if len(matching_jobs) == 0: raise ValueError(f"Could not find a job with title '{jobTitle}' at company '{companyName or ''}'.")
    if len(matching_jobs) > 1: raise ValueError(f"Found multiple jobs with title '{jobTitle}'. Please specify a company.")
    job = matching_jobs[0]

    # 3. BUILD AND PASS DENORMALIZED INPUT
    application_input = {
        "userId": user["UserID"], 
        "jobId": job["jobId"],
        "userName": f"{user['firstName']} {user['lastName']}".strip(), 
        "jobTitle": job["title"],                                     
        "companyName": job["company"]                                 
    }
    return resolve_create_application(None, info, input=application_input)

@mutation.field("updateApplication")
def resolve_update_application(obj, info, appId, input):
    set_fields = clean_update_input(input)
    if not set_fields: raise ValueError("No fields provided to update.")
    updated = application_repo.update_one_application({"appId": int(appId)}, set_fields)
    if not updated: raise ValueError(f"Application with ID {appId} not found for update.")
    return to_application_output(updated)

@mutation.field("updateApplicationStatusByNames")
def resolve_update_application_status_by_names(obj, info, userName, jobTitle, newStatus, companyName=None):
    # --- AUTHORIZATION ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter": 
        logger.warning(f"Permission denied: Non-Recruiter attempted status update for {userName}")
        raise ValueError("Permission denied: You must be a Recruiter to update an application.")
    
    # --- FIND THE SINGLE TARGET APPLICATION ---
    application_filter = {"userName": userName, "jobTitle": jobTitle}
    if companyName: application_filter["companyName"] = companyName
    
    apps = application_repo.find_applications(application_filter)
    if not apps: 
        logger.warning(f"Application not found for {userName} at {jobTitle} ({companyName or 'any'}).")
        raise ValueError(f"No application found for '{userName}' at job '{jobTitle}' at company '{companyName or ''}'.")
    if len(apps) > 1: 
        logger.warning(f"Ambiguous application update for {userName} at {jobTitle}. Matches: {len(apps)}")
        raise ValueError("Found multiple matching applications. Please be more specific.")
    
    target_app_id = apps[0]["appId"]
    logger.debug(f"DEBUG_A: Found application {target_app_id}. Status being set to '{newStatus}'")

    # --- UPDATE STATUS ---
    updated_app = application_repo.update_one_application({"appId": target_app_id}, {"status": newStatus})
    if not updated_app: 
        logger.error(f"Failed to update application {target_app_id} status to {newStatus}.")
        raise ValueError("Failed to update application status.")

    logger.debug("DEBUG_B: Status successfully updated in DB.")

    # --- TRIGGER SIDE-EFFECTS (Email, Job Closure) ---
    candidate = user_repo.find_one_by_id(updated_app["userId"])
    job = job_repo.find_job_by_id(updated_app["jobId"])

    # --- FIX: Use .lower().startswith('interview') for safety ---
    if newStatus.lower().startswith("interview") and candidate and job:
        logger.debug("DEBUG_C: Initiating send_interview_invitation.")
        email_service.send_interview_invitation(
            to_email=candidate["email"], candidate_name=candidate["firstName"],
            job_title=job["title"], company=job["company"],
            app_id=updated_app["appId"] 
        )
    
    if newStatus.lower() == "hired" and candidate and job: # <-- FIX: Checking for 'hired' (long form)
        # Send confirmation/offer email to the hired candidate and audit success
        offer_subject = f"Job Offer for {job['title']} at {job['company']}"
        offer_body = f"<p>Congratulations {candidate['firstName']}, we are delighted to offer you the position!</p><p>Details will follow shortly.</p>"
        
        # We call the internal helper directly to send the email and audit
        if email_service._send_email(candidate["email"], offer_subject, offer_body): 
            email_service._audit_email_success(updated_app["appId"], "Hired")

        logger.debug("DEBUG_D: Starting background thread for mass rejection.")
        thread = threading.Thread(target=_handle_hired_status_side_effects, args=(job["jobId"], candidate["UserID"]))
        thread.start()

    # 3. NEW: Manual Rejection (Send Email Immediately)
    if newStatus.lower() == "rejected" and candidate and job:
        logger.debug(f"Sending rejection email to {candidate['email']}")
        email_service.send_rejection_notification(
            to_email=candidate["email"], 
            candidate_name=candidate["firstName"],
            job_title=job["title"], 
            company=job["company"],
            app_id=updated_app["appId"]
        )
    logger.debug(f"DEBUG_D: Final resolver output for App {target_app_id}.")
    return to_application_output(updated_app)

@mutation.field("addNoteToApplicationByJob")
def resolve_add_note_to_application_by_job(obj, info, jobTitle, note, companyName=None):
    # --- AUTHORIZATION (Implicit Applicant) ---
    user_id = info.context.get("UserID")
    if not user_id: raise ValueError("Permission denied: You must be logged in to add a note.")
    
    # 1. FIND JOB
    job_filter = job_repo.build_job_filter(companyName, None, jobTitle)
    jobs = job_repo.find_jobs(job_filter, None, None)
    if not jobs: raise ValueError(f"Could not find job with title '{jobTitle}'.")
    if len(jobs) > 1: raise ValueError(f"Found multiple jobs with title '{jobTitle}'. Please specify a company.")

    # 2. FIND APPLICANT'S APPLICATION
    application_filter = {"userId": user_id, "jobId": jobs[0]["jobId"]}
    apps = application_repo.find_applications(application_filter)
    if not apps: raise ValueError(f"You have not applied for the '{jobTitle}' job.")
    
    target_app_id = apps[0]["appId"]
    
    # 3. APPEND NOTE
    existing_notes = apps[0].get("notes", "") or ""
    # Applicant notes are simply appended, without a timestamp prefix
    updated_notes = f"{existing_notes}\n{note}".strip() 

    updated_app = application_repo.update_one_application({"appId": target_app_id}, {"notes": updated_notes})
    if not updated_app: raise ValueError("Failed to add note.")
    return to_application_output(updated_app)

@mutation.field("addManagerNoteToApplication")
def resolve_add_manager_note_to_application(obj, info, userName, jobTitle, note, companyName=None):
    # --- AUTHORIZATION ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter": raise ValueError("Permission denied: You must be a Recruiter to add a note.")
    
    # --- FIND THE SINGLE TARGET APPLICATION ---
    application_filter = {"userName": userName, "jobTitle": jobTitle}
    if companyName: application_filter["companyName"] = companyName

    apps = application_repo.find_applications(application_filter)
    if not apps: raise ValueError(f"No application found for user '{userName}' at job '{jobTitle}'.")
    if len(apps) > 1: raise ValueError("Found multiple matching applications. Please be more specific.")
    
    target_app_id = apps[0]["appId"]
    # --- END FIND LOGIC ---
    
    # --- APPEND NOTE ---
    existing_notes = apps[0].get("notes", "") or ""
    timestamp = datetime.utcnow().strftime('%Y-%m-%d')
    new_note = f"\n--- Recruiter Note ({timestamp}): {note}"
    updated_notes = existing_notes.strip() + new_note

    updated_app = application_repo.update_one_application({"appId": target_app_id}, {"notes": updated_notes})
    if not updated_app: raise ValueError("Failed to add note.")
    return to_application_output(updated_app)

# --- Ensure correct Query object is exposed for ariadne schema build ---
@query.field("applicationById")
def resolve_application_by_id(*_, appId):
    doc = application_repo.find_application_by_id(int(appId))
    if not doc: raise ValueError(f"Application with ID {appId} not found.")
    return to_application_output(doc)
</file>

<file path="src/frontend-react/src/App.js">
// src/frontend-react/src/App.js
import React, { useState, useEffect } from 'react';
import { Routes, Route, Navigate, useNavigate } from 'react-router-dom';
import './App.css';
import LoginPage from './LoginPage';
import ResultsDisplay from './ResultsDisplay';
import apiClient from './api';
import ResumeUploader from './ResumeUploader'; // Import the new uploader component
import CompleteProfilePage from './CompleteProfilePage';
import SchedulingPanel from './SchedulingPanel';

function ChatPage() {
  const navigate = useNavigate();
  const [user, setUser] = useState(null);
  const [uploadTarget, setUploadTarget] = useState(null); // State to trigger the uploader UI
  // --- NEW: Scheduling State ---
  const [schedulingTarget, setSchedulingTarget] = useState(null); // {candidateId, jobId, candidateName, jobTitle}
  // -----------------------------

  // --- This effect checks for a valid, non-expired session on component load ---
  useEffect(() => {
    const sessionJSON = localStorage.getItem('session');
    
    if (sessionJSON) {
      const session = JSON.parse(sessionJSON);
      const now = new Date().getTime();

      if (now > session.expiresAt) {
        localStorage.removeItem('session');
        navigate('/login');
      } else {
        setUser(session.user);
      }
    } else {
      navigate('/login');
    }
  }, [navigate]);

  const handleLogout = () => {
    localStorage.removeItem('session');
    setUser(null);
    navigate('/login');
  };

  // --- State and handlers for chat functionality ---
  const [messages, setMessages] = useState([
    { type: 'text', role: 'assistant', payload: { text: "Hi! Ask me anything about users or jobs." } }
  ]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [theme, setTheme] = useState(() => localStorage.getItem('theme') || 'light');

  // Effect to apply the theme to the document
  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
  }, [theme]);

  const toggleTheme = () => setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));

  const formatContentForDisplay = (content) => {
    return content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  };

  // --- NEW: Function to initiate scheduling from a component (like ResultsDisplay) ---
  const handleInitiateScheduling = (candidateId, jobId, candidateName, jobTitle) => {
    setSchedulingTarget({ candidateId, jobId, candidateName, jobTitle });
  };

  const handleSend = async (e) => {
    e.preventDefault();
    if (!input.trim() || loading) return;

    const userPrompt = input.trim();
    setMessages(prev => [...prev, { type: 'text', role: 'user', payload: { text: userPrompt } }]);
    setInput('');
    setLoading(true);

    try {
      const payload = { 
        query: userPrompt,
        userContext: user
      };
      
      const response = await apiClient.post('/nl2gql', payload);
      const { graphql = "", result = {} } = response.data;

      // Check for a successful 'apply' mutation to trigger the resume uploader
      if (result.data?.apply) {
        const application = result.data.apply;
        setUploadTarget({
          appId: application.appId,
          jobTitle: application.job.title,
        });
        // Add the success message to the chat first
        setMessages(prev => [...prev, { type: 'results', role: 'assistant', payload: { rawGql: graphql, rawJson: result } }]);
      }
      else if (graphql === "Small talk handled by service logic" && result.response) {
        setMessages(prev => [...prev, { type: 'text', role: 'assistant', payload: { text: result.response } }]);
      } else {
        setMessages(prev => [...prev, { type: 'results', role: 'assistant', payload: { rawGql: graphql, rawJson: result } }]);
      }
    } catch (error) {
      const err_msg = error.response?.data?.error?.message || "An unexpected error occurred while connecting to the service.";
      setMessages(prev => [...prev, { type: 'text', role: 'assistant', payload: { text: `**Error:** ${err_msg}` } }]);
    } finally {
      setLoading(false);
    }
  };

  // Render nothing until the authentication check is complete
  if (!user) {
    return null;
  }

  // --- JSX for the ChatPage component ---
  return (
    <div className="App">
      <div className="header-container">
        <h1>JobChat.AI</h1>
        <div className="header-controls">
          <span className="user-greeting">Hi, {user.firstName}! ({user.role})</span>
          <button onClick={toggleTheme} className="theme-toggle">
            {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
          </button>
          <button onClick={handleLogout} className="logout-button" title="Logout">
            Logout
          </button>
        </div>
      </div>

      {user.role === 'Recruiter' && (
        <div className="recruiter-panel">
          <p>Recruiter Tools: You can now post jobs. Try asking: "create a job for a Senior Python Developer at Google..."</p>
        </div>
      )}

      <div className="message-container">
        {messages.map((m, index) => (
          <div key={index} className={`message ${m.role}-message`}>
            {m.type === 'results' ? (
              <ResultsDisplay 
                rawGql={m.payload.rawGql} 
                rawJson={m.payload.rawJson} 
                onInviteClick={handleInitiateScheduling}
                currentUserRole={user.role}
              />
            ) : (
              <div
                className="message-bubble"
                dangerouslySetInnerHTML={{ __html: formatContentForDisplay(m.payload.text) }}
              />
            )}
          </div>
        ))}
      </div>
      
      {/* Conditionally render the ResumeUploader when a target is set */}
      {uploadTarget && (
        <ResumeUploader 
          target={uploadTarget} 
          onComplete={() => setUploadTarget(null)} 
        />
      )}
      {/* --- NEW: Scheduling Component --- */}
      {schedulingTarget && (
        <SchedulingPanel
          target={schedulingTarget}
          onClose={() => setSchedulingTarget(null)}
          recruiterId={user.UserID}
        />
      )}
      
      <form onSubmit={handleSend} className="input-form">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type a request like 'find jobs in London'..."
          disabled={loading || !!uploadTarget || !!schedulingTarget} // <-- Disable input when scheduling
        />
        <button type="submit" disabled={loading || !!uploadTarget || !!schedulingTarget}>
          {loading ? '...' : 'Send'}
        </button>
      </form>
    </div>
  );
}


// --- Main App Component for Routing ---
function App() {
  return (
    <Routes>
      <Route path="/login" element={<LoginPage />} />
      <Route path="/chat" element={<ChatPage />} />
      <Route path="/complete-profile/:userId" element={<CompleteProfilePage />} />
      <Route path="/" element={<Navigate to="/chat" />} />
    </Routes>
  );
}

export default App;
</file>

<file path="src/backend/app.py">
# src/backend/app.py
import os
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))
import logging 
from flask import send_from_directory

import bcrypt
import requests
from flask_cors import CORS
from flask import Flask, jsonify, request
from ariadne import load_schema_from_path, make_executable_schema, graphql_sync
from ariadne.explorer import ExplorerGraphiQL
from dotenv import load_dotenv
from werkzeug.exceptions import HTTPException
from datetime import datetime

from src.backend.services import resume_parser_service 
from src.backend.models.user_models import UserProfileType
from src.backend.errors import handle_http_exception, handle_value_error, handle_generic_exception, json_error
from src.backend.services.nl2gql_service import process_nl2gql_request
from src.backend.repository import user_repo, application_repo # Added application_repo for upload endpoint
from src.backend.db import ensure_user_counter, ensure_job_counter, ensure_application_counter, ensure_interview_counter, next_user_id
from werkzeug.utils import secure_filename

# Import resolvers
from src.backend.resolvers.user_resolvers import query as user_query, mutation as user_mutation
from src.backend.resolvers.job_resolvers import query as job_query, mutation as job_mutation
# --- FIX 1: Import the 'job' ObjectType from the application resolvers ---
from src.backend.resolvers.application_resolvers import query as app_query, mutation as app_mutation, application as application_object, job

# --- NEW: Import Scheduling Resolvers ---
from src.backend.resolvers.scheduling_resolvers import query as scheduling_query, mutation as scheduling_mutation, interview as interview_object

# Load environment variables
load_dotenv(os.path.join(os.path.dirname(__file__), '../.env'))

# --- Flask app setup ---
app = Flask(__name__)
CORS(app)
explorer_html = ExplorerGraphiQL().html(None)

# Configure basic logging to console
logging.basicConfig(
    level=logging.DEBUG, # Set to DEBUG for maximum output during debugging
    format='%(asctime)s - %(levelname)s - %(threadName)s - %(message)s'
)
logger = logging.getLogger('FLASK_APP') # Create a main logger instance
# --- NEW: Suppress Verbose MongoDB Logging ---
logging.getLogger('pymongo').setLevel(logging.WARNING)
logging.getLogger('pymongo.server_monitoring').setLevel(logging.WARNING)

# --- Load GraphQL schema ---
schema_path = os.path.join(os.path.dirname(__file__), "schema.graphql")
type_defs = load_schema_from_path(schema_path)
schema = make_executable_schema(
    type_defs,
    [user_query, job_query, app_query, scheduling_query],
    [user_mutation, job_mutation, app_mutation, scheduling_mutation],
    application_object,
    job,  # --- FIX 2: Pass the imported 'job' ObjectType to the schema builder ---
    interview_object
)

# Initialize database counters
ensure_user_counter()
ensure_job_counter()
ensure_application_counter()
ensure_interview_counter()

# --- Error Handlers ---
@app.errorhandler(HTTPException)
def http_error(e): return handle_http_exception(e)
@app.errorhandler(ValueError)
def value_error(e): return handle_value_error(e)
@app.errorhandler(Exception)
def unhandled_exception(e): return handle_generic_exception(e)

@app.route("/resumes/<path:filename>", methods=["GET"])
def serve_resume(filename):
    return send_from_directory(RESUME_FOLDER, filename)

# --- GraphQL endpoints ---
@app.route("/graphql", methods=["GET"])
def graphql_explorer(): return explorer_html, 200
@app.route("/graphql", methods=["POST"])
def graphql_server():
    data = request.get_json(silent=True)
    user_role = request.headers.get("X-User-Role", "Applicant")
    user_id = request.headers.get("X-User-ID")
    first_name = request.headers.get("X-User-FirstName", "")
    last_name = request.headers.get("X-User-LastName", "")
    logger.debug(f"Incoming Headers - X-User-ID: {user_id}, Role: {user_role}")
    
    # Build context with user information
    context = {
        "request": request, 
        "user_role": user_role
    }
    
    # Add user details to context if UserID is provided
    if user_id:
        try:
            context["UserID"] = int(user_id)
            context["firstName"] = first_name
            context["lastName"] = last_name
        except ValueError:
            pass  # Invalid UserID, skip adding to context
            
    # DEBUG LOGGING (moved below context creation to avoid UnboundLocalError)
    logger.debug(f"Constructed Context keys: {list(context.keys())}")
    if "UserID" in context:
        logger.debug(f"Context UserID: {context['UserID']}")
    
    success, result = graphql_sync(
        schema, 
        data, 
        context_value=context, 
        debug=app.debug
    )
    logger.debug(f"result: {result}")
    return jsonify(result), (200 if success else 400)

# --- Health check ---
@app.route("/")
def health(): return jsonify({"status": "Backend is running!"}), 200

# --- File Upload Endpoint ---
RESUME_FOLDER = os.path.join(os.path.dirname(__file__), 'resumes')
ALLOWED_EXTENSIONS = {'pdf', 'docx'}
if not os.path.exists(RESUME_FOLDER):
    os.makedirs(RESUME_FOLDER)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route("/applications/<int:appId>/resume", methods=["POST"])
def upload_resume(appId):
    if 'resume' not in request.files: return jsonify({"error": "No resume file part in the request"}), 400
    file = request.files['resume']
    if file.filename == '': return jsonify({"error": "No selected file"}), 400
    if file and allowed_file(file.filename):
        application = application_repo.find_application_by_id(appId)
        if not application: return jsonify({"error": "Application not found"}), 404
        user_id = application.get("userId")
        filename = f"user_{user_id}_app_{appId}_{secure_filename(file.filename)}"
        file_path = os.path.join(RESUME_FOLDER, filename)
        file.save(file_path)
        resume_url = f"/resumes/{filename}"
        application_repo.update_one_application({"appId": appId}, {"resume_url": resume_url})
        try:
            resume_parser_service.parse_resume_and_update_user(file_path, user_id)
        except Exception as e:
            print(f"Error triggering resume parsing: {e}")
        return jsonify({"message": "Resume uploaded successfully!", "resume_url": resume_url}), 200
    return jsonify({"error": "File type not allowed"}), 400

# --- NL2GQL Endpoint ---
@app.route("/nl2gql", methods=["POST"])
def nl2gql():
    data = request.get_json(silent=True) or {}
    user_text = data.get("query", "")
    user_context = data.get("userContext")
    run_graphql = request.args.get("run", "true").lower() != "false"
    with open(schema_path, "r", encoding="utf-8") as f: schema_sdl = f.read()
    def execute_graphql_query(gql_data):
        user_role = request.headers.get("X-User-Role", "Applicant")
        user_id = request.headers.get("X-User-ID")
        first_name = request.headers.get("X-User-FirstName", "")
        last_name = request.headers.get("X-User-LastName", "")
        
        context = {
            "request": request, 
            "user_role": user_role, 
            "user": user_context
        }
        
        if user_id:
            try:
                context["UserID"] = int(user_id)
                context["firstName"] = first_name
                context["lastName"] = last_name
            except ValueError:
                pass

        return graphql_sync(
            schema, gql_data, 
            context_value=context, 
            debug=app.debug
        )
    payload, status_code = process_nl2gql_request(user_text, schema_sdl, run_graphql, execute_graphql_query, user_context)
    return jsonify(payload), status_code

# --- User Authentication Endpoints ---
@app.route("/register", methods=["POST"])
def register_user():
    # ... (all existing validation logic is the same)
    data = request.get_json()
    email, password, first_name, last_name, role = data.get("email"), data.get("password"), data.get("firstName"), data.get("lastName"), data.get("role")
    if not all([email, password, first_name, last_name, role]): return jsonify({"error": "Missing required fields"}), 400
    # ... (role validation, existing user check, password hashing are the same)

    new_user_doc = {
        "UserID": next_user_id(), "email": email.lower(), "password": bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()),
        "firstName": first_name, "lastName": last_name, "role": role, "phone_number": None, "city": None,
        "state_province": None, "country": None, "linkedin_profile": None, "portfolio_url": None,
        "highest_qualification": None, "years_of_experience": None, "createdAt": datetime.utcnow().isoformat(),
        "dob": None, "skills": [], "professionalTitle": None, "is_us_citizen": None, "highest_degree_year": None
    }
    
    try:
        user_repo.insert_user(new_user_doc)
        # --- THE CHANGE: Return the new UserID on success ---
        return jsonify({
            "message": "User registered successfully!",
            "UserID": new_user_doc["UserID"]
        }), 201
    except Exception as e:
        return jsonify({"error": f"An internal error occurred: {e}"}), 500

# --- NEW User-Profile Resume Upload Endpoint ---
@app.route("/users/<int:user_id>/resume", methods=["POST"])
def upload_profile_resume(user_id):
    if 'resume' not in request.files: return jsonify({"error": "No resume file part"}), 400
    file = request.files['resume']
    if file.filename == '': return jsonify({"error": "No selected file"}), 400

    if file and allowed_file(file.filename):
        # Verify the user exists
        user = user_repo.find_one_by_id(user_id)
        if not user:
            return jsonify({"error": "User not found"}), 404
        
        filename = f"user_{user_id}_profile_{secure_filename(file.filename)}"
        file_path = os.path.join(RESUME_FOLDER, filename)
        file.save(file_path)
        
        # Trigger the parsing service (this can be slow, ideally a background job)
        try:
            resume_parser_service.parse_resume_and_update_user(file_path, user_id)
        except Exception as e:
            print(f"Error triggering profile resume parsing: {e}")

        return jsonify({"message": "Resume uploaded and parsing initiated."}), 200

    return jsonify({"error": "File type not allowed"}), 400
   
@app.route("/login", methods=["POST"])
def login_user():
    data = request.get_json()
    if not data: return jsonify({"error": "Invalid JSON body"}), 400
    email, password = data.get("email"), data.get("password")
    if not email or not password: return jsonify({"error": "Email and password are required"}), 400
    user = user_repo.find_user_by_email(email)
    if not user: return jsonify({"error": "Invalid email or password"}), 401
    if bcrypt.checkpw(password.encode('utf-8'), user.get("password")):
        user_data = user_repo.to_user_output(user)
        return jsonify({"message": "Login successful!", "user": user_data}), 200
    else:
        return jsonify({"error": "Invalid email or password"}), 401

if __name__ == "__main__":
    print("üöÄ Starting Flask server on http://localhost:8000 ...")
    app.run(host="0.0.0.0", port=8000, debug=True)
</file>

<file path="src/backend/schema.graphql">
# src/backend/schema.graphql
type User {
  UserID: Int!
  email: String!
  firstName: String!
  lastName: String!
  role: String!
  phone_number: String
  city: String
  state_province: String
  country: String
  linkedin_profile: String
  portfolio_url: String
  highest_qualification: String
  years_of_experience: Int
  createdAt: String
  dob: String
  skills: [String]
  professionalTitle: String
  is_us_citizen: Boolean
  highest_degree_year: Int
  applicationStatus: String
  resume_url: String
  interviewTime: String 
}
input UserInput {
  firstName: String!
  lastName: String!
  email: String!
  role: String!
  phone_number: String
  city: String
  state_province: String
  country: String
  linkedin_profile: String
  portfolio_url: String
  highest_qualification: String
  years_of_experience: Int
  dob: String
  skills: [String]
  professionalTitle: String
}
input UserUpdateInput {
  firstName: String
  lastName: String
  phone_number: String
  city: String
  state_province: String
  country: String
  linkedin_profile: String
  portfolio_url: String
  highest_qualification: String
  years_of_experience: Int
  dob: String
  skills: [String]
  professionalTitle: String
  is_us_citizen: Boolean
  highest_degree_year: Int
}
type Job {
  jobId: Int!
  title: String!
  company: String
  location: String
  salaryRange: String
  skillsRequired: [String]
  description: String
  postedAt: String
  applicants: [User!]
  applicationCount: Int!
  requires_us_citizenship: Boolean
  minimum_degree_year: Int
  status: String
  posterUserId: Int
  posterName: String
}
input JobInput {
  title: String!
  company: String
  location: String
  salaryRange: String
  skillsRequired: [String]
  description: String
}
input JobUpdateInput {
  title: String
  company: String
  location: String
  salaryRange: String
  skillsRequired: [String]
  description: String
  requires_us_citizenship: Boolean
  minimum_degree_year: Int
  status: String
}
type Application {
  appId: Int!
  userId: Int!
  jobId: Int!
  status: String!
  submittedAt: String!
  notes: String
  candidate: User
  job: Job
  resume_url: String
  # Denormalized fields for easier querying
  userName: String
  jobTitle: String
  companyName: String
  emailSent: String # Track email status
}
input ApplicationInput {
  userId: Int!
  jobId: Int!
  notes: String
}
input ApplicationUpdateInput {
  status: String
  notes: String
}

"""
Represents a single block of a recruiter's weekly availability.
"""
type AvailabilitySlot {
  dayOfWeek: String! # e.g., "Monday", "Tuesday"
  startTime: String! # e.g., "09:00"
  endTime: String!   # e.g., "17:00"
}

input AvailabilityInput {
  dayOfWeek: String!
  startTime: String!
  endTime: String!
}

"""
Represents a confirmed interview booking.
"""
type Interview {
  interviewId: Int!
  jobId: Int!
  candidateId: Int!
  recruiterId: Int!
  startTime: String! # ISO 8601 UTC timestamp
  endTime: String!   # ISO 8601 UTC timestamp
  job: Job           # <-- Field Resolver will fetch job details
  candidate: User    # <-- Field Resolver will fetch candidate details
}

type Query {
  users(
    limit: Int
    skip: Int
    firstName: String
    lastName: String
    dob: String
    skills: [String!]
    isUSCitizen: Boolean
    yearsOfExperience_gte: Int
  ): [User!]!
  userById(UserID: Int!): User
  jobs(
    limit: Int
    skip: Int
    company: String
    location: String
    title: String
    posterUserId: Int
  ): [Job!]!
  jobById(jobId: Int!): Job
  applications(userId: Int, jobId: Int, status: String): [Application!]!
  applicationById(appId: Int!): Application
  """
  Fetches the weekly availability schedule for the logged-in recruiter.
  """
  mySchedule: [AvailabilitySlot!]
  """
  Finds conflict-free interview slots for the Recruiter and Candidate.
  Returns ISO 8601 strings for available start times.
  """
  findAvailableSlots(candidateId: Int!, durationMinutes: Int, numDays: Int): [String!]!
}

type Mutation {
  createUser(input: UserInput!): User!
  updateUser(UserID: Int!, input: UserUpdateInput!): User!
  updateUserByName(
    firstName: String
    lastName: String
    input: UserUpdateInput!
  ): User!
  deleteUser(UserID: Int!): Boolean!
  deleteUserByFields(firstName: String, lastName: String, dob: String): Boolean!
  createJob(input: JobInput!): Job!
  updateJob(jobId: Int!, input: JobUpdateInput!): Job
  updateJobByFields(title: String!, company: String, input: JobUpdateInput!): Job
  deleteJob(jobId: Int!): Boolean!
  addSkillsToJob(jobId: Int!, skills: [String!]!): Job
  deleteJobByFields(title: String!, company: String): Boolean!
  createApplication(input: ApplicationInput!): Application!
  apply(userName: String!, jobTitle: String!, companyName: String): Application!
  updateApplication(appId: Int!, input: ApplicationUpdateInput!): Application
  addSkillsToUser(UserID: Int!, skills: [String!]!): User
  updateApplicationStatusByNames(
    userName: String!
    jobTitle: String!
    companyName: String
    newStatus: String!
  ): Application
  addNoteToApplicationByJob(
    jobTitle: String!
    note: String!
    companyName: String
  ): Application
  """
  Allows a Recruiter to add private notes to a candidate's application.
  """
  addManagerNoteToApplication(
    userName: String!
    jobTitle: String!
    companyName: String
    note: String!
  ): Application

  """
  Sets the recurring weekly availability for the logged-in recruiter.
  This will overwrite any existing schedule.
  """
  setMyAvailability(availability: [AvailabilityInput!]!): Boolean!

  """
  Books a new interview slot. The system performs a final conflict check before booking.
  """
  bookInterview(jobId: Int!, candidateId: Int!, startTime: String!, endTime: String!): Interview
}
</file>

</files>
