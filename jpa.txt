This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
README.md
requirements.txt
src/backend/.env
src/backend/app.py
src/backend/db.py
src/backend/errors.py
src/backend/models/user_models.py
src/backend/repository/account_repo.py
src/backend/repository/application_repo.py
src/backend/repository/job_repo.py
src/backend/repository/user_repo.py
src/backend/resolvers/application_resolvers.py
src/backend/resolvers/job_resolvers.py
src/backend/resolvers/user_resolvers.py
src/backend/schema.graphql
src/backend/services/nl2gql_service.py
src/backend/validators/common_validators.py
src/frontend-react/.env.development
src/frontend-react/package.json
src/frontend-react/public/index.html
src/frontend-react/src/App.css
src/frontend-react/src/App.js
src/frontend-react/src/index.js
src/frontend-react/src/LoginPage.css
src/frontend-react/src/LoginPage.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/backend/repository/account_repo.py">
# src/backend/repository/account_repo.py
from typing import Optional, Dict, Any
from ..db import get_db

def accounts_collection():
    """Returns a handle to the 'accounts' collection."""
    return get_db()["accounts"]

def find_account_by_email(email: str) -> Optional[dict]:
    """
    Finds a single account by its email (case-insensitive).
    """
    return accounts_collection().find_one({"email": {"$regex": f"^{email}$", "$options": "i"}})

def insert_account(account_doc: Dict[str, Any]) -> None:
    """
    Inserts a new account document into the database.
    """
    accounts_collection().insert_one(account_doc)
</file>

<file path="src/frontend-react/src/LoginPage.css">
/* src/frontend-react/src/App.css */

/* --- Add these styles to the end of the file --- */

.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background-color: var(--background-color);
}

.login-form {
  padding: 40px;
  background-color: var(--card-background);
  border-radius: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  width: 100%;
  max-width: 400px;
  text-align: center;
}

.login-form h2 {
  margin-bottom: 25px;
  color: var(--text-color);
}

.input-group {
  margin-bottom: 20px;
  text-align: left;
}

.input-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: 600;
  color: var(--text-color);
}

.input-group input {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--border-color);
  border-radius: 5px;
  background-color: var(--input-bg);
  color: var(--text-color);
  box-sizing: border-box; /* Ensures padding doesn't affect width */
}

.login-button {
  width: 100%;
  padding: 12px;
  background-color: var(--button-bg);
  color: var(--button-text);
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  transition: background-color 0.2s;
}

.login-button:hover {
  background-color: #0b5cb0;
}

.toggle-form {
  margin-top: 20px;
  font-size: 14px;
}

.toggle-button {
  background: none;
  border: none;
  color: var(--button-bg);
  cursor: pointer;
  font-weight: bold;
  padding: 0 5px;
  font-size: 14px;
}

.input-group select {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--border-color);
  border-radius: 5px;
  background-color: var(--input-bg);
  color: var(--text-color);
  box-sizing: border-box;
  font-size: 16px; /* Match input font-size */
  font-family: inherit; /* Inherit font from parent */
  -webkit-appearance: none; /* Removes default browser styling on Safari/Chrome */
  -moz-appearance: none; /* Removes default browser styling on Firefox */
  appearance: none;
  background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23666%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
  background-repeat: no-repeat;
  background-position: right 1rem center;
  background-size: 0.65em auto;
}
</file>

<file path="src/frontend-react/src/LoginPage.js">
// src/frontend-react/src/LoginPage.js
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import './LoginPage.css';

const API_ENDPOINT = process.env.REACT_APP_API_ENDPOINT || 'http://localhost:8000';

function LoginPage() {
  const [email, setEmail] = useState('');
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [password, setPassword] = useState('');
  const [role, setRole] = useState('Applicant');
  const [isLogin, setIsLogin] = useState(true);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (isLogin) {
      // --- Sign-In Logic ---
      try {
        const payload = { email, password };
        const response = await axios.post(`${API_ENDPOINT}/login`, payload);
        
        // 1. Store user data in session storage upon successful login
        sessionStorage.setItem('user', JSON.stringify(response.data.user));
        
        // 2. Redirect to the chat page
        navigate('/chat');

      } catch (error) {
        if (error.response && error.response.data.error) {
          alert(`Login failed: ${error.response.data.error}`);
        } else {
          alert('Login failed: An unknown error occurred.');
        }
        console.error('Login error:', error);
      }
    } else {
      // --- Registration Logic (remains the same) ---
      try {
        const payload = { email, firstName, lastName, password, role };
        const response = await axios.post(`${API_ENDPOINT}/register`, payload);

        alert(response.data.message);
        setIsLogin(true);
        setEmail('');
        setFirstName('');
        setLastName('');
        setPassword('');
        setRole('Applicant');

      } catch (error) {
        if (error.response && error.response.data.error) {
          alert(`Registration failed: ${error.response.data.error}`);
        } else {
          alert('Registration failed: An unknown error occurred.');
        }
        console.error('Registration error:', error);
      }
    }
  };

  // The JSX for the form remains unchanged
  return (
    <div className="login-container">
      <form onSubmit={handleSubmit} className="login-form">
        <h2>{isLogin ? 'Sign In' : 'Sign Up'}</h2>
        {!isLogin && (
          <>
            <div className="input-group"><label>First Name</label><input type="text" value={firstName} onChange={(e) => setFirstName(e.target.value)} required /></div>
            <div className="input-group"><label>Last Name</label><input type="text" value={lastName} onChange={(e) => setLastName(e.target.value)} required /></div>
            <div className="input-group"><label>I am a</label><select value={role} onChange={(e) => setRole(e.target.value)} required><option value="Applicant">User / Applicant</option><option value="Recruiter">Recruiter</option></select></div>
          </>
        )}
        <div className="input-group"><label>Email</label><input type="email" value={email} onChange={(e) => setEmail(e.target.value)} required /></div>
        <div className="input-group"><label>Password</label><input type="password" value={password} onChange={(e) => setPassword(e.target.value)} required /></div>
        <button type="submit" className="login-button">{isLogin ? 'Sign In' : 'Sign Up'}</button>
        <p className="toggle-form">{isLogin ? "Don't have an account?" : "Already have an account?"}<button type="button" onClick={() => setIsLogin(!isLogin)} className="toggle-button">{isLogin ? 'Sign Up' : 'Sign In'}</button></p>
      </form>
    </div>
  );
}

export default LoginPage;
</file>

<file path=".gitignore">
Python specific files

pycache/
*.pyc
.pytest_cache/
.coverage

Dependency directories

venv/
node_modules/
dist/
build/

IDE files

.idea/
.vscode/
</file>

<file path="README.md">
# Job Portal App

Lightweight job portal backend and Streamlit frontend for demo/testing purposes. This repository contains a Python-based GraphQL backend and a Streamlit frontend used to interact with job postings, applications and user data. It includes services for authentication, resume parsing and other helper components.

## Key features

- GraphQL backend (schema under `src/backend/schema.graphql`) exposing jobs, users and applications.
- Streamlit frontend demo app in `src/frontend/app_streamlit.py`.
- Simple services for auth, resume parsing, embeddings and NL2GQL utilities.
- Modular repository layout separating models, repositories, resolvers and services for easy testing and extension.

## Tech stack

- Python 3.10+ (recommended)
- Streamlit for the frontend demo
- GraphQL for the backend API
- Pytest for tests

## Repository layout (important files)

- `src/backend/app.py` â€” backend application entrypoint
- `src/backend/db.py` â€” database helpers
- `src/backend/schema.graphql` â€” GraphQL schema
- `src/backend/models/` â€” datamodels for jobs, users, applications
- `src/backend/repository/` â€” repository layer (data access)
- `src/backend/resolvers/` â€” GraphQL resolvers
- `src/backend/services/` â€” application services (auth, resume_parser, embeddings, etc.)
- `src/frontend/app_streamlit.py` â€” Streamlit demo frontend
- `tests/` â€” unit tests for backend, frontend and services

## Prerequisites

- Python 3.10 or newer installed and available on PATH as `python`.
- A working PowerShell (this README includes PowerShell commands).
- (Optional) Git to clone the repository.

## Setup (Windows PowerShell)

1. Create and activate a virtual environment:

```powershell
python -m venv .venv
.\.venv\Scripts\Activate.ps1
```

2. Install dependencies:

```powershell
python -m pip install --upgrade pip
python -m pip install -r requirements.txt
```

If you plan to run only the frontend demo, installing the full `requirements.txt` is the simplest choice.

## Running the backend

Start the backend (from repository root):

```powershell
python .\src\backend\app.py
```

This will start the backend service. The GraphQL endpoint and the exact host/port will depend on the implementation in `src/backend/app.py` (check that file for details). If the app exposes a `/graphql` endpoint, you can query it with a GraphQL client.

## Running the Streamlit frontend

Start the demo frontend (from repository root):

```powershell
streamlit run .\src\frontend\app_streamlit.py
```

The Streamlit UI should open in your default browser and interact with the running backend (or mock data depending on configuration).

## Tests

Run the test suite with pytest (from repository root):

```powershell
pytest -q
```

The `tests/` folder includes unit tests for repositories, resolvers and services.

## Development notes

- Code is organized to separate concerns: models â†’ repositories â†’ resolvers â†’ services.
- If you add new dependencies, update `requirements.txt` and include them in the virtualenv.
- Small, focused unit tests are included â€” please add tests for new behavior.

## Contributing

1. Fork the repository and create a feature branch.
2. Add tests for any new feature or bug fix.
3. Submit a pull request with a clear description of changes.

## License & Author

This repository is maintained by RJBOGA. Include your preferred license file if you want to open-source this project (e.g., MIT, Apache-2.0).

## Contact

For questions or help, open an issue in the repository or contact the maintainer.
</file>

<file path="requirements.txt">
# requirements.txt
Flask
ariadne
pymongo
python-dotenv
requests
streamlit
bcrypt
</file>

<file path="src/backend/app.py">
import os
import sys
# Add project root (src/) to sys.path for absolute imports from src.backend.*
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

import bcrypt
from src.backend.repository import account_repo
import requests
from flask_cors import CORS
from flask import Flask, jsonify, request
from ariadne import load_schema_from_path, make_executable_schema, graphql_sync
from ariadne.explorer import ExplorerGraphiQL
from dotenv import load_dotenv
from werkzeug.exceptions import HTTPException
from src.backend.models.user_models import UserProfileType

# Load environment variables from the src directory
load_dotenv(os.path.join(os.path.dirname(__file__), '../.env'))

# Import modules from the new structure
from src.backend.errors import (
    handle_http_exception,
    handle_value_error,
    handle_generic_exception,
    # unwrap_graphql_errors is now only used inside the service
    json_error,
)
# Import the NL2GQL service function
from src.backend.services.nl2gql_service import process_nl2gql_request

# Import resolvers for ALL entities
from src.backend.resolvers.user_resolvers import query as user_query, mutation as user_mutation
from src.backend.resolvers.job_resolvers import query as job_query, mutation as job_mutation
from src.backend.resolvers.application_resolvers import query as app_query, mutation as app_mutation, application as application_object

# Import for database counter initialization
from src.backend.db import ensure_user_counter, ensure_job_counter, ensure_application_counter

# --- Flask app setup ---
app = Flask(__name__)
CORS(app)
explorer_html = ExplorerGraphiQL().html(None)

# --- Load schema ---
schema_path = os.path.join(os.path.dirname(__file__), "schema.graphql")
type_defs = load_schema_from_path(schema_path)

# Combine resolvers from all modules into a list
schema = make_executable_schema(
    type_defs,
    [user_query, job_query, app_query],
    [user_mutation, job_mutation, app_mutation],
    application_object
)

# Initialize all database counters
ensure_user_counter()
ensure_job_counter()
ensure_application_counter()

# --- Error Handlers ---
@app.errorhandler(404)
def not_found(e):
    return json_error("Not found", 404)

@app.errorhandler(405)
def method_not_allowed(e):
    return json_error("Method not allowed", 405)

@app.errorhandler(ValueError)
def value_error(e):
    return handle_value_error(e)

@app.errorhandler(Exception)
def unhandled_exception(e):
    if isinstance(e, HTTPException):
        return handle_http_exception(e)
    return handle_generic_exception(e)

# --- GraphQL endpoints (No Changes) ---
@app.route("/graphql", methods=["GET"])
def graphql_explorer():
    return explorer_html, 200

@app.route("/graphql", methods=["POST"])
def graphql_server():
    data = request.get_json(silent=True)
    if not isinstance(data, dict):
        # We call jsonify here because this is the final response layer
        payload, status = json_error("Body must be JSON with 'query' and optional 'variables'", 400)
        return jsonify(payload), status

    success, result = graphql_sync(
        schema,
        data,
        context_value={"request": request},
        debug=app.debug,
    )
    # The main graphql endpoint doesn't need unwrap_graphql_errors,
    # as it returns the standard GraphQL JSON response including the "errors" key.
    return jsonify(result), (200 if success else 400)

# --- Health check (No Changes) ---
@app.route("/")
def health():
    return jsonify({"status": "Backend is running!"}), 200

# --- NL2GQL Endpoint (Simplified) ---
@app.route("/nl2gql", methods=["POST"])
def nl2gql():
    data = request.get_json(silent=True) or {}
    user_text = data.get("query", "")
    run_graphql = request.args.get("run", "true").lower() != "false"

    if not isinstance(user_text, str) or not user_text.strip():
        payload, status = json_error("Missing 'query' in body", 400)
        return jsonify(payload), status

    try:
        with open(schema_path, "r", encoding="utf-8") as f:
            schema_sdl = f.read()
    except Exception as e:
        payload, status = json_error(f"Failed to read schema: {e}", 500)
        return jsonify(payload), status

    def execute_graphql_query(gql_data):
        return graphql_sync(
            schema,
            gql_data,
            context_value={"request": request},
            debug=app.debug,
        )

    # The service now reliably returns a (payload_dict, status_code) tuple
    payload, status_code = process_nl2gql_request(
        user_text, schema_sdl, run_graphql, execute_graphql_query
    )

    # We can now simply jsonify the payload and return it with its status
    return jsonify(payload), status_code

# --- NEW User Registration Endpoint ---
@app.route("/register", methods=["POST"])
def register_user():
    data = request.get_json()
    if not data:
        return jsonify({"error": "Invalid JSON body"}), 400

    # 1. Extract and validate required fields, including the new 'role'
    email = data.get("email")
    password = data.get("password")
    first_name = data.get("firstName")
    last_name = data.get("lastName")
    role = data.get("role")

    if not all([email, password, first_name, last_name, role]):
        return jsonify({"error": "Missing required fields: email, password, firstName, lastName, role"}), 400

    # 2. Validate the role against our UserProfileType enum
    try:
        # This will check if 'role' is 'Applicant' or 'Recruiter' (case-insensitively)
        # and will raise a ValueError if it's not.
        validated_role = UserProfileType.from_str(role).value
    except ValueError as e:
        return jsonify({"error": str(e)}), 400

    # 3. Check if user already exists
    if account_repo.find_account_by_email(email):
        return jsonify({"error": f"An account with the email '{email}' already exists."}), 409

    # 4. Hash the password
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

    # 5. Create the new user document with the validated role
    new_account = {
        "email": email.lower(),
        "password": hashed_password,
        "firstName": first_name,
        "lastName": last_name,
        "role": validated_role  # Add the role to the document
    }

    # 6. Insert into the database
    try:
        account_repo.insert_account(new_account)
        return jsonify({
            "message": "User registered successfully!",
            "user": {"email": email, "role": validated_role}
        }), 201
    except Exception as e:
        return jsonify({"error": f"An internal error occurred: {e}"}), 500
    
# --- NEW User Login Endpoint ---
@app.route("/login", methods=["POST"])
def login_user():
    data = request.get_json()
    if not data:
        return jsonify({"error": "Invalid JSON body"}), 400

    email = data.get("email")
    password = data.get("password")

    if not email or not password:
        return jsonify({"error": "Email and password are required"}), 400

    # 1. Find the user account by email
    account = account_repo.find_account_by_email(email)
    if not account:
        return jsonify({"error": "Invalid email or password"}), 401 # 401 Unauthorized

    # 2. Check if the provided password matches the hashed password in the DB
    password_bytes = password.encode('utf-8')
    hashed_password_bytes = account.get("password") # Should already be bytes from BSON

    if bcrypt.checkpw(password_bytes, hashed_password_bytes):
        # 3. Passwords match! Prepare user data to send back to the frontend.
        # Do NOT send the password hash back.
        user_data = {
            "email": account.get("email"),
            "firstName": account.get("firstName"),
            "lastName": account.get("lastName"),
            "role": account.get("role")
        }
        return jsonify({
            "message": "Login successful!",
            "user": user_data
        }), 200
    else:
        # 4. Passwords do not match.
        return jsonify({"error": "Invalid email or password"}), 401

if __name__ == "__main__":
    print("ðŸš€ Starting Flask server on http://localhost:8000 ...")
    app.run(host="0.0.0.0", port=8000, debug=True)
</file>

<file path="src/backend/db.py">
# db.py
import os
from datetime import datetime
from dotenv import load_dotenv
from pymongo import MongoClient, ReturnDocument

# ... (no changes to MONGO_URI, DB_NAME, _client, _db, get_db)
load_dotenv(os.path.join(os.path.dirname(__file__), '../../config/.env'))
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017/")
DB_NAME = os.getenv("DB_NAME", "jobtracker")
_client = MongoClient(MONGO_URI)
_db = _client[DB_NAME]
def get_db():
    return _db


# --- Collection Helpers ---
def users_collection():
    return _db["users"]

def jobs_collection():
    return _db["jobs"]

def applications_collection(): # New
    return _db["applications"]

def counters_collection():
    return _db["counters"]


# --- Counters (User, Job, and new Application counter) ---
def _ensure_counter(counter_id: str):
    counters_collection().update_one(
        {"_id": counter_id},
        {"$setOnInsert": {"sequence_value": 0}},
        upsert=True,
    )

def _next_id(counter_id: str):
    result = counters_collection().find_one_and_update(
        {"_id": counter_id},
        {"$inc": {"sequence_value": 1}},
        return_document=ReturnDocument.AFTER,
        upsert=True,
    )
    return int(result["sequence_value"])

def ensure_user_counter():
    _ensure_counter("UserID")

def next_user_id():
    return _next_id("UserID")

def ensure_job_counter():
    _ensure_counter("jobId")

def next_job_id():
    return _next_id("jobId")

def ensure_application_counter(): # New
    _ensure_counter("appId")

def next_application_id(): # New
    return _next_id("appId")


# --- Output Formatting (no changes to user/job, new for application) ---
def to_user_output(doc: dict): # ... no changes
    if not doc:
        return None
    return {
        "UserID": int(doc.get("UserID")) if doc.get("UserID") is not None else None,
        "FirstName": doc.get("FirstName"),
        "LastName": doc.get("LastName"),
        "DateOfBirth": doc.get("DateOfBirth"),
        "ProfessionalTitle": doc.get("ProfessionalTitle"),
        "Summary": doc.get("Summary"),
    }

def to_job_output(doc: dict): # ... no changes
    if not doc:
        return None
    return {
        "jobId": int(doc.get("jobId")) if doc.get("jobId") is not None else None,
        "title": doc.get("title"),
        "company": doc.get("company"),
        "location": doc.get("location"),
        "salaryRange": doc.get("salaryRange"),
        "skillsRequired": doc.get("skillsRequired"),
        "description": doc.get("description"),
        "postedAt": doc.get("postedAt"),
    }

def to_application_output(doc: dict): # New
    if not doc:
        return None
    return {
        "appId": int(doc.get("appId")) if doc.get("appId") is not None else None,
        "userId": int(doc.get("userId")) if doc.get("userId") is not None else None,
        "jobId": int(doc.get("jobId")) if doc.get("jobId") is not None else None,
        "status": doc.get("status"),
        "submittedAt": doc.get("submittedAt"),
        "notes": doc.get("notes"),
    }
</file>

<file path="src/backend/errors.py">
from flask import jsonify
from werkzeug.exceptions import HTTPException

def json_error(message: str, status: int):
    """Creates a standard JSON error payload and returns it as a tuple."""
    error_payload = {"error": {"message": message, "status": status}}
    # In this new version, we return the payload and status,
    # letting the final route handler call jsonify.
    return error_payload, status

def handle_http_exception(e: HTTPException):
    message = getattr(e, "description", None) or getattr(e, "name", "HTTP Error")
    status = getattr(e, "code", None) or 500
    # Create the JSON response directly here for Flask's error handler
    payload, status_code = json_error(message, status)
    return jsonify(payload), status_code

def handle_value_error(e: ValueError):
    # Create the JSON response directly here for Flask's error handler
    payload, status_code = json_error(str(e), 400)
    return jsonify(payload), status_code

def handle_generic_exception(e: Exception):
    # Create the JSON response directly here for Flask's error handler
    payload, status_code = json_error("Internal server error", 500)
    return jsonify(payload), status_code

def unwrap_graphql_errors(result: dict):
    """
    Normalizes GraphQL error payloads into our standard shape.
    Returns a tuple of (error_payload, status_code) or None.
    """
    if not result:
        return json_error("Empty GraphQL response", 500)

    errors = result.get("errors") if isinstance(result, dict) else None
    if errors:
        msgs = []
        for err in errors:
            msg = err.get("message") if isinstance(err, dict) else str(err)
            if msg:
                msgs.append(msg)
        message = "; ".join(msgs) if msgs else "GraphQL execution error"
        return json_error(message, 400)

    return None
</file>

<file path="src/backend/models/user_models.py">
# JPA/src/backend/models/user_models.py

from enum import Enum

class UserProfileType(Enum):
    APPLICANT = "Applicant"
    RECRUITER = "Recruiter"

    @classmethod
    def from_str(cls, value: str):
        try:
            return cls(value.title())
        except ValueError:
            raise ValueError(f"Invalid ProfileType: {value}. Must be one of: Applicant, Recruiter")
            
def get_user_profile_types():
    return [e.value for e in UserProfileType]
</file>

<file path="src/backend/repository/application_repo.py">
from typing import Optional, Dict, Any, List
from pymongo import ReturnDocument
from ..db import applications_collection

def find_applications(q: Dict[str, Any]) -> List[dict]:
    """Finds multiple applications in the database."""
    return list(applications_collection().find(q, {"_id": 0}))

def find_application_by_id(app_id: int) -> Optional[dict]:
    """Finds a single application by its unique appId."""
    return applications_collection().find_one({"appId": int(app_id)}, {"_id": 0})

def insert_application(doc: dict) -> None:
    """Inserts a new application document into the database."""
    applications_collection().insert_one(doc)

def update_one_application(q: Dict[str, Any], set_fields: Dict[str, Any]) -> Optional[dict]:
    """Finds one application and updates it."""
    return applications_collection().find_one_and_update(
        q,
        {"$set": set_fields},
        projection={"_id": 0},
        return_document=ReturnDocument.AFTER,
    )
</file>

<file path="src/backend/repository/job_repo.py">
import re
from typing import Optional, Dict, Any, List
from pymongo import ReturnDocument
from ..db import jobs_collection, next_job_id

def to_job_output(doc: dict) -> dict:
    """Formats a job document from MongoDB for GraphQL output."""
    if not doc:
        return None
    return {
        "jobId": int(doc.get("jobId")) if doc.get("jobId") is not None else None,
        "title": doc.get("title"),
        "company": doc.get("company"),
        "location": doc.get("location"),
        "salaryRange": doc.get("salaryRange"),
        "skillsRequired": doc.get("skillsRequired"),
        "description": doc.get("description"),
        "postedAt": doc.get("postedAt"),
    }

def build_job_filter(company: Optional[str], location: Optional[str], title: Optional[str]) -> Dict[str, Any]:
    """Builds a filter query for jobs with case-insensitive regex matching."""
    q: Dict[str, Any] = {}
    if company:
        q["company"] = {"$regex": f"^{re.escape(company)}$", "$options": "i"}
    if location:
        q["location"] = {"$regex": f"^{re.escape(location)}$", "$options": "i"}
    if title:
        q["title"] = {"$regex": f".*{re.escape(title)}.*", "$options": "i"} # Partial match for title
    return q

def find_jobs(q: Dict[str, Any], skip: Optional[int], limit: Optional[int]) -> List[dict]:
    """Finds multiple jobs in the database."""
    col = jobs_collection()
    cursor = col.find(q, {"_id": 0})
    if skip is not None:
        cursor = cursor.skip(int(skip))
    if limit is not None:
        cursor = cursor.limit(int(limit))
    return list(cursor)

def find_job_by_id(job_id: int) -> Optional[dict]:
    """Finds a single job by its unique jobId."""
    return jobs_collection().find_one({"jobId": int(job_id)}, {"_id": 0})

def insert_job(doc: dict) -> None:
    """Inserts a new job document into the database."""
    jobs_collection().insert_one(doc)

def update_one_job(q: Dict[str, Any], set_fields: Dict[str, Any]) -> Optional[dict]:
    """Finds one job and updates it."""
    return jobs_collection().find_one_and_update(
        q,
        {"$set": set_fields},
        projection={"_id": 0},
        return_document=ReturnDocument.AFTER,
    )

def delete_one_job(q: Dict[str, Any]) -> int:
    """Deletes one job matching the query."""
    res = jobs_collection().delete_one(q)
    return int(res.deleted_count)
</file>

<file path="src/backend/repository/user_repo.py">
import re
from typing import Optional, Dict, Any, List
from pymongo import ReturnDocument
from ..db import users_collection, counters_collection
from ..db import get_db  # if you need raw DB access

def ensure_user_counter():
    counters = counters_collection()
    counters.update_one(
        {"_id": "UserID"},
        {"$setOnInsert": {"sequence_value": 0}},
        upsert=True,
    )

def next_user_id() -> int:
    counters = counters_collection()
    result = counters.find_one_and_update(
        {"_id": "UserID"},
        {"$inc": {"sequence_value": 1}},
        return_document=ReturnDocument.AFTER,
        upsert=True,
    )
    return int(result["sequence_value"])

def to_user_output(doc: dict) -> dict:
    if not doc:
        return None
    return {
        "UserID": int(doc.get("UserID")) if doc.get("UserID") is not None else None,
        "FirstName": doc.get("FirstName"),
        "LastName": doc.get("LastName"),
        "DateOfBirth": doc.get("DateOfBirth"),
        "ProfessionalTitle": doc.get("ProfessionalTitle"),
        "Summary": doc.get("Summary"),
    }

def name_filter_ci(first_name: Optional[str], last_name: Optional[str]) -> Dict[str, Any]:
    q: Dict[str, Any] = {}
    if first_name:
        q["FirstName"] = {"$regex": f"^{re.escape(first_name)}$", "$options": "i"}
    if last_name:
        q["LastName"] = {"$regex": f"^{re.escape(last_name)}$", "$options": "i"}
    return q

def build_filter(first_name: Optional[str], last_name: Optional[str], dob: Optional[str]) -> Dict[str, Any]:
    q = name_filter_ci(first_name, last_name)
    if dob:
        q["DateOfBirth"] = dob
    return q

def find_users(q: Dict[str, Any], skip: Optional[int], limit: Optional[int]) -> List[dict]:
    col = users_collection()
    cursor = col.find(q, {"_id": 0})
    if skip is not None:
        cursor = cursor.skip(int(skip))
    if limit is not None:
        cursor = cursor.limit(int(limit))
    return list(cursor)

def find_one_by_id(user_id: int) -> Optional[dict]:
    col = users_collection()
    return col.find_one({"UserID": int(user_id)}, {"_id": 0})

def insert_user(doc: dict) -> None:
    users_collection().insert_one(doc)

def update_one(q: Dict[str, Any], set_fields: Dict[str, Any]) -> Optional[dict]:
    col = users_collection()
    return col.find_one_and_update(
        q,
        {"$set": set_fields},
        projection={"_id": 0},
        return_document=ReturnDocument.AFTER,
    )

def update_many(q: Dict[str, Any], set_fields: Dict[str, Any]) -> int:
    res = users_collection().update_many(q, {"$set": set_fields})
    return int(res.modified_count)

def delete_one(q: Dict[str, Any]) -> int:
    res = users_collection().delete_one(q)
    return int(res.deleted_count)

def delete_many(q: Dict[str, Any]) -> int:
    res = users_collection().delete_many(q)
    return int(res.deleted_count)
</file>

<file path="src/backend/resolvers/application_resolvers.py">
from datetime import datetime
from ariadne import QueryType, MutationType, ObjectType
from ..db import next_application_id, to_application_output
from ..validators.common_validators import clean_update_input

# Import repositories for all entities, as we need them for lookups
from ..repository import user_repo, job_repo, application_repo

# Create QueryType, MutationType, and a new ObjectType for resolving linked fields
query = QueryType()
mutation = MutationType()
application = ObjectType("Application") # Binds resolver functions to the Application type in the schema

@query.field("applications")
def resolve_applications(*_, userId=None, jobId=None, status=None):
    q = {}
    if userId:
        q["userId"] = int(userId)
    if jobId:
        q["jobId"] = int(jobId)
    if status:
        q["status"] = status
    
    docs = application_repo.find_applications(q)
    return [to_application_output(d) for d in docs]

@query.field("applicationById")
def resolve_application_by_id(*_, appId):
    doc = application_repo.find_application_by_id(int(appId))
    if not doc:
        raise ValueError(f"Application with ID {appId} not found.")
    return to_application_output(doc)

# --- Field level resolvers for linked types ---
# When GraphQL asks for the 'candidate' field on an Application, this function runs
@application.field("candidate")
def resolve_application_candidate(app_obj, _):
    user_id = app_obj.get("userId")
    if not user_id:
        return None
    # Use the user_repo to fetch the user data
    user_doc = user_repo.find_one_by_id(user_id)
    return user_repo.to_user_output(user_doc)

# When GraphQL asks for the 'job' field on an Application, this function runs
@application.field("job")
def resolve_application_job(app_obj, _):
    job_id = app_obj.get("jobId")
    if not job_id:
        return None
    # Use the job_repo to fetch the job data
    job_doc = job_repo.find_job_by_id(job_id)
    return job_repo.to_job_output(job_doc)

# --- Mutations ---
@mutation.field("createApplication")
def resolve_create_application(*_, input):
    user_id = input.get("userId")
    job_id = input.get("jobId")

    # --- Validation ---
    if not user_repo.find_one_by_id(user_id):
        raise ValueError(f"Validation failed: User with ID {user_id} does not exist.")
    if not job_repo.find_job_by_id(job_id):
        raise ValueError(f"Validation failed: Job with ID {job_id} does not exist.")

    doc = {
        "appId": next_application_id(),
        "userId": user_id,
        "jobId": job_id,
        "status": "Applied",
        "submittedAt": datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'),
        "notes": input.get("notes")
    }
    application_repo.insert_application(doc)
    return to_application_output(doc)

@mutation.field("apply")
def resolve_apply(*_, userName, jobTitle, companyName=None):
    # --- New, more robust name parsing logic ---
    name_parts = userName.strip().split()
    first_name = None
    last_name = None

    if len(name_parts) == 1:
        first_name = name_parts[0]
    elif len(name_parts) > 1:
        first_name = name_parts[0]
        # Handle multi-word last names like "van der Sar"
        last_name = " ".join(name_parts[1:])

    if not first_name:
        raise ValueError("User name cannot be empty.")

    # 1. Find the user using the parsed name parts
    user_filter = user_repo.name_filter_ci(first_name, last_name)
    matching_users = user_repo.find_users(user_filter, None, None)
    
    if len(matching_users) == 0:
        raise ValueError(f"Could not find a user named '{userName}'.")
    if len(matching_users) > 1:
        raise ValueError(f"Found multiple users named '{userName}'. Please be more specific or use a last name.")
    user = matching_users[0]
    
    # 2. Find the job (this logic remains the same)
    job_filter = job_repo.build_job_filter(companyName, None, jobTitle)
    matching_jobs = job_repo.find_jobs(job_filter, None, None)

    if len(matching_jobs) == 0:
        raise ValueError(f"Could not find a job with title '{jobTitle}' at company '{companyName or ''}'.")
    if len(matching_jobs) > 1:
        raise ValueError(f"Found multiple jobs with title '{jobTitle}'. Please specify a company.")
    job = matching_jobs[0]

    # 3. Create the application using the found IDs
    application_input = {"userId": user["UserID"], "jobId": job["jobId"]}
    return resolve_create_application(None, input=application_input)


@mutation.field("updateApplication")
def resolve_update_application(*_, appId, input):
    set_fields = clean_update_input(input)
    if not set_fields:
        raise ValueError("No fields provided to update.")
        
    updated = application_repo.update_one_application({"appId": int(appId)}, set_fields)
    if not updated:
        raise ValueError(f"Application with ID {appId} not found for update.")
    return to_application_output(updated)
</file>

<file path="src/backend/resolvers/job_resolvers.py">
from datetime import datetime
from ariadne import QueryType, MutationType
from ..validators.common_validators import require_non_empty_str, clean_update_input
from ..repository.job_repo import (
    build_job_filter,
    find_jobs,
    find_job_by_id,
    insert_job,
    update_one_job,
    delete_one_job,
    to_job_output,
)
from ..db import next_job_id

# Create separate QueryType and MutationType instances
# We will combine these with the user resolvers in app.py
query = QueryType()
mutation = MutationType()

@query.field("jobs")
def resolve_jobs(*_, limit=None, skip=None, company=None, location=None, title=None):
    q = build_job_filter(company, location, title)
    docs = find_jobs(q, skip, limit)
    return [to_job_output(d) for d in docs]

@query.field("jobById")
def resolve_job_by_id(*_, jobId):
    doc = find_job_by_id(int(jobId))
    if not doc:
        raise ValueError(f"Job with ID {jobId} not found.")
    return to_job_output(doc)

@mutation.field("createJob")
def resolve_create_job(*_, input):
    title = require_non_empty_str(input.get("title"), "title")
    
    doc = {
        "jobId": next_job_id(),
        "title": title,
        "company": input.get("company"),
        "location": input.get("location"),
        "salaryRange": input.get("salaryRange"),
        "skillsRequired": input.get("skillsRequired", []),
        "description": input.get("description"),
        "postedAt": datetime.utcnow().strftime('%Y-%m-%d'),
    }
    insert_job(doc)
    return to_job_output(doc)

@mutation.field("updateJob")
def resolve_update_job(*_, jobId, input):
    if "title" in input and input["title"] is not None:
        require_non_empty_str(input["title"], "title")

    set_fields = clean_update_input(input)
    if not set_fields:
        raise ValueError("No fields provided to update.")

    updated = update_one_job({"jobId": int(jobId)}, set_fields)
    if not updated:
        raise ValueError(f"Job with ID {jobId} not found for update.")
    return to_job_output(updated)

@mutation.field("deleteJob")
def resolve_delete_job(*_, jobId):
    count = delete_one_job({"jobId": int(jobId)})
    if count == 0:
        raise ValueError(f"Job with ID {jobId} not found for deletion.")
    return True
</file>

<file path="src/backend/resolvers/user_resolvers.py">
from typing import Optional
from ariadne import QueryType, MutationType
# Corrected import for validators
from ..validators.common_validators import require_non_empty_str, validate_date_str, clean_update_input
# Corrected import for the user repository
from ..repository.user_repo import (
    next_user_id,
    to_user_output,
    build_filter,
    name_filter_ci,
    find_users,
    find_one_by_id,
    insert_user,
    update_one,
    update_many,
    delete_one,
    delete_many,
)

query = QueryType()
mutation = MutationType()

@query.field("users")
def resolve_users(*_, limit=None, skip=None, FirstName=None, LastName=None, DateOfBirth=None):
    if DateOfBirth:
        DateOfBirth = validate_date_str(DateOfBirth)
    q = build_filter(FirstName, LastName, DateOfBirth)
    docs = find_users(q, skip, limit)
    return [to_user_output(d) for d in docs]

@query.field("userById")
def resolve_user_by_id(*_, UserID):
    doc = find_one_by_id(int(UserID))
    return to_user_output(doc)

@mutation.field("createUser")
def resolve_create_user(*_, input):
    first = require_non_empty_str(input.get("FirstName"), "FirstName")
    last = require_non_empty_str(input.get("LastName"), "LastName")
    dob = validate_date_str(input.get("DateOfBirth"))
    title = (input.get("ProfessionalTitle") or None)
    summary = (input.get("Summary") or None)

    doc = {
        "UserID": next_user_id(),
        "FirstName": first,
        "LastName": last,
        "DateOfBirth": dob,
        "ProfessionalTitle": title,
        "Summary": summary,
    }
    insert_user(doc)
    return to_user_output(doc)

@mutation.field("updateUser")
def resolve_update_user(*_, UserID, input):
    if "FirstName" in input and input["FirstName"] is not None:
        require_non_empty_str(input["FirstName"], "FirstName")
    if "LastName" in input and input["LastName"] is not None:
        require_non_empty_str(input["LastName"], "LastName")
    if "DateOfBirth" in input and input["DateOfBirth"] is not None:
        input["DateOfBirth"] = validate_date_str(input["DateOfBirth"])

    set_fields = clean_update_input(input)
    if not set_fields:
        raise ValueError("No fields provided to update")

    updated = update_one({"UserID": int(UserID)}, set_fields)
    return to_user_output(updated)

@mutation.field("updateUserByName")
def resolve_update_user_by_name(*_, FirstName=None, LastName=None, input=None):
    if input and input.get("DateOfBirth") is not None:
        input["DateOfBirth"] = validate_date_str(input["DateOfBirth"])
    if input and input.get("FirstName") is not None:
        require_non_empty_str(input["FirstName"], "FirstName")
    if input and input.get("LastName") is not None:
        require_non_empty_str(input["LastName"], "LastName")

    q = name_filter_ci(FirstName, LastName)
    if not q:
        raise ValueError("Provide FirstName and/or LastName to identify the user")

    set_fields = clean_update_input(input or {})
    if not set_fields:
        raise ValueError("No fields provided to update")

    matches = find_users(q, None, None)
    if len(matches) == 0:
        raise ValueError("No user matched the provided name filter")
    if len(matches) > 1:
        raise ValueError("Multiple users matched; include both FirstName and LastName to disambiguate")

    updated = update_one(q, set_fields)
    return to_user_output(updated)

@mutation.field("updateUsersByName")
def resolve_update_users_by_name(*_, FirstName=None, LastName=None, input=None):
    if input and input.get("DateOfBirth") is not None:
        input["DateOfBirth"] = validate_date_str(input["DateOfBirth"])
    q = name_filter_ci(FirstName, LastName)
    if not q:
        raise ValueError("Provide FirstName and/or LastName to filter users")
    set_fields = clean_update_input(input or {})
    if not set_fields:
        raise ValueError("No fields provided to update")
    count = update_many(q, set_fields)
    return int(count)

@mutation.field("deleteUser")
def resolve_delete_user(*_, UserID):
    return delete_one({"UserID": int(UserID)}) == 1

@mutation.field("deleteUserByFields")
def resolve_delete_user_by_fields(*_, FirstName=None, LastName=None, DateOfBirth=None):
    if DateOfBirth:
        DateOfBirth = validate_date_str(DateOfBirth)
    q = build_filter(FirstName, LastName, DateOfBirth)
    if not q:
        raise ValueError("Provide at least one filter: FirstName, LastName, or DateOfBirth")
    matches = find_users(q, None, None)
    if len(matches) == 0:
        return False
    if len(matches) > 1:
        raise ValueError("Multiple users matched; add more filters to target a single user")
    return delete_one(q) == 1

@mutation.field("deleteUsersByFields")
def resolve_delete_users_by_fields(*_, FirstName=None, LastName=None, DateOfBirth=None):
    if DateOfBirth:
        DateOfBirth = validate_date_str(DateOfBirth)
    q = build_filter(FirstName, LastName, DateOfBirth)
    if not q:
        raise ValueError("Provide at least one filter: FirstName, LastName, or DateOfBirth")
    return int(delete_many(q))
</file>

<file path="src/backend/schema.graphql">
# schema.graphql

# --- Existing User Types ---
type User {
  UserID: Int!
  FirstName: String!
  LastName: String!
  DateOfBirth: String
  ProfessionalTitle: String
  Summary: String
}
input UserInput { # ... no changes
  FirstName: String!
  LastName: String!
  DateOfBirth: String
  ProfessionalTitle: String
  Summary: String
}
input UserUpdateInput { # ... no changes
  FirstName: String
  LastName: String
  DateOfBirth: String
  ProfessionalTitle: String
  Summary: String
}


# --- Existing Job Types ---
type Job { # ... no changes
  jobId: Int!
  title: String!
  company: String
  location: String
  salaryRange: String
  skillsRequired: [String]
  description: String
  postedAt: String
}
input JobInput { # ... no changes
  title: String!
  company: String
  location: String
  salaryRange: String
  skillsRequired: [String]
  description: String
}
input JobUpdateInput { # ... no changes
  title: String
  company: String
  location: String
  salaryRange: String
  skillsRequired: [String]
  description: String
}


# --- New Application Type ---
type Application {
  appId: Int!
  userId: Int!
  jobId: Int!
  status: String!  # e.g., "Applied", "Under Review", "Interview", "Rejected", "Offered"
  submittedAt: String!
  notes: String
  
  # --- Linked entities for richer queries ---
  candidate: User
  job: Job
}

input ApplicationInput {
  userId: Int!
  jobId: Int!
  notes: String
}

input ApplicationUpdateInput {
  status: String
  notes: String
}


# --- Updated Query Type ---
type Query {
  # ... existing User and Job queries
  users(limit: Int, skip: Int, FirstName: String, LastName: String, DateOfBirth: String): [User!]!
  userById(UserID: Int!): User
  jobs(limit: Int, skip: Int, company: String, location: String, title: String): [Job!]!
  jobById(jobId: Int!): Job

  # --- New Application queries ---
  applications(userId: Int, jobId: Int, status: String): [Application!]!
  applicationById(appId: Int!): Application
}


# --- Updated Mutation Type ---
type Mutation {
  # ... existing User and Job mutations
  createUser(input: UserInput!): User!
  updateUser(UserID: Int!, input: UserInput!): User!
  updateUserByName(FirstName: String, LastName: String, input: UserUpdateInput!): User!
  updateUsersByName(FirstName: String, LastName: String, input: UserUpdateInput!): Int!
  deleteUser(UserID: Int!): Boolean!
  deleteUserByFields(FirstName: String, LastName: String, DateOfBirth: String): Boolean!
  deleteUsersByFields(FirstName: String, LastName: String, DateOfBirth: String): Int!
  createJob(input: JobInput!): Job!
  updateJob(jobId: Int!, input: JobUpdateInput!): Job
  deleteJob(jobId: Int!): Boolean!

  # --- New Application mutations ---
  """
  Creates an application linking a user to a job.
  """
  createApplication(input: ApplicationInput!): Application!
  
  """
  Smart mutation: Applies a user to a job using names instead of IDs.
  The backend will look up the user and job IDs.
  """
  #apply(userFirstName: String!, userLastName: String, jobTitle: String!, companyName: String): Application!
  apply(userName: String!, jobTitle: String!, companyName: String): Application!
  
  """
  Updates the status or notes of an existing application.
  """
  updateApplication(appId: Int!, input: ApplicationUpdateInput!): Application
}
</file>

<file path="src/backend/validators/common_validators.py">
import re
from typing import Optional, Dict, Any

DATE_RE = re.compile(r"^\d{4}-\d{2}-\d{2}$")

def require_non_empty_str(value: Optional[str], field: str) -> str:
    if value is None or (isinstance(value, str) and value.strip() == ""):
        raise ValueError(f"{field} must be a non-empty string")
    return value.strip()

def validate_date_str(value: Optional[str]) -> Optional[str]:
    if value is None or value == "":
        return None
    if not DATE_RE.match(value):
        raise ValueError("DateOfBirth must be in YYYY-MM-DD format")
    return value

def clean_update_input(input_data: Dict[str, Any]) -> Dict[str, Any]:
    return {k: v for k, v in (input_data or {}).items() if v is not None}
</file>

<file path="src/frontend-react/.env.development">
# Frontend environment variables
REACT_APP_NL2GQL_ENDPOINT=http://localhost:8000/nl2gql
</file>

<file path="src/frontend-react/package.json">
{
  "name": "job-portal-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.6.8",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="src/frontend-react/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Job Seeker Chat</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
</file>

<file path="src/frontend-react/src/App.css">
/* --- Global Variables (Themes) --- */
:root {
    /* Light Theme Defaults */
    --background-color: #f0f2f5;
    --text-color: #1c1e21;
    --card-background: #ffffff;
    --border-color: #ccc;
    --user-bubble-bg: #dcf8c6;
    --assistant-bubble-bg: #e5e5e5;
    --input-bg: #ffffff;
    --button-bg: #1877f2;
    --button-text: #ffffff;
}

/* Dark Theme Overrides */
[data-theme='dark'] {
    --background-color: #18191a;
    --text-color: #e4e6eb;
    --card-background: #242526;
    --border-color: #3a3b3c;
    --user-bubble-bg: #324e2c; /* Darker green */
    --assistant-bubble-bg: #3a3b3c;
    --input-bg: #3a3b3c;
    --button-bg: #2d88ff;
    --button-text: #ffffff;
}

/* --- Base Layout --- */
body {
    background-color: var(--background-color);
    color: var(--text-color);
    transition: background-color 0.3s, color 0.3s;
    margin: 0;
}

.App {
    max-width: 800px;
    margin: 40px auto;
    padding: 20px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--card-background);
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* --- Header and Toggle --- */
.header-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.theme-toggle {
    background: none;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.3s, border-color 0.3s;
}

.theme-toggle:hover {
    background-color: var(--assistant-bubble-bg);
}

/* --- Message Area --- */
.message-container {
    height: 500px;
    overflow-y: auto;
    border: 1px solid var(--border-color);
    padding: 10px;
    margin-bottom: 20px;
    border-radius: 8px;
    background-color: var(--card-background); /* Explicitly set for area */
}

/* --- Chat Bubbles --- */
.message {
    display: flex;
    margin-bottom: 15px;
    flex-direction: column;
}

.user-message {
    align-items: flex-end;
}

.assistant-message {
    align-items: flex-start;
}

.message-bubble {
    padding: 12px;
    border-radius: 18px;
    max-width: 80%;
    word-wrap: break-word;
    white-space: pre-wrap;
    line-height: 1.5;
}

.user-message .message-bubble {
    background-color: var(--user-bubble-bg);
    color: var(--text-color);
}

.assistant-message .message-bubble {
    background-color: var(--assistant-bubble-bg);
    color: var(--text-color);
}

.message-bubble strong {
    font-weight: 600;
    margin-bottom: 5px;
    display: block;
}

/* --- Input Form --- */
.input-form {
    display: flex;
    gap: 10px;
}

.input-form input {
    flex-grow: 1;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    background-color: var(--input-bg);
    color: var(--text-color);
    outline: none;
}

.input-form button {
    padding: 12px 25px;
    background-color: var(--button-bg);
    color: var(--button-text);
    border: none;
    border-radius: 20px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.input-form button:hover:not(:disabled) {
    background-color: #0b5cb0; /* Slightly darker blue */
}

.input-form button:disabled {
    background-color: var(--border-color);
    cursor: not-allowed;
}

/* Style for the code blocks in assistant messages */
.message-bubble pre {
    background-color: rgba(0, 0, 0, 0.05); /* Lighter background for code in bubble */
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto;
    margin-top: 10px;
}
[data-theme='dark'] .message-bubble pre {
    background-color: rgba(255, 255, 255, 0.1);
}

.header-controls {
    display: flex;
    align-items: center;
    gap: 15px; /* Adds space between the theme button and profile icon */
}

.profile-link {
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-color); /* Makes the icon match the current text color */
}

.profile-icon {
    width: 28px;
    height: 28px;
    cursor: pointer;
    transition: opacity 0.2s;
}

.profile-link:hover .profile-icon {
    opacity: 0.7; /* Fades the icon slightly on hover */
}
</file>

<file path="src/backend/.env">
MONGO_URI=mongodb://localhost:27017/
DB_NAME=jobtracker

# Alternative: If using Ollama cloud service, uncomment and configure:
OLLAMA_HOST=https://ollama.com
OLLAMA_MODEL=gpt-oss:120b-cloud  
OLLAMA_API_KEY=2a5870ffa8ab469b879ab02999b684db.28nZHl4ZWnBXzrvzWFpiJ7DT
</file>

<file path="src/backend/services/nl2gql_service.py">
import os
import requests
import json
from dotenv import load_dotenv

env_path = os.path.join(os.path.dirname(__file__), '../../.env')
print(f"Loading .env from: {env_path}")
print(f"File exists: {os.path.exists(env_path)}")
load_dotenv(dotenv_path=env_path)

from ..errors import json_error, unwrap_graphql_errors

# Ensure these are set to the cloud values
OLLAMA_HOST = os.getenv("OLLAMA_HOST", "https://ollama.com")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gpt-oss:120b-cloud")
OLLAMA_API_KEY = os.getenv("OLLAMA_API_KEY") # Read directly from env
print(f"OLLAMA_HOST loaded as: {OLLAMA_HOST}")
print(f"OLLAMA_MODEL loaded as: {OLLAMA_MODEL}")
print(f"OLLAMA_API_KEY loaded: {'Yes' if OLLAMA_API_KEY else 'No'}")
OLLAMA_GENERATE_URL = f"{OLLAMA_HOST}/api/generate"


# --- ENHANCED FUNCTION: Small Talk Interceptor (Handles Small Talk, Vocatives, Discourse Markers, Idioms) ---
def handle_small_talk(user_text: str):
    """
    Checks for simple conversational phrases (greetings, interjections, etc.)
    and returns a predefined response to bypass the LLM.
    """
    
    # --- Category 1: Direct Matches (Small Talk & Interjections) ---
    small_talk_map = {
        # Greetings
        "hi": "Hello there! How can I assist with your job data today?",
        "hello": "Hi! I'm ready to convert your requests into GraphQL. What can I do?",
        "hey": "Hey! Let me know what data you need to query or update.",
        "greetings": "Greetings! I'm here to help with your job portal data via NL2GQL.",
        
        # Gratitude
        "thanks": "You're welcome! I'm happy to help.",
        "thank you": "My pleasure! Just ask if you have more queries.",
        
        # Interjections / Exclamations
        "wow": "Glad to impress! Do you have a query for me?",
        "cool": "I think so too! Ready for your next command.",
        "awesome": "I strive for excellence! Ready for a command.",
        "oops": "Mistakes happen! Please try your query again.",
        "sorry": "No worries at all. What is your request?",
        
        # Phatic Expressions (Conversation management)
        "how are you": "I'm a GraphQL assistant, but I'm operating perfectly! What query can I run?",
        "what's up": "Just monitoring the database for your requests. What can I do for you?",
        "how are you doing today": "I'm a GraphQL assistant, but I'm operating perfectly! What query can I run?",
    }
    
    # --- Category 2: Idioms, Common Phrases & Discourse Markers (Keyword Matching) ---
    keyword_responses = {
        "by the way": "Interesting point. Do you have a job or user query for me?",
        "i mean": "I understand. Please formulate your query clearly.",
        "just saying": "Got it. I'm waiting for a command that maps to GraphQL.",
        "you know": "I know what you mean. Focus on what data you need.",
        "hold on": "Okay, I'll hold. Let me know when you have a request.",
        "excuse me": "No problem. How can I help with the data?",
        "long time no see": "It's good to be back in the chat! Ready for a query.",
        "what the hell": "Please keep the conversation focused on data queries.",
        "what the f": "Please keep the conversation focused on data queries.",
        "can you help me": "Absolutely! I can help by converting your request into a GraphQL query.",
        "can i ask": "You can ask. I can answer if it involves querying or mutating job portal data.",
    }
    
    # Default conversational response if a simple greeting/interjection is matched
    default_response = (
        "Hello! I'm your GraphQL assistant. I can help you with job portal data. "
        "Try asking me to: \n- **Create** a user: *create a user named Jane Doe born on 1990-01-01*\n"
        "- **Find** jobs: *find jobs for Java developer in London*\n"
        "- **Apply** to a job: *apply user Raju B to Java Developer at MyCompany*"
    )
    
    # Normalize input
    clean_text = user_text.lower().strip()
    words = clean_text.split()
    
    # 1. Check for Direct Matches (Handles most greetings/interjections)
    if clean_text in small_talk_map:
        response = small_talk_map[clean_text]
        return {"graphql": "Small talk handled by service logic", "result": {"response": response}}, 200
        
    # Check for short multi-word exact match for "how are you doing today"
    if clean_text == "how are you doing today":
        return {"graphql": "Small talk handled by service logic", "result": {"response": small_talk_map["how are you doing today"]}}, 200

    # 2. Check for Keyword Matches (Handles Idioms, Discourse Markers, and multi-word Phatic)
    for key, response in keyword_responses.items():
        if key in clean_text:
            return {"graphql": "Small talk handled by service logic", "result": {"response": response}}, 200

    # 3. Check for multi-word short greetings/Vocatives
    if words:
        is_greeting = words[0] in ["hi", "hello", "hey"]
        is_vocative = "assistant" in words or "bot" in words
        
        if (is_greeting or is_vocative) and len(words) <= 5:
            # Return the default, guiding response
            return {"graphql": "Small talk handled by service logic", "result": {"response": default_response}}, 200
        
    return None

# --- END ENHANCED FUNCTION ---


def build_nl2gql_prompt(user_text: str, schema_sdl: str) -> str:
    # ... (remains the same) ...
    return (
        "You are an expert GraphQL assistant. Your task is to convert the user's natural language request "
        "into a single, valid GraphQL operation that adheres strictly to the provided schema. "
        "Return ONLY the GraphQL operation with no explanations or markdown fences.\n\n"
        "Key Instructions:\n"
        "- When the user wants to 'apply' a person to a job, ALWAYS use the `apply` mutation. It takes a single `userName` string (e.g., 'Raju boo' or 'Priya Sharma'), a `jobTitle`, and an optional `companyName`.\n"
        "- For other actions, use the appropriate query or mutation (e.g., `users`, `jobs`, `createUser`, `createJob`).\n"
        "- If the user's request cannot be mapped to any field in the schema, return the single word: INVALID.\n"
        "- Do not make up fields or assume logic not present in the schema.\n\n"
        "Schema:\n"
        f"{schema_sdl}\n\n"
        "User request:\n"
        f"{user_text}"
    )

def extract_graphql(text: str) -> str:
    # ... (remains the same) ...
    if "```" in text:
        parts = text.split("```")
        for i in range(1, len(parts), 2):
            block = parts[i]
            if block.strip().startswith("graphql"):
                lines = block.splitlines()
                return "\n".join(lines[1:]).strip() if len(lines) > 1 else ""
        for i in range(1, len(parts), 2):
            if parts[i].strip():
                return parts[i].strip()
    return text.strip()

def process_nl2gql_request(user_text: str, schema_sdl: str, run_graphql: bool, graphql_executor_fn):
    """
    Processes a natural language query, converts to GraphQL, and optionally executes it.
    This function now consistently returns a tuple: (payload_dict, status_code).
    """
    
    # --- Check for small talk first ---
    small_talk_response = handle_small_talk(user_text)
    if small_talk_response:
        return small_talk_response
    # --- END CHECK ---
    
    # Pre-check for API key before making the call
    if not OLLAMA_API_KEY:
        return json_error("NL2GQL Service Error: OLLAMA_API_KEY is missing in environment configuration.", 500)
        
    prompt = build_nl2gql_prompt(user_text, schema_sdl)

    headers = {}
    if OLLAMA_API_KEY:
        headers["Authorization"] = f"Bearer {OLLAMA_API_KEY}"

    try:
        resp = requests.post(
            OLLAMA_GENERATE_URL,
            json={"model": OLLAMA_MODEL, "prompt": prompt, "stream": False},
            headers=headers,
            timeout=90,
        )
    except requests.exceptions.Timeout:
        return json_error("Upstream NL generation timed out", 504)
    except requests.exceptions.RequestException as e:
        # This catches general network errors like DNS failure or SSL/Cert issues
        return json_error(f"Ollama network error: {e}. Check OLLAMA_HOST/URL.", 502)

    if not resp.ok:
        try:
            err_details = resp.json().get("error", resp.text)
            if resp.status_code == 401 or resp.status_code == 403:
                msg = f"LLM Authorization Failed. Check OLLAMA_API_KEY. Details: {err_details}"
            else:
                msg = f"LLM Error {resp.status_code}: {err_details}"
            
            return json_error(msg, 502)

        except (json.JSONDecodeError, ValueError):
            return json_error(f"Ollama returned non-JSON error response (Status: {resp.status_code}).", 502)

    try:
        gen_body = resp.json()
    except ValueError:
        return json_error("Ollama returned non-JSON response on success.", 502)

    gen = gen_body.get("response", "")
    gql = extract_graphql(gen)

    if not gql or gql.strip().upper() == "INVALID":
        return json_error(
            "Out of scope. Your request could not be mapped to a valid operation. Try asking about users or jobs (or be more specific).",
            400
        )

    if not run_graphql:
        return {"graphql": gql}, 200

    # Execute generated GraphQL
    success, result = graphql_executor_fn({"query": gql})
    
    # Check for GraphQL-level errors (like our ValueErrors from the resolver)
    wrapped_error = unwrap_graphql_errors(result)
    if wrapped_error:
        return wrapped_error 

    # Success case
    return {"graphql": gql, "result": result}, (200 if success else 400)
</file>

<file path="src/frontend-react/src/index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
      <BrowserRouter>  {/* Wrap App with BrowserRouter */}
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

// Note: A real setup would also need an HTML file (index.html) 
// and potentially CSS, but 'react-scripts start' handles index.html creation.
</file>

<file path="src/frontend-react/src/App.js">
// src/frontend-react/src/App.js
import React, { useState, useEffect } from 'react';
import { Routes, Route, Navigate, Link } from 'react-router-dom';
import axios from 'axios';
import './App.css';
import LoginPage from './LoginPage';

const NL2GQL_ENDPOINT = process.env.REACT_APP_NL2GQL_ENDPOINT || 'http://localhost:8000/nl2gql';

function ChatPage() {
  const navigate = useNavigate();
  const [user, setUser] = useState(null); // State to hold user data

  // --- This effect runs when the component loads ---
  useEffect(() => {
    const storedUser = sessionStorage.getItem('user');
    if (storedUser) {
      // If user data exists in session, parse and set it to state
      setUser(JSON.parse(storedUser));
    } else {
      // If no user, redirect to the login page
      navigate('/login');
    }
  }, [navigate]);

  const handleLogout = () => {
    // Clear user from session storage
    sessionStorage.removeItem('user');
    // Clear user from state
    setUser(null);
    // Redirect to login page
    navigate('/login');
  };

  // The rest of the ChatPage component state and functions
  const [messages, setMessages] = useState(/* ... */);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [theme, setTheme] = useState(() => localStorage.getItem('theme') || 'light');

  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
  }, [theme]);

  const toggleTheme = () => setTheme(prev => (prev === 'light' ? 'dark' : 'light'));
  const formatContentForDisplay = (content) => { /* ... */ };
  const handleSend = async (e) => { /* ... */ };


  // Render a loading state or nothing until the user check is complete
  if (!user) {
    return null; // or a loading spinner
  }

  return (
    <div className="App">
      <div className="header-container">
        <h1>Job Seeker Chat (React)</h1>
        <div className="header-controls">
          <span className="user-greeting">Hi, {user.firstName}!</span>
          <button onClick={toggleTheme} className="theme-toggle">
            {theme === 'light' ? 'ðŸŒ™' : 'â˜€ï¸'}
          </button>
          <button onClick={handleLogout} className="logout-button" title="Logout">
            Logout
          </button>
        </div>
      </div>

      {/* The rest of the chat UI remains the same */}
      <div className="message-container">
        {messages.map((m, index) => (
          <div key={index} className={`message ${m.role}-message`}>
            <div className="message-bubble" dangerouslySetInnerHTML={{ __html: formatContentForDisplay(m.content) }}/>
          </div>
        ))}
      </div>
      <form onSubmit={handleSend} className="input-form">
        <input type="text" value={input} onChange={(e) => setInput(e.target.value)} placeholder="Type a request..." disabled={loading}/>
        <button type="submit" disabled={loading}>{loading ? '...' : 'Send'}</button>
      </form>
    </div>
  );
}


function App() {
  return (
    <Routes>
      <Route path="/login" element={<LoginPage />} />
      <Route path="/chat" element={<ChatPage />} />
      <Route path="/" element={<Navigate to="/chat" />} />
    </Routes>
  );
}

// THIS LINE WAS MISSING
export default App;
</file>

</files>
