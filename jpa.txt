This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
README.md
requirements.txt
scripts/seed_db.py
src/backend/.env
src/backend/app.py
src/backend/db.py
src/backend/errors.py
src/backend/models/user_models.py
src/backend/repository/application_repo.py
src/backend/repository/job_repo.py
src/backend/repository/user_repo.py
src/backend/resolvers/application_resolvers.py
src/backend/resolvers/job_resolvers.py
src/backend/resolvers/user_resolvers.py
src/backend/schema.graphql
src/backend/services/nl2gql_service.py
src/backend/validators/common_validators.py
src/frontend-react/.env.development
src/frontend-react/package.json
src/frontend-react/public/index.html
src/frontend-react/src/api.js
src/frontend-react/src/App.css
src/frontend-react/src/App.js
src/frontend-react/src/index.js
src/frontend-react/src/LoginPage.css
src/frontend-react/src/LoginPage.js
src/frontend-react/src/ResultsDisplay.css
src/frontend-react/src/ResultsDisplay.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
Python specific files

pycache/
*.pyc
.pytest_cache/
.coverage

Dependency directories

venv/
node_modules/
dist/
build/

IDE files

.idea/
.vscode/
</file>

<file path="scripts/seed_db.py">
# scripts/seed_db.py
import os
import sys
import bcrypt
from datetime import datetime
from faker import Faker

# --- Setup Project Path ---
# This allows the script to import modules from the 'src' directory
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Now we can import our backend modules
from src.backend.db import get_db, next_user_id, next_job_id
from src.backend.models.user_models import UserProfileType

# Initialize Faker to generate realistic data
fake = Faker()

def seed_database():
    """
    Clears and populates the database with sample users and jobs.
    """
    print("Connecting to the database...")
    db = get_db()
    
    # --- 1. Clear Existing Data ---
    print("Clearing existing collections (users, jobs, applications)...")
    db["users"].delete_many({})
    db["jobs"].delete_many({})
    db["applications"].delete_many({})
    
    # --- 2. Create Sample Users ---
    print("Creating sample users...")
    users_to_create = [
        # --- RECRUITERS ---
        {
            "UserID": next_user_id(), "email": "recruiter@google.com", "password": "password123",
            "firstName": "Alice", "lastName": "Jones", "role": UserProfileType.RECRUITER.value,
            "professionalTitle": "Senior Technical Recruiter", "createdAt": datetime.utcnow().isoformat(),
            # All other fields are null by default
        },
        {
            "UserID": next_user_id(), "email": "hiring@figma.com", "password": "password123",
            "firstName": "Bob", "lastName": "Smith", "role": UserProfileType.RECRUITER.value,
            "professionalTitle": "Hiring Manager", "createdAt": datetime.utcnow().isoformat(),
        },
        # --- APPLICANTS ---
        {
            "UserID": next_user_id(), "email": "applicant1@email.com", "password": "password123",
            "firstName": "Charlie", "lastName": "Brown", "role": UserProfileType.APPLICANT.value,
            "professionalTitle": "Software Engineer", "years_of_experience": 5,
            "skills": ["Python", "Flask", "React", "MongoDB"], "city": "San Francisco", "country": "USA",
            "linkedin_profile": "https://linkedin.com/in/charliebrown", "createdAt": datetime.utcnow().isoformat(),
        },
        {
            "UserID": next_user_id(), "email": "applicant2@email.com", "password": "password123",
            "firstName": "Diana", "lastName": "Prince", "role": UserProfileType.APPLICANT.value,
            "professionalTitle": "Product Manager", "years_of_experience": 8,
            "skills": ["Agile", "Product Strategy", "AI"], "city": "New York", "country": "USA",
            "linkedin_profile": "https://linkedin.com/in/dianaprince", "createdAt": datetime.utcnow().isoformat(),
        },
        {
            "UserID": next_user_id(), "email": "applicant3@email.com", "password": "password123",
            "firstName": "Ethan", "lastName": "Hunt", "role": UserProfileType.APPLICANT.value,
            "professionalTitle": "Data Scientist", "years_of_experience": 4,
            "skills": ["SQL", "Python", "Machine Learning", "PyTorch"], "city": "London", "country": "UK",
             "linkedin_profile": "https://linkedin.com/in/ethanhunt", "createdAt": datetime.utcnow().isoformat(),
        },
    ]

    for user_data in users_to_create:
        # Securely hash the password before insertion
        password = user_data.pop("password").encode('utf-8')
        user_data["password"] = bcrypt.hashpw(password, bcrypt.gensalt())
        
        # Initialize remaining fields to None if they don't exist
        user_model_fields = [
            "phone_number", "city", "state_province", "country", "linkedin_profile",
            "portfolio_url", "highest_qualification", "years_of_experience",
            "dob", "skills", "professionalTitle"
        ]
        for field in user_model_fields:
            if field not in user_data:
                user_data[field] = None
        
        db["users"].insert_one(user_data)
    print(f"  -> Successfully created {len(users_to_create)} users.")

    # --- 3. Create Sample Jobs ---
    print("Creating sample jobs...")
    jobs_to_create = [
        {
            "jobId": next_job_id(), "title": "Senior Python Developer", "company": "Google",
            "location": "Mountain View, CA", "skillsRequired": ["Python", "Django", "AWS", "Kubernetes"],
            "description": "Seeking an experienced backend developer to join our cloud infrastructure team.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
        {
            "jobId": next_job_id(), "title": "Senior UI/UX Designer", "company": "Figma",
            "location": "San Francisco, CA", "skillsRequired": ["Figma", "Prototyping", "User Research"],
            "description": "Design the future of collaborative tools with a world-class team.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
        {
            "jobId": next_job_id(), "title": "Product Manager, AI", "company": "Microsoft",
            "location": "Redmond, WA", "skillsRequired": ["Product Strategy", "Agile", "AI", "Machine Learning"],
            "description": "Lead the development of our next-generation AI Copilot features.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
        {
            "jobId": next_job_id(), "title": "Data Scientist", "company": "Netflix",
            "location": "Los Gatos, CA", "skillsRequired": ["SQL", "Python", "Machine Learning", "Statistics"],
            "description": "Analyze viewer data to drive content strategy and personalization algorithms.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
        {
            "jobId": next_job_id(), "title": "Frontend Engineer (React)", "company": "Vercel",
            "location": "Remote", "skillsRequired": ["React", "Next.js", "TypeScript", "CSS-in-JS"],
            "description": "Build beautiful and performant web experiences for a global audience.",
            "postedAt": datetime.utcnow().strftime('%Y-%m-%d')
        },
    ]
    db["jobs"].insert_many(jobs_to_create)
    print(f"  -> Successfully created {len(jobs_to_create)} jobs.")

    print("\n--- Seeding Complete! ---")
    print("You can now log in with the following test accounts:")
    print("  Recruiters:")
    print("    - Email: recruiter@google.com (Password: password123)")
    print("    - Email: hiring@figma.com (Password: password123)")
    print("  Applicants:")
    print("    - Email: applicant1@email.com (Password: password123)")
    print("    - Email: applicant2@email.com (Password: password123)")
    print("    - Email: applicant3@email.com (Password: password123)")
    print("-------------------------")

if __name__ == "__main__":
    seed_database()
</file>

<file path="src/backend/db.py">
# db.py
import os
from datetime import datetime
from dotenv import load_dotenv
from pymongo import MongoClient, ReturnDocument

# ... (no changes to MONGO_URI, DB_NAME, _client, _db, get_db)
load_dotenv(os.path.join(os.path.dirname(__file__), '../../config/.env'))
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017/")
DB_NAME = os.getenv("DB_NAME", "jobtracker")
_client = MongoClient(MONGO_URI)
_db = _client[DB_NAME]
def get_db():
    return _db


# --- Collection Helpers ---
def users_collection():
    return _db["users"]

def jobs_collection():
    return _db["jobs"]

def applications_collection(): # New
    return _db["applications"]

def counters_collection():
    return _db["counters"]


# --- Counters (User, Job, and new Application counter) ---
def _ensure_counter(counter_id: str):
    counters_collection().update_one(
        {"_id": counter_id},
        {"$setOnInsert": {"sequence_value": 0}},
        upsert=True,
    )

def _next_id(counter_id: str):
    result = counters_collection().find_one_and_update(
        {"_id": counter_id},
        {"$inc": {"sequence_value": 1}},
        return_document=ReturnDocument.AFTER,
        upsert=True,
    )
    return int(result["sequence_value"])

def ensure_user_counter():
    _ensure_counter("UserID")

def next_user_id():
    return _next_id("UserID")

def ensure_job_counter():
    _ensure_counter("jobId")

def next_job_id():
    return _next_id("jobId")

def ensure_application_counter(): # New
    _ensure_counter("appId")

def next_application_id(): # New
    return _next_id("appId")


# --- Output Formatting (no changes to user/job, new for application) ---
def to_user_output(doc: dict): # ... no changes
    if not doc:
        return None
    return {
        "UserID": int(doc.get("UserID")) if doc.get("UserID") is not None else None,
        "FirstName": doc.get("FirstName"),
        "LastName": doc.get("LastName"),
        "DateOfBirth": doc.get("DateOfBirth"),
        "ProfessionalTitle": doc.get("ProfessionalTitle"),
        "Summary": doc.get("Summary"),
    }

def to_job_output(doc: dict): # ... no changes
    if not doc:
        return None
    return {
        "jobId": int(doc.get("jobId")) if doc.get("jobId") is not None else None,
        "title": doc.get("title"),
        "company": doc.get("company"),
        "location": doc.get("location"),
        "salaryRange": doc.get("salaryRange"),
        "skillsRequired": doc.get("skillsRequired"),
        "description": doc.get("description"),
        "postedAt": doc.get("postedAt"),
    }

def to_application_output(doc: dict): # New
    if not doc:
        return None
    return {
        "appId": int(doc.get("appId")) if doc.get("appId") is not None else None,
        "userId": int(doc.get("userId")) if doc.get("userId") is not None else None,
        "jobId": int(doc.get("jobId")) if doc.get("jobId") is not None else None,
        "status": doc.get("status"),
        "submittedAt": doc.get("submittedAt"),
        "notes": doc.get("notes"),
    }
</file>

<file path="src/backend/errors.py">
from flask import jsonify
from werkzeug.exceptions import HTTPException

def json_error(message: str, status: int):
    """Creates a standard JSON error payload and returns it as a tuple."""
    error_payload = {"error": {"message": message, "status": status}}
    # In this new version, we return the payload and status,
    # letting the final route handler call jsonify.
    return error_payload, status

def handle_http_exception(e: HTTPException):
    message = getattr(e, "description", None) or getattr(e, "name", "HTTP Error")
    status = getattr(e, "code", None) or 500
    # Create the JSON response directly here for Flask's error handler
    payload, status_code = json_error(message, status)
    return jsonify(payload), status_code

def handle_value_error(e: ValueError):
    # Create the JSON response directly here for Flask's error handler
    payload, status_code = json_error(str(e), 400)
    return jsonify(payload), status_code

def handle_generic_exception(e: Exception):
    # Create the JSON response directly here for Flask's error handler
    payload, status_code = json_error("Internal server error", 500)
    return jsonify(payload), status_code

def unwrap_graphql_errors(result: dict):
    """
    Normalizes GraphQL error payloads into our standard shape.
    Returns a tuple of (error_payload, status_code) or None.
    """
    if not result:
        return json_error("Empty GraphQL response", 500)

    errors = result.get("errors") if isinstance(result, dict) else None
    if errors:
        msgs = []
        for err in errors:
            msg = err.get("message") if isinstance(err, dict) else str(err)
            if msg:
                msgs.append(msg)
        message = "; ".join(msgs) if msgs else "GraphQL execution error"
        return json_error(message, 400)

    return None
</file>

<file path="src/backend/models/user_models.py">
# JPA/src/backend/models/user_models.py

from enum import Enum

class UserProfileType(Enum):
    APPLICANT = "Applicant"
    RECRUITER = "Recruiter"

    @classmethod
    def from_str(cls, value: str):
        try:
            return cls(value.title())
        except ValueError:
            raise ValueError(f"Invalid ProfileType: {value}. Must be one of: Applicant, Recruiter")
            
def get_user_profile_types():
    return [e.value for e in UserProfileType]
</file>

<file path="src/backend/validators/common_validators.py">
import re
from typing import Optional, Dict, Any

DATE_RE = re.compile(r"^\d{4}-\d{2}-\d{2}$")

def require_non_empty_str(value: Optional[str], field: str) -> str:
    if value is None or (isinstance(value, str) and value.strip() == ""):
        raise ValueError(f"{field} must be a non-empty string")
    return value.strip()

def validate_date_str(value: Optional[str]) -> Optional[str]:
    if value is None or value == "":
        return None
    if not DATE_RE.match(value):
        raise ValueError("DateOfBirth must be in YYYY-MM-DD format")
    return value

def clean_update_input(input_data: Dict[str, Any]) -> Dict[str, Any]:
    return {k: v for k, v in (input_data or {}).items() if v is not None}
</file>

<file path="src/frontend-react/.env.development">
# Frontend environment variables
REACT_APP_NL2GQL_ENDPOINT=http://localhost:8000/nl2gql
</file>

<file path="src/frontend-react/package.json">
{
  "name": "job-portal-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.6.8",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="src/frontend-react/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Job Seeker Chat</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
</file>

<file path="src/frontend-react/src/api.js">
// src/frontend-react/src/api.js
import axios from 'axios';

const API_ENDPOINT = process.env.REACT_APP_API_ENDPOINT || 'http://localhost:8000';

// Create an axios instance
const apiClient = axios.create({
  baseURL: API_ENDPOINT,
});

// Use an interceptor to dynamically add the user's role to every request
apiClient.interceptors.request.use(config => {
  try {
    const sessionJSON = localStorage.getItem('session');
    if (sessionJSON) {
      const session = JSON.parse(sessionJSON);
      const userRole = session.user?.role;
      
      if (userRole) {
        // Add the role to a custom header for our GraphQL endpoint
        config.headers['X-User-Role'] = userRole;
      }
    }
  } catch (e) {
    console.error("Could not parse session data for API interceptor", e);
  }
  return config;
}, error => {
  return Promise.reject(error);
});

export default apiClient;
</file>

<file path="src/frontend-react/src/LoginPage.css">
/* src/frontend-react/src/App.css */

/* --- Add these styles to the end of the file --- */

.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background-color: var(--background-color);
}

.login-form {
  padding: 40px;
  background-color: var(--card-background);
  border-radius: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  width: 100%;
  max-width: 400px;
  text-align: center;
}

.login-form h2 {
  margin-bottom: 25px;
  color: var(--text-color);
}

.input-group {
  margin-bottom: 20px;
  text-align: left;
}

.input-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: 600;
  color: var(--text-color);
}

.input-group input {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--border-color);
  border-radius: 5px;
  background-color: var(--input-bg);
  color: var(--text-color);
  box-sizing: border-box; /* Ensures padding doesn't affect width */
}

.login-button {
  width: 100%;
  padding: 12px;
  background-color: var(--button-bg);
  color: var(--button-text);
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  transition: background-color 0.2s;
}

.login-button:hover {
  background-color: #0b5cb0;
}

.toggle-form {
  margin-top: 20px;
  font-size: 14px;
}

.toggle-button {
  background: none;
  border: none;
  color: var(--button-bg);
  cursor: pointer;
  font-weight: bold;
  padding: 0 5px;
  font-size: 14px;
}

.input-group select {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--border-color);
  border-radius: 5px;
  background-color: var(--input-bg);
  color: var(--text-color);
  box-sizing: border-box;
  font-size: 16px; /* Match input font-size */
  font-family: inherit; /* Inherit font from parent */
  -webkit-appearance: none; /* Removes default browser styling on Safari/Chrome */
  -moz-appearance: none; /* Removes default browser styling on Firefox */
  appearance: none;
  background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23666%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
  background-repeat: no-repeat;
  background-position: right 1rem center;
  background-size: 0.65em auto;
}
</file>

<file path="README.md">
# JobChat.AI - Conversational Job Portal

**JobChat.AI** is a modern web application that redefines how users interact with a job portal.  
It features a **conversational AI interface** allowing users to find jobs, manage applications, and query user data using plain English.  
The backend service translates natural language into **GraphQL** queries, offering a seamless and intuitive user experience.

---

## üöÄ Key Features

- **Conversational AI Interface**  
  A React-based chat UI where users can type requests like  
  _"show me all python jobs in San Francisco"_ or _"create a user named Jane Doe"_.

- **NL2GQL Service**  
  A powerful backend service that uses an LLM (Large Language Model) to translate natural language into executable GraphQL queries in real time.

- **Secure User Authentication**  
  Full registration and login system with REST endpoints. Passwords are securely hashed using `bcrypt`.

- **Rich Frontend Experience**  
  A responsive single-page application built with React, featuring:
  - Client-side routing with React Router (`/login`, `/chat`)
  - Session management to keep users logged in
  - Clean, formatted results display for database queries
  - Collapsible view to inspect raw GraphQL and JSON data
  - Dark/Light mode theme toggle

- **Robust Backend (Python + Flask)**  
  - GraphQL API for structured data access (`/graphql`)
  - REST endpoints for authentication (`/login`, `/register`)
  - Dedicated endpoint for the NL2GQL service (`/nl2gql`)

---

## üß† Tech Stack

### Backend
- **Framework:** Python, Flask  
- **API:** Ariadne (GraphQL), REST  
- **Database:** MongoDB (via PyMongo)  
- **Security:** bcrypt  
- **AI Service:** Ollama (or any compatible LLM endpoint)

### Frontend
- **Library:** React  
- **Routing:** React Router (`react-router-dom`)  
- **HTTP Client:** Axios  
- **Styling:** Plain CSS with theme variables  

---

## üìÅ Repository Layout

| Path | Description |
|------|--------------|
| `src/backend/app.py` | Main Flask app with REST and GraphQL endpoints |
| `src/backend/schema.graphql` | Defines the GraphQL schema |
| `src/backend/services/nl2gql_service.py` | Translates natural language ‚Üí GraphQL |
| `src/backend/repository/` | Data access layer for MongoDB collections (`accounts`, `jobs`, etc.) |
| `src/backend/resolvers/` | Business logic for the GraphQL API |
| `src/frontend-react/src/App.js` | Main React component with routing |
| `src/frontend-react/src/LoginPage.js` | Login and registration form |
| `src/frontend-react/src/ResultsDisplay.js` | Renders formatted query results in chat |

---

## ‚öôÔ∏è Prerequisites

- **Python 3.10+** and `pip`  
- **Node.js v16+** and `npm`  
- **MongoDB** (running instance)  
- **(Optional)** Git for cloning the repository  

---

## üß© Setup Instructions

### 1Ô∏è‚É£ Clone the Repository
```bash
git clone <your-repository-url>
cd <repository-folder>


2Ô∏è‚É£ Backend Setup
Create Virtual Environment
# For Unix/macOS
python3 -m venv .venv
source .venv/bin/activate

# For Windows
python -m venv .venv
.\.venv\Scripts\Activate.ps1

Install Dependencies
pip install -r requirements.txt

Configure Environment Variables

Create a file at src/backend/.env with the following:

# src/backend/.env

# MongoDB connection string
MONGO_URI=mongodb://localhost:2717/
DB_NAME=jobtracker

# LLM service endpoint and credentials
OLLAMA_HOST=https://ollama.com
OLLAMA_MODEL=your-chosen-model
OLLAMA_API_KEY=your-api-key

3Ô∏è‚É£ Frontend Setup

Navigate to the React app directory:

cd src/frontend-react


Install Node.js dependencies:

npm install


üí° If any dependencies are missing, check package.json and re-run npm install.

‚ñ∂Ô∏è Running the Application

You must have both backend and frontend servers running.

Start the Backend
python src/backend/app.py


Server will run at http://localhost:8000

Start the Frontend
cd src/frontend-react
npm start


The React app will open at http://localhost:3000

You‚Äôll be redirected to the chat page after login or sign-up.

ü§ù Contributing

Fork the repository

Create a feature branch (git checkout -b feature-name)

Add tests for new features or bug fixes

Submit a pull request with a clear description

üìú License & Author

This project is maintained by RJBOGA
Licensed under the MIT License
</file>

<file path="src/backend/.env">
MONGO_URI=mongodb://localhost:27017/
DB_NAME=jobtracker

# Alternative: If using Ollama cloud service, uncomment and configure:
OLLAMA_HOST=https://ollama.com
OLLAMA_MODEL=gpt-oss:120b-cloud  
OLLAMA_API_KEY=2a5870ffa8ab469b879ab02999b684db.28nZHl4ZWnBXzrvzWFpiJ7DT
</file>

<file path="src/backend/repository/application_repo.py">
from typing import Optional, Dict, Any, List
from pymongo import ReturnDocument
from ..db import applications_collection

def find_applications(q: Dict[str, Any]) -> List[dict]:
    """Finds multiple applications in the database."""
    return list(applications_collection().find(q, {"_id": 0}))

def find_application_by_id(app_id: int) -> Optional[dict]:
    """Finds a single application by its unique appId."""
    return applications_collection().find_one({"appId": int(app_id)}, {"_id": 0})

def insert_application(doc: dict) -> None:
    """Inserts a new application document into the database."""
    applications_collection().insert_one(doc)

def update_one_application(q: Dict[str, Any], set_fields: Dict[str, Any]) -> Optional[dict]:
    """Finds one application and updates it."""
    return applications_collection().find_one_and_update(
        q,
        {"$set": set_fields},
        projection={"_id": 0},
        return_document=ReturnDocument.AFTER,
    )

def count_applications(query: Dict[str, Any]) -> int:
    """Counts the number of documents in the applications collection matching a query."""
    return applications_collection().count_documents(query)
</file>

<file path="src/backend/repository/job_repo.py">
# src/backend/repository/job_repo.py
import re
from typing import Optional, Dict, Any, List # Added 'List' here
from pymongo import ReturnDocument
from ..db import jobs_collection

def to_job_output(doc: dict) -> dict:
    if not doc: return None
    return {
        "jobId": int(doc.get("jobId")) if doc.get("jobId") is not None else None,
        "title": doc.get("title"), "company": doc.get("company"), "location": doc.get("location"),
        "salaryRange": doc.get("salaryRange"), "skillsRequired": doc.get("skillsRequired"),
        "description": doc.get("description"), "postedAt": doc.get("postedAt"),
    }

def build_job_filter(company: Optional[str], location: Optional[str], title: Optional[str]) -> Dict[str, Any]:
    q: Dict[str, Any] = {}
    if company: q["company"] = {"$regex": f"^{re.escape(company)}$", "$options": "i"}
    if location: q["location"] = {"$regex": f"^{re.escape(location)}$", "$options": "i"}
    if title: q["title"] = {"$regex": f".*{re.escape(title)}.*", "$options": "i"}
    return q

def find_jobs(q: Dict[str, Any], skip: Optional[int], limit: Optional[int]) -> List[dict]:
    cursor = jobs_collection().find(q, {"_id": 0})
    if skip is not None: cursor = cursor.skip(int(skip))
    if limit is not None: cursor = cursor.limit(int(limit))
    return list(cursor)

def find_job_by_id(job_id: int) -> Optional[dict]:
    return jobs_collection().find_one({"jobId": int(job_id)}, {"_id": 0})

def insert_job(doc: dict) -> None:
    jobs_collection().insert_one(doc)

def update_one_job(q: Dict[str, Any], set_fields: Dict[str, Any]) -> Optional[dict]:
    return jobs_collection().find_one_and_update(
        q, {"$set": set_fields}, projection={"_id": 0}, return_document=ReturnDocument.AFTER
    )

def delete_one_job(q: Dict[str, Any]) -> int:
    res = jobs_collection().delete_one(q)
    return int(res.deleted_count)

def add_skills_to_job(job_id: int, skills: List[str]) -> Optional[dict]:
    return jobs_collection().find_one_and_update(
        {"jobId": int(job_id)},
        {"$addToSet": {"skillsRequired": {"$each": skills}}},
        projection={"_id": 0},
        return_document=ReturnDocument.AFTER,
    )
</file>

<file path="src/backend/repository/user_repo.py">
# src/backend/repository/user_repo.py
import re
from typing import Optional, Dict, Any, List
from pymongo import ReturnDocument
from ..db import users_collection

def find_user_by_email(email: str) -> Optional[dict]:
    """Finds a single user by their email (case-insensitive)."""
    return users_collection().find_one({"email": {"$regex": f"^{email}$", "$options": "i"}})

def to_user_output(doc: dict) -> Optional[dict]:
    """Formats a user document from MongoDB for API output, excluding sensitive fields."""
    if not doc:
        return None
    
    return {
        "UserID": doc.get("UserID"),
        "email": doc.get("email"),
        "firstName": doc.get("firstName"),
        "lastName": doc.get("lastName"),
        "role": doc.get("role"),
        "phone_number": doc.get("phone_number"),
        "city": doc.get("city"),
        "state_province": doc.get("state_province"),
        "country": doc.get("country"),
        "linkedin_profile": doc.get("linkedin_profile"),
        "portfolio_url": doc.get("portfolio_url"),
        "highest_qualification": doc.get("highest_qualification"),
        "years_of_experience": doc.get("years_of_experience"),
        "createdAt": doc.get("createdAt"),
        "dob": doc.get("dob"),
        "skills": doc.get("skills"),
        "professionalTitle": doc.get("professionalTitle")
    }

def build_filter(first_name: Optional[str], last_name: Optional[str], dob: Optional[str], skills: Optional[List[str]] = None) -> Dict[str, Any]:
    """Builds a filter query, now including support for skills."""
    q = {}
    if first_name:
        q["firstName"] = {"$regex": f"^{re.escape(first_name)}$", "$options": "i"}
    if last_name:
        q["lastName"] = {"$regex": f"^{re.escape(last_name)}$", "$options": "i"}
    if dob:
        q["dob"] = dob
    if skills:
        q["skills"] = {"$all": skills}
    return q

def find_users(q: Dict[str, Any], skip: Optional[int], limit: Optional[int]) -> List[dict]:
    """Finds multiple users, excluding the password field."""
    cursor = users_collection().find(q, {"_id": 0, "password": 0})
    if skip is not None:
        cursor = cursor.skip(int(skip))
    if limit is not None:
        cursor = cursor.limit(int(limit))
    return list(cursor)

def find_one_by_id(user_id: int) -> Optional[dict]:
    """Finds a single user by ID, excluding the password field."""
    return users_collection().find_one({"UserID": int(user_id)}, {"_id": 0, "password": 0})

def insert_user(doc: dict) -> None:
    """Inserts a new user document."""
    users_collection().insert_one(doc)

def update_one(q: Dict[str, Any], set_fields: Dict[str, Any]) -> Optional[dict]:
    """Finds and updates one user, returning the updated document."""
    return users_collection().find_one_and_update(
        q,
        {"$set": set_fields},
        projection={"_id": 0, "password": 0},
        return_document=ReturnDocument.AFTER,
    )

def delete_one(q: Dict[str, Any]) -> int:
    """Deletes one user matching the query."""
    res = users_collection().delete_one(q)
    return int(res.deleted_count)
</file>

<file path="src/backend/resolvers/job_resolvers.py">
# src/backend/resolvers/job_resolvers.py
from datetime import datetime
from ariadne import QueryType, MutationType
from ..validators.common_validators import require_non_empty_str, clean_update_input
from ..repository.job_repo import (
    build_job_filter,
    find_jobs,
    find_job_by_id,
    insert_job,
    update_one_job,
    delete_one_job,
    to_job_output,
    add_skills_to_job,
)
from ..db import next_job_id

query = QueryType()
mutation = MutationType()

# --- READ Operations (Publicly Accessible) ---

@query.field("jobs")
def resolve_jobs(obj, info, limit=None, skip=None, company=None, location=None, title=None):
    # No authorization check needed here. Anyone can search for jobs.
    q = build_job_filter(company, location, title)
    docs = find_jobs(q, skip, limit)
    return [to_job_output(d) for d in docs]

@query.field("jobById")
def resolve_job_by_id(obj, info, jobId):
    # No authorization check needed here. Anyone can view a specific job.
    doc = find_job_by_id(int(jobId))
    if not doc:
        raise ValueError(f"Job with ID {jobId} not found.")
    return to_job_output(doc)

# --- MUTATION Operations (Protected for Recruiters) ---

@mutation.field("createJob")
def resolve_create_job(obj, info, input):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to post a job.")

    title = require_non_empty_str(input.get("title"), "title")
    
    doc = {
        "jobId": next_job_id(),
        "title": title,
        "company": input.get("company"),
        "location": input.get("location"),
        "salaryRange": input.get("salaryRange"),
        "skillsRequired": input.get("skillsRequired", []),
        "description": input.get("description"),
        "postedAt": datetime.utcnow().strftime('%Y-%m-%d'),
    }
    insert_job(doc)
    return to_job_output(doc)

@mutation.field("updateJob")
def resolve_update_job(obj, info, jobId, input):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to update a job.")

    if "title" in input and input["title"] is not None:
        require_non_empty_str(input["title"], "title")

    set_fields = clean_update_input(input)
    if not set_fields:
        raise ValueError("No fields provided to update.")

    updated = update_one_job({"jobId": int(jobId)}, set_fields)
    if not updated:
        raise ValueError(f"Job with ID {jobId} not found for update.")
    return to_job_output(updated)

@mutation.field("deleteJob")
def resolve_delete_job(obj, info, jobId):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to delete a job.")

    count = delete_one_job({"jobId": int(jobId)})
    if count == 0:
        raise ValueError(f"Job with ID {jobId} not found for deletion.")
    return True

@mutation.field("addSkillsToJob")
def resolve_add_skills_to_job(obj, info, jobId, skills):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to modify a job.")

    if not skills:
        raise ValueError("The 'skills' list cannot be empty.")

    # Call our new repository function
    updated_job = add_skills_to_job(jobId, skills)
    
    if not updated_job:
        raise ValueError(f"Job with ID {jobId} not found.")
        
    return to_job_output(updated_job)

@mutation.field("deleteJobByFields")
def resolve_delete_job_by_fields(obj, info, title, company=None):
    # --- AUTHORIZATION CHECK ---
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to delete a job.")

    # Build a filter to find the job(s)
    q = build_job_filter(company, None, title)
    
    # --- SAFETY CHECK ---
    # Before deleting, find how many jobs match the criteria.
    matching_jobs = find_jobs(q, None, None)
    
    if len(matching_jobs) == 0:
        raise ValueError(f"No job found with title '{title}' at company '{company or ''}'.")
    if len(matching_jobs) > 1:
        raise ValueError("Multiple jobs matched this criteria. Please be more specific or use a Job ID.")
        
    # If exactly one job matches, proceed with deletion
    count = delete_one_job(q)
    return count == 1
</file>

<file path="src/backend/resolvers/user_resolvers.py">
# src/backend/resolvers/user_resolvers.py
from ariadne import QueryType, MutationType
from datetime import datetime
from ..validators.common_validators import require_non_empty_str, validate_date_str, clean_update_input
from ..repository import user_repo
from ..db import next_user_id

query = QueryType()
mutation = MutationType()

@query.field("users")
def resolve_users(*_, limit=None, skip=None, firstName=None, lastName=None, dob=None, skills=None):
    if dob:
        dob = validate_date_str(dob)
    # Pass all arguments to the filter builder
    q = user_repo.build_filter(firstName, lastName, dob, skills)
    docs = user_repo.find_users(q, skip, limit)
    return [user_repo.to_user_output(d) for d in docs]

@query.field("userById")
def resolve_user_by_id(*_, UserID):
    doc = user_repo.find_one_by_id(int(UserID))
    return user_repo.to_user_output(doc)

@mutation.field("createUser")
def resolve_create_user(*_, input):
    email = require_non_empty_str(input.get("email"), "email")
    if user_repo.find_user_by_email(email):
        raise ValueError(f"A user with the email '{email}' already exists.")

    doc = {
        "UserID": next_user_id(), "email": email.lower(), "password": None,
        "firstName": require_non_empty_str(input.get("firstName"), "firstName"),
        "lastName": require_non_empty_str(input.get("lastName"), "lastName"),
        "role": require_non_empty_str(input.get("role"), "role"),
        "createdAt": datetime.utcnow().isoformat(), "phone_number": input.get("phone_number"),
        "city": input.get("city"), "state_province": input.get("state_province"),
        "country": input.get("country"), "linkedin_profile": input.get("linkedin_profile"),
        "portfolio_url": input.get("portfolio_url"), "highest_qualification": input.get("highest_qualification"),
        "years_of_experience": input.get("years_of_experience"), "dob": validate_date_str(input.get("dob")),
        "skills": input.get("skills", []), "professionalTitle": input.get("professionalTitle")
    }
    user_repo.insert_user(doc)
    return user_repo.to_user_output(doc)

@mutation.field("updateUser")
def resolve_update_user(*_, UserID, input):
    if "dob" in input and input.get("dob") is not None: input["dob"] = validate_date_str(input["dob"])
    if "firstName" in input and input.get("firstName") is not None: require_non_empty_str(input["firstName"], "firstName")
    if "lastName" in input and input.get("lastName") is not None: require_non_empty_str(input["lastName"], "lastName")
    
    set_fields = clean_update_input(input)
    if not set_fields: raise ValueError("No fields provided to update")
    
    updated = user_repo.update_one({"UserID": int(UserID)}, set_fields)
    if not updated: raise ValueError(f"User with ID {UserID} not found for update.")
    return user_repo.to_user_output(updated)

@mutation.field("updateUserByName")
def resolve_update_user_by_name(*_, firstName=None, lastName=None, input=None):
    if input and input.get("dob") is not None: input["dob"] = validate_date_str(input["dob"])
    
    q = user_repo.build_filter(firstName, lastName, None)
    if not q: raise ValueError("Provide firstName and/or lastName to identify the user")
    
    set_fields = clean_update_input(input or {})
    if not set_fields: raise ValueError("No fields provided to update")

    matches = user_repo.find_users(q, None, None)
    if len(matches) == 0: raise ValueError("No user matched the provided name filter")
    if len(matches) > 1: raise ValueError("Multiple users matched; please be more specific to target a single user")

    target_user_id = matches[0]["UserID"]
    updated = user_repo.update_one({"UserID": target_user_id}, set_fields)
    return user_repo.to_user_output(updated)

@mutation.field("deleteUser")
def resolve_delete_user(*_, UserID):
    return user_repo.delete_one({"UserID": int(UserID)}) == 1

@mutation.field("deleteUserByFields")
def resolve_delete_user_by_fields(*_, firstName=None, lastName=None, dob=None):
    if dob: dob = validate_date_str(dob)
    q = user_repo.build_filter(firstName, lastName, dob)
    if not q: raise ValueError("Provide at least one filter: firstName, lastName, or dob")
    
    matches = user_repo.find_users(q, None, None)
    if len(matches) == 0: return False
    if len(matches) > 1: raise ValueError("Multiple users matched; add more filters to target a single user")
    
    return user_repo.delete_one(q) == 1
</file>

<file path="src/frontend-react/src/index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
      <BrowserRouter>  {/* Wrap App with BrowserRouter */}
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

// Note: A real setup would also need an HTML file (index.html) 
// and potentially CSS, but 'react-scripts start' handles index.html creation.
</file>

<file path="src/frontend-react/src/ResultsDisplay.css">
/* src/frontend-react/src/ResultsDisplay.css */
.results-display {
    padding: 15px;
    border-radius: 18px;
    background-color: var(--assistant-bubble-bg);
    color: var(--text-color);
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
}

.results-summary {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.result-item {
    background-color: var(--card-background);
    padding: 15px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
}

.item-title {
    font-weight: bold;
    font-size: 1.1em;
    color: var(--button-bg);
}

[data-theme='dark'] .item-title {
    color: #61dafb;
}

.item-location {
    font-size: 0.9em;
    color: #666;
}
[data-theme='dark'] .item-location {
    color: #aaa;
}

.item-company {
    margin-bottom: 10px;
    font-style: italic;
}

.item-skills {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 10px;
}

.skill-tag {
    background-color: var(--assistant-bubble-bg);
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.8em;
}

.details-toggle {
    margin-top: 15px;
    text-align: center;
}

.details-toggle button {
    background: none;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 6px 12px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 0.9em;
    font-weight: 500;
}

.details-toggle button:hover {
    background-color: var(--border-color);
}

.raw-details {
    margin-top: 15px;
    border-top: 1px solid var(--border-color);
    padding-top: 10px;
}

.raw-details strong {
    display: block;
    margin-bottom: 5px;
}

.raw-details pre {
    background-color: rgba(0, 0, 0, 0.05);
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto;
    margin-top: 5px;
    white-space: pre-wrap;
}

[data-theme='dark'] .raw-details pre {
    background-color: rgba(255, 255, 255, 0.1);
}

.job-applicant-container {
    background-color: var(--background-color);
}

.container-title {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.2em;
    color: var(--text-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
}

.status-update-info {
    line-height: 1.6;
    font-size: 1.05em;
}

.application-count-result {
    font-size: 1.1em;
    font-weight: 500;
    text-align: center;
}
</file>

<file path="requirements.txt">
# requirements.txt
Flask
ariadne
pymongo
python-dotenv
requests
streamlit
bcrypt
Faker
</file>

<file path="src/backend/resolvers/application_resolvers.py">
# src/backend/resolvers/application_resolvers.py
from datetime import datetime
from ariadne import QueryType, MutationType, ObjectType
from ..db import next_application_id, to_application_output
from ..validators.common_validators import clean_update_input
from ..repository import user_repo, job_repo, application_repo

query = QueryType()
mutation = MutationType()
application = ObjectType("Application")
job = ObjectType("Job")

@job.field("applicants")
def resolve_job_applicants(job_obj, info):
    """Resolver for the 'applicants' field on the Job type."""
    job_id = job_obj.get("jobId")
    if not job_id: return []

    applications = application_repo.find_applications({"jobId": job_id})
    if not applications: return []

    user_ids = [app.get("userId") for app in applications]
    if not user_ids: return []

    applicant_docs = user_repo.find_users({"UserID": {"$in": user_ids}}, None, None)
    return [user_repo.to_user_output(doc) for doc in applicant_docs]

@query.field("applications")
def resolve_applications(*_, userId=None, jobId=None, status=None):
    q = {}
    if userId: q["userId"] = int(userId)
    if jobId: q["jobId"] = int(jobId)
    if status: q["status"] = status
    docs = application_repo.find_applications(q)
    return [to_application_output(d) for d in docs]

@query.field("applicationById")
def resolve_application_by_id(*_, appId):
    doc = application_repo.find_application_by_id(int(appId))
    if not doc: raise ValueError(f"Application with ID {appId} not found.")
    return to_application_output(doc)

@application.field("candidate")
def resolve_application_candidate(app_obj, _):
    user_id = app_obj.get("userId")
    if not user_id: return None
    user_doc = user_repo.find_one_by_id(user_id)
    return user_repo.to_user_output(user_doc)

@application.field("job")
def resolve_application_job(app_obj, _):
    job_id = app_obj.get("jobId")
    if not job_id: return None
    job_doc = job_repo.find_job_by_id(job_id)
    return job_repo.to_job_output(job_doc)

@mutation.field("createApplication")
def resolve_create_application(*_, input):
    user_id, job_id = input.get("userId"), input.get("jobId")
    if not user_repo.find_one_by_id(user_id): raise ValueError(f"Validation failed: User with ID {user_id} does not exist.")
    if not job_repo.find_job_by_id(job_id): raise ValueError(f"Validation failed: Job with ID {job_id} does not exist.")
    doc = {
        "appId": next_application_id(), "userId": user_id, "jobId": job_id,
        "status": "Applied", "submittedAt": datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'),
        "notes": input.get("notes")
    }
    application_repo.insert_application(doc)
    return to_application_output(doc)

@mutation.field("apply")
def resolve_apply(*_, userName, jobTitle, companyName=None):
    name_parts = userName.strip().split()
    first_name, last_name = (name_parts[0], " ".join(name_parts[1:])) if len(name_parts) > 1 else (name_parts[0], None)
    if not first_name: raise ValueError("User name cannot be empty.")

    # --- CORRECTED FUNCTION CALL ---
    user_filter = user_repo.build_filter(first_name, last_name, None, None)
    matching_users = user_repo.find_users(user_filter, None, None)
    
    if len(matching_users) == 0: raise ValueError(f"Could not find a user named '{userName}'.")
    if len(matching_users) > 1: raise ValueError(f"Found multiple users named '{userName}'. Please be more specific.")
    user = matching_users[0]
    
    job_filter = job_repo.build_job_filter(companyName, None, jobTitle)
    matching_jobs = job_repo.find_jobs(job_filter, None, None)
    if len(matching_jobs) == 0: raise ValueError(f"Could not find a job with title '{jobTitle}' at company '{companyName or ''}'.")
    if len(matching_jobs) > 1: raise ValueError(f"Found multiple jobs with title '{jobTitle}'. Please specify a company.")
    job = matching_jobs[0]

    application_input = {"userId": user["UserID"], "jobId": job["jobId"]}
    return resolve_create_application(None, input=application_input)

@mutation.field("updateApplication")
def resolve_update_application(*_, appId, input):
    set_fields = clean_update_input(input)
    if not set_fields: raise ValueError("No fields provided to update.")
    updated = application_repo.update_one_application({"appId": int(appId)}, set_fields)
    if not updated: raise ValueError(f"Application with ID {appId} not found for update.")
    return to_application_output(updated)

# --- ADD THIS NEW MUTATION RESOLVER ---
@mutation.field("updateApplicationStatusByNames")
def resolve_update_application_status_by_names(obj, info, userName, jobTitle, newStatus, companyName=None):
    # 1. AUTHORIZATION CHECK
    user_role = info.context.get("user_role")
    if user_role != "Recruiter":
        raise ValueError("Permission denied: You must be a Recruiter to update an application.")

    # 2. FIND THE USER
    name_parts = userName.strip().split()
    first_name = name_parts[0] if name_parts else None
    last_name = " ".join(name_parts[1:]) if len(name_parts) > 1 else None
    if not first_name: raise ValueError("A user name must be provided.")

    user_filter = user_repo.build_filter(first_name, last_name, None, None)
    matching_users = user_repo.find_users(user_filter, None, None)
    if not matching_users: raise ValueError(f"Could not find a user named '{userName}'.")
    if len(matching_users) > 1: raise ValueError(f"Found multiple users named '{userName}'. Please be more specific.")
    user = matching_users[0]
    
    # 3. FIND THE JOB
    job_filter = job_repo.build_job_filter(companyName, None, jobTitle)
    matching_jobs = job_repo.find_jobs(job_filter, None, None)
    if not matching_jobs: raise ValueError(f"Could not find a job with title '{jobTitle}' at company '{companyName or ''}'.")
    if len(matching_jobs) > 1: raise ValueError(f"Found multiple jobs with title '{jobTitle}'. Please specify a company.")
    job_doc = matching_jobs[0]

    # 4. FIND AND UPDATE THE APPLICATION
    application_filter = {"userId": user["UserID"], "jobId": job_doc["jobId"]}
    update_fields = {"status": newStatus}
    
    updated_application = application_repo.update_one_application(application_filter, update_fields)
    
    if not updated_application:
        raise ValueError(f"No application found for user '{userName}' at job '{jobTitle}'.")
        
    # --- 5. THE FIX: Construct the full response object ---
    # Manually combine the updated application data with the user and job objects
    # that we already have in memory.
    response_data = to_application_output(updated_application)
    response_data["candidate"] = user_repo.to_user_output(user)
    response_data["job"] = job_repo.to_job_output(job_doc)
    
    return response_data

@job.field("applicationCount")
def resolve_job_application_count(job_obj, info):
    """Resolver for the 'applicationCount' field on the Job type."""
    job_id = job_obj.get("jobId")
    if not job_id:
        return 0
    
    # Use our new, efficient counting function
    count = application_repo.count_applications({"jobId": job_id})
    return count
</file>

<file path="src/backend/schema.graphql">
# src/backend/schema.graphql

# --- User Types ---
type User {
  UserID: Int!
  email: String!
  firstName: String!
  lastName: String!
  role: String!
  phone_number: String
  city: String
  state_province: String
  country: String
  linkedin_profile: String
  portfolio_url: String
  highest_qualification: String
  years_of_experience: Int
  createdAt: String
  dob: String
  skills: [String]
  professionalTitle: String
}

input UserInput {
  firstName: String!
  lastName: String!
  email: String!
  role: String!
  phone_number: String
  city: String
  state_province: String
  country: String
  linkedin_profile: String
  portfolio_url: String
  highest_qualification: String
  years_of_experience: Int
  dob: String
  skills: [String]
  professionalTitle: String
}

input UserUpdateInput {
  firstName: String
  lastName: String
  phone_number: String
  city: String
  state_province: String
  country: String
  linkedin_profile: String
  portfolio_url: String
  highest_qualification: String
  years_of_experience: Int
  dob: String
  skills: [String]
  professionalTitle: String
}


# --- Job & Application Types ---
type Job { 
  jobId: Int!
  title: String!
  company: String
  location: String
  salaryRange: String
  skillsRequired: [String]
  description: String
  postedAt: String
  applicants: [User!]
  applicationCount: Int!
}

input JobInput {
  title: String!
  company: String
  location: String
  salaryRange: String
  skillsRequired: [String]
  description: String
}

input JobUpdateInput {
  title: String
  company: String
  location: String
  salaryRange: String
  skillsRequired: [String]
  description: String
}

type Application {
  appId: Int!
  userId: Int!
  jobId: Int!
  status: String!
  submittedAt: String!
  notes: String
  candidate: User
  job: Job
}

input ApplicationInput {
  userId: Int!
  jobId: Int!
  notes: String
}

input ApplicationUpdateInput {
  status: String
  notes: String
}


# --- CORRECTED Query Type ---
type Query {
  users(limit: Int, skip: Int, firstName: String, lastName: String, dob: String, skills: [String!]): [User!]!
  userById(UserID: Int!): User
  jobs(limit: Int, skip: Int, company: String, location: String, title: String): [Job!]!
  jobById(jobId: Int!): Job
  applications(userId: Int, jobId: Int, status: String): [Application!]!
  applicationById(appId: Int!): Application
}


# --- CORRECTED Mutation Type ---
type Mutation {
  createUser(input: UserInput!): User!
  updateUser(UserID: Int!, input: UserUpdateInput!): User!
  updateUserByName(firstName: String, lastName: String, input: UserUpdateInput!): User!
  deleteUser(UserID: Int!): Boolean!
  deleteUserByFields(firstName: String, lastName: String, dob: String): Boolean!
  
  createJob(input: JobInput!): Job!
  updateJob(jobId: Int!, input: JobUpdateInput!): Job
  deleteJob(jobId: Int!): Boolean!
  addSkillsToJob(jobId: Int!, skills: [String!]!): Job
  deleteJobByFields(title: String!, company: String): Boolean!
  
  createApplication(input: ApplicationInput!): Application!
  apply(userName: String!, jobTitle: String!, companyName: String): Application!
  updateApplication(appId: Int!, input: ApplicationUpdateInput!): Application
  
  """
  Updates an application's status by finding it via user and job names.
  """
  updateApplicationStatusByNames(userName: String!, jobTitle: String!, companyName: String, newStatus: String!): Application
}
</file>

<file path="src/frontend-react/src/App.css">
/* src/frontend-react/src/App.css */
html, body, #root {
  height: 100%;
}

/* --- Global Variables (Themes) --- */
:root {
    /* Light Theme Defaults */
    --background-color: #f0f2f5;
    --text-color: #1c1e21;
    --card-background: #ffffff;
    --border-color: #ccc;
    --user-bubble-bg: #dcf8c6;
    --assistant-bubble-bg: #e5e5e5;
    --input-bg: #ffffff;
    --button-bg: #1877f2;
    --button-text: #ffffff;
}

/* Dark Theme Overrides */
[data-theme='dark'] {
    --background-color: #18191a;
    --text-color: #e4e6eb;
    --card-background: #242526;
    --border-color: #3a3b3c;
    --user-bubble-bg: #324e2c; /* Darker green */
    --assistant-bubble-bg: #3a3b3c;
    --input-bg: #3a3b3c;
    --button-bg: #2d88ff;
    --button-text: #ffffff;
}

/* --- Base Layout --- */
body {
    background-color: var(--background-color);
    color: var(--text-color);
    transition: background-color 0.3s, color 0.3s;
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.App {
    max-width: 1000px; /* Make it wider */
    height: 90vh; /* Make it 90% of the viewport height */
    margin: 40px auto;
    padding: 20px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--card-background);
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    
    /* Add these properties to enable flexbox */
    display: flex;
    flex-direction: column;
}

/* --- Header --- */
.header-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.header-controls {
    display: flex;
    align-items: center;
    gap: 15px; /* Adds space between header elements */
}

.theme-toggle {
    background: none;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 5px;
    font-size: 14px; /* For emoji consistency */
    line-height: 1; /* Aligns emoji better */
    transition: background-color 0.3s, border-color 0.3s;
}

.theme-toggle:hover {
    background-color: var(--assistant-bubble-bg);
}

/* --- Message Area --- */
.message-container {
    flex: 1; /* This makes the container grow to fill available space */
    min-height: 0; /* Prevents flexbox overflow issues */
    overflow-y: auto;
    border: 1px solid var(--border-color);
    padding: 10px;
    margin-bottom: 20px;
    border-radius: 8px;
    background-color: var(--card-background);
}

/* --- Chat Bubbles --- */
.message {
    display: flex;
    margin-bottom: 15px;
    flex-direction: column;
}

.user-message {
    align-items: flex-end;
}

.assistant-message {
    align-items: flex-start;
}

.message-bubble {
    padding: 12px;
    border-radius: 18px;
    max-width: 80%;
    word-wrap: break-word;
    white-space: pre-wrap;
    line-height: 1.5;
}

.user-message .message-bubble {
    background-color: var(--user-bubble-bg);
    color: var(--text-color);
}

.assistant-message .message-bubble {
    background-color: var(--assistant-bubble-bg);
    color: var(--text-color);
}

.message-bubble strong {
    font-weight: 600;
    margin-bottom: 5px;
    display: block;
}

/* --- Input Form --- */
.input-form {
    display: flex;
    gap: 10px;
}

.input-form input {
    flex-grow: 1;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    background-color: var(--input-bg);
    color: var(--text-color);
    outline: none;
    font-size: 16px;
}

.input-form button {
    padding: 12px 25px;
    background-color: var(--button-bg);
    color: var(--button-text);
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.2s;
}

.input-form button:hover:not(:disabled) {
    background-color: #0b5cb0; /* Slightly darker blue */
}

.input-form button:disabled {
    background-color: var(--border-color);
    cursor: not-allowed;
}

/* --- Code Blocks in Assistant Messages --- */
.message-bubble pre {
    background-color: rgba(0, 0, 0, 0.05);
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto;
    margin-top: 10px;
}

[data-theme='dark'] .message-bubble pre {
    background-color: rgba(255, 255, 255, 0.1);
}

/* --- User Greeting and Logout Button Styles --- */
.user-greeting {
  font-weight: 600;
  color: var(--text-color);
  margin-right: 10px;
}

.logout-button {
  background-color: #e4e6eb;
  color: #1c1e21;
  border: 1px solid var(--border-color);
  padding: 8px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
  transition: background-color 0.2s, color 0.2s;
}

.logout-button:hover {
  background-color: #d1d3d6;
}

[data-theme='dark'] .logout-button {
  background-color: #3a3b3c;
  color: #e4e6eb;
}

[data-theme='dark'] .logout-button:hover {
  background-color: #4e4f50;
}
</file>

<file path="src/frontend-react/src/LoginPage.js">
// src/frontend-react/src/LoginPage.js
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import './LoginPage.css';

const API_ENDPOINT = process.env.REACT_APP_API_ENDPOINT || 'http://localhost:8000';

function LoginPage() {
  const [email, setEmail] = useState('');
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [password, setPassword] = useState('');
  const [role, setRole] = useState('Applicant');
  const [isLogin, setIsLogin] = useState(true);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (isLogin) {
      // --- Sign-In Logic with Persistent Session ---
      try {
        const payload = { email, password };
        const response = await axios.post(`${API_ENDPOINT}/login`, payload);
        
        // 1. Calculate the expiration time (48 hours from now)
        const expirationTime = new Date().getTime() + (48 * 60 * 60 * 1000); // 48 hours in milliseconds

        // 2. Create an object to store both the user data and the expiry timestamp
        const sessionData = {
          user: response.data.user,
          expiresAt: expirationTime,
        };

        // 3. Store this object in localStorage for persistence
        localStorage.setItem('session', JSON.stringify(sessionData));
        
        // 4. Redirect to the chat page
        navigate('/chat');

      } catch (error) {
        if (error.response && error.response.data.error) {
          alert(`Login failed: ${error.response.data.error}`);
        } else {
          alert('Login failed: An unknown error occurred.');
        }
        console.error('Login error:', error);
      }
    } else {
      // --- Registration Logic ---
      try {
        const payload = { email, firstName, lastName, password, role };
        const response = await axios.post(`${API_ENDPOINT}/register`, payload);

        alert(response.data.message);
        setIsLogin(true); // Switch form to login mode on successful registration
        // Clear all fields
        setEmail('');
        setFirstName('');
        setLastName('');
        setPassword('');
        setRole('Applicant');

      } catch (error) {
        if (error.response && error.response.data.error) {
          alert(`Registration failed: ${error.response.data.error}`);
        } else {
          alert('Registration failed: An unknown error occurred.');
        }
        console.error('Registration error:', error);
      }
    }
  };

  return (
    <div className="login-container">
      <form onSubmit={handleSubmit} className="login-form">
        <h2>{isLogin ? 'Sign In to JobChat.AI' : 'Create Your Account'}</h2>
        
        {!isLogin && (
          <>
            <div className="input-group">
              <label>First Name</label>
              <input type="text" value={firstName} onChange={(e) => setFirstName(e.target.value)} required />
            </div>
            <div className="input-group">
              <label>Last Name</label>
              <input type="text" value={lastName} onChange={(e) => setLastName(e.target.value)} required />
            </div>
            <div className="input-group">
              <label>I am a</label>
              <select value={role} onChange={(e) => setRole(e.target.value)} required>
                <option value="Applicant">User / Applicant</option>
                <option value="Recruiter">Recruiter</option>
              </select>
            </div>
          </>
        )}

        <div className="input-group">
          <label>Email</label>
          <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} required />
        </div>

        <div className="input-group">
          <label>Password</label>
          <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} required />
        </div>
        
        <button type="submit" className="login-button">
          {isLogin ? 'Sign In' : 'Sign Up'}
        </button>
        
        <p className="toggle-form">
          {isLogin ? "Don't have an account?" : "Already have an account?"}
          <button type="button" onClick={() => setIsLogin(!isLogin)} className="toggle-button">
            {isLogin ? 'Sign Up' : 'Sign In'}
          </button>
        </p>
      </form>
    </div>
  );
}

export default LoginPage;
</file>

<file path="src/frontend-react/src/ResultsDisplay.js">
// src/frontend-react/src/ResultsDisplay.js
import React, { useState } from 'react';
import './ResultsDisplay.css';

// A small helper component to render a single Job
const JobResult = ({ job }) => (
  <div className="result-item">
    <div className="item-header">
      <span className="item-title">{job.title || 'N/A'}</span>
      <span className="item-location">{job.location || 'N/A'}</span>
    </div>
    <div className="item-company">{job.company || 'N/A'}</div>
    {job.skillsRequired && job.skillsRequired.length > 0 && (
      <div className="item-skills">
        {job.skillsRequired.map(skill => <span key={skill} className="skill-tag">{skill}</span>)}
      </div>
    )}
  </div>
);

// An enhanced component to render a single, detailed User profile
const UserResult = ({ user }) => (
    <div className="result-item">
        <div className="item-header">
            <span className="item-title">{user.firstName} {user.lastName}</span>
            <span className="item-location">{user.city && user.country ? `${user.city}, ${user.country}` : ''}</span>
        </div>
        <div className="item-subtitle">{user.professionalTitle || 'No professional title provided'}</div>
        
        {user.years_of_experience != null && (
            <div className="item-detail">
                <strong>Experience:</strong> {user.years_of_experience} years
            </div>
        )}
        {user.highest_qualification && (
            <div className="item-detail">
                <strong>Qualification:</strong> {user.highest_qualification}
            </div>
        )}

        {user.skills && user.skills.length > 0 && (
            <div className="item-skills">
                {user.skills.map(skill => <span key={skill} className="skill-tag">{skill}</span>)}
            </div>
        )}

        <div className="item-links">
            {user.linkedin_profile && <a href={user.linkedin_profile} target="_blank" rel="noopener noreferrer">LinkedIn</a>}
            {user.portfolio_url && <a href={user.portfolio_url} target="_blank" rel="noopener noreferrer">Portfolio</a>}
        </div>
    </div>
);

// A helper component to render the result of an application status update
const ApplicationResult = ({ app }) => (
    <div className="result-item">
        <div className="item-header">
            <span className="item-title">Application Status Updated</span>
        </div>
        <div className="status-update-info">
            Candidate **{app.candidate?.firstName} {app.candidate?.lastName}** for the position of **{app.job?.title}** has been moved to the **{app.status}** stage.
        </div>
    </div>
);


const ResultsDisplay = ({ rawGql, rawJson }) => {
  const [detailsVisible, setDetailsVisible] = useState(false);

  let resultsContent = null;
  const resultData = rawJson?.data;

  // Check for different types of data and prepare the display content
  if (resultData) {
      // Handles application status updates
      if (resultData.updateApplicationStatusByNames) {
          resultsContent = <ApplicationResult app={resultData.updateApplicationStatusByNames} />;
      }
      // NEW: Handles a request for jobs that includes an application count
      else if (resultData.jobs && Array.isArray(resultData.jobs) && resultData.jobs[0]?.applicationCount !== undefined) {
          resultsContent = resultData.jobs.map(job => (
              <div key={job.jobId} className="result-item application-count-result">
                  The job "**{job.title}**" at **{job.company}** has **{job.applicationCount}** application(s).
              </div>
          ));
      }
      // Handles a request for jobs with nested applicants
      else if (resultData.jobs && Array.isArray(resultData.jobs) && resultData.jobs[0]?.applicants) {
          resultsContent = resultData.jobs.map(job => (
              <div key={job.jobId} className="result-item job-applicant-container">
                  <h3 className="container-title">Applicants for: {job.title} at {job.company}</h3>
                  {job.applicants.length > 0 ? (
                      job.applicants.map(applicant => <UserResult key={applicant.UserID} user={applicant} />)
                  ) : (
                      <p>No applicants found for this job yet.</p>
                  )}
              </div>
          ));
      }
      // Handles a simple list of jobs
      else if (resultData.jobs && Array.isArray(resultData.jobs)) {
          resultsContent = resultData.jobs.length > 0
            ? resultData.jobs.map(job => <JobResult key={job.jobId} job={job} />)
            : <p>No jobs found matching your criteria.</p>;
      
      // Handles a list of users
      } else if (resultData.users && Array.isArray(resultData.users)) {
          resultsContent = resultData.users.length > 0
            ? resultData.users.map(user => <UserResult key={user.UserID} user={user} />)
            : <p>No users found matching your criteria.</p>;

      // Handles a single user lookup
      } else if (resultData.userById) {
          resultsContent = <UserResult user={resultData.userById} />;

      // Handles a successful user creation or update
      } else if (resultData.createUser || resultData.updateUser) {
          const user = resultData.createUser || resultData.updateUser;
          resultsContent = (
            <div>
              <p>‚úÖ Success! User profile updated:</p>
              <UserResult user={user} />
            </div>
          );
      }
  }
  
  // Fallback for successful operations that don't return a list or known object
  if (!resultsContent && rawJson?.data) {
      resultsContent = <p>‚úÖ The operation was successful. View details for the raw response.</p>;
  // Fallback for GraphQL errors
  } else if (!resultsContent && rawJson?.errors) {
      resultsContent = <p>‚ùå An error occurred. See details for more information.</p>;
  }

  return (
    <div className="results-display">
      <div className="results-summary">
        {resultsContent}
      </div>
      
      <div className="details-toggle">
        <button onClick={() => setDetailsVisible(!detailsVisible)}>
          {detailsVisible ? 'Hide GraphQL & JSON' : 'Show GraphQL & JSON'}
        </button>
      </div>

      {detailsVisible && (
        <div className="raw-details">
          <strong>Generated GraphQL:</strong>
          <pre>{rawGql}</pre>
          
          <strong>Result JSON:</strong>
          <pre>{JSON.stringify(rawJson, null, 2)}</pre>
        </div>
      )}
    </div>
  );
};

export default ResultsDisplay;
</file>

<file path="src/backend/app.py">
# src/backend/app.py
import os
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

import bcrypt
import requests
from flask_cors import CORS
from flask import Flask, jsonify, request
from ariadne import load_schema_from_path, make_executable_schema, graphql_sync
from ariadne.explorer import ExplorerGraphiQL
from dotenv import load_dotenv
from werkzeug.exceptions import HTTPException
from datetime import datetime

# Import backend modules
from src.backend.models.user_models import UserProfileType
from src.backend.errors import handle_http_exception, handle_value_error, handle_generic_exception, json_error
from src.backend.services.nl2gql_service import process_nl2gql_request
from src.backend.repository import user_repo
from src.backend.db import ensure_user_counter, ensure_job_counter, ensure_application_counter, next_user_id

# Import resolvers
from src.backend.resolvers.user_resolvers import query as user_query, mutation as user_mutation
from src.backend.resolvers.job_resolvers import query as job_query, mutation as job_mutation
from src.backend.resolvers.application_resolvers import query as app_query, mutation as app_mutation, application as application_object, job
# Load environment variables
load_dotenv(os.path.join(os.path.dirname(__file__), '../.env'))

# --- Flask app setup ---
app = Flask(__name__)
CORS(app)
explorer_html = ExplorerGraphiQL().html(None)

# --- Load GraphQL schema ---
schema_path = os.path.join(os.path.dirname(__file__), "schema.graphql")
type_defs = load_schema_from_path(schema_path)
schema = make_executable_schema(
    type_defs,
    [user_query, job_query, app_query],
    [user_mutation, job_mutation, app_mutation],
    application_object,
    job  
)

# Initialize database counters
ensure_user_counter()
ensure_job_counter()
ensure_application_counter()

# --- Error Handlers ---
@app.errorhandler(HTTPException)
def http_error(e): return handle_http_exception(e)
@app.errorhandler(ValueError)
def value_error(e): return handle_value_error(e)
@app.errorhandler(Exception)
def unhandled_exception(e): return handle_generic_exception(e)

# --- GraphQL endpoints ---
@app.route("/graphql", methods=["GET"])
def graphql_explorer(): return explorer_html, 200
@app.route("/graphql", methods=["POST"])
def graphql_server():
    data = request.get_json(silent=True)
    user_role = request.headers.get("X-User-Role", "Applicant")
    success, result = graphql_sync(
        schema, 
        data, 
        context_value={"request": request, "user_role": user_role}, 
        debug=app.debug
    )
    return jsonify(result), (200 if success else 400)

# --- Health check ---
@app.route("/")
def health(): return jsonify({"status": "Backend is running!"}), 200

# --- NL2GQL Endpoint ---
@app.route("/nl2gql", methods=["POST"])
def nl2gql():
    data = request.get_json(silent=True) or {}
    user_text = data.get("query", "")
    user_context = data.get("userContext")
    run_graphql = request.args.get("run", "true").lower() != "false"
    with open(schema_path, "r", encoding="utf-8") as f: schema_sdl = f.read()

    # --- THIS IS THE FUNCTION THAT NEEDED TO BE FIXED ---
    def execute_graphql_query(gql_data):
        # 1. Read the role from the header within this function's scope
        user_role = request.headers.get("X-User-Role", "Applicant")
        
        # 2. Pass the role into the context for this specific execution
        return graphql_sync(
            schema, 
            gql_data, 
            context_value={"request": request, "user_role": user_role}, 
            debug=app.debug
        )

    payload, status_code = process_nl2gql_request(
        user_text, schema_sdl, run_graphql, execute_graphql_query, user_context
    )
    return jsonify(payload), status_code

# --- User Registration Endpoint ---
@app.route("/register", methods=["POST"])
def register_user():
    data = request.get_json()
    if not data: return jsonify({"error": "Invalid JSON body"}), 400
    
    email, password, first_name, last_name, role = data.get("email"), data.get("password"), data.get("firstName"), data.get("lastName"), data.get("role")
    if not all([email, password, first_name, last_name, role]):
        return jsonify({"error": "Missing required fields"}), 400
    try:
        validated_role = UserProfileType.from_str(role).value
    except ValueError as e:
        return jsonify({"error": str(e)}), 400

    if user_repo.find_user_by_email(email):
        return jsonify({"error": f"An account with the email '{email}' already exists."}), 409

    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

    new_user_doc = {
        "UserID": next_user_id(), "email": email.lower(), "password": hashed_password,
        "firstName": first_name, "lastName": last_name, "role": validated_role,
        "phone_number": None, "city": None, "state_province": None, "country": None,
        "linkedin_profile": None, "portfolio_url": None, "highest_qualification": None,
        "years_of_experience": None, "createdAt": datetime.utcnow().isoformat(),
        "dob": None, "skills": [], "professionalTitle": None
    }

    try:
        user_repo.insert_user(new_user_doc)
        return jsonify({"message": "User registered successfully!"}), 201
    except Exception as e:
        return jsonify({"error": f"An internal error occurred: {e}"}), 500
    
# --- User Login Endpoint ---
@app.route("/login", methods=["POST"])
def login_user():
    data = request.get_json()
    if not data: return jsonify({"error": "Invalid JSON body"}), 400
    email, password = data.get("email"), data.get("password")
    if not email or not password: return jsonify({"error": "Email and password are required"}), 400

    user = user_repo.find_user_by_email(email)
    if not user: return jsonify({"error": "Invalid email or password"}), 401

    if bcrypt.checkpw(password.encode('utf-8'), user.get("password")):
        user_data = user_repo.to_user_output(user)
        return jsonify({"message": "Login successful!", "user": user_data}), 200
    else:
        return jsonify({"error": "Invalid email or password"}), 401

if __name__ == "__main__":
    print("üöÄ Starting Flask server on http://localhost:8000 ...")
    app.run(host="0.0.0.0", port=8000, debug=True)
</file>

<file path="src/backend/services/nl2gql_service.py">
# src/backend/services/nl2gql_service.py
import os
import requests
import json
from typing import Optional
from dotenv import load_dotenv

env_path = os.path.join(os.path.dirname(__file__), '../../.env')
load_dotenv(dotenv_path=env_path)

from ..errors import json_error, unwrap_graphql_errors

OLLAMA_HOST = os.getenv("OLLAMA_HOST", "https://ollama.com")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gpt-oss:120b-cloud")
OLLAMA_API_KEY = os.getenv("OLLAMA_API_KEY")
OLLAMA_GENERATE_URL = f"{OLLAMA_HOST}/api/generate"


# --- RESTORED: The more comprehensive small talk handler ---
def handle_small_talk(user_text: str):
    """
    Checks for a wide range of conversational phrases (greetings, idioms, etc.)
    and returns a predefined friendly response to bypass the LLM.
    """
    clean_text = user_text.lower().strip()
    words = clean_text.split()
    
    # --- Category 1: Direct Matches (Greetings, Gratitude, Interjections) ---
    small_talk_map = {
        "hi": "Hello there! How can I assist with your job data today?",
        "hello": "Hi! I'm ready to convert your requests into GraphQL. What can I do?",
        "hey": "Hey! Let me know what data you need to query or update.",
        "greetings": "Greetings! I'm here to help with your job portal data via NL2GQL.",
        "thanks": "You're welcome! I'm happy to help.",
        "thank you": "My pleasure! Just ask if you have more queries.",
        "wow": "Glad to impress! Do you have a query for me?",
        "cool": "I think so too! Ready for your next command.",
        "awesome": "I strive for excellence! Ready for a command.",
        "oops": "Mistakes happen! Please try your query again.",
        "sorry": "No worries at all. What is your request?",
        "how are you": "I'm a GraphQL assistant, operating perfectly! What query can I run for you?",
        "what's up": "Just monitoring the database for your requests. What can I do for you?",
        "how are you doing today": "I'm a GraphQL assistant, operating perfectly! What query can I run for you?",
    }
    
    # --- Category 2: Idioms, Common Phrases & Discourse Markers (Keyword Matching) ---
    keyword_responses = {
        "by the way": "Interesting point. Do you have a job or user query for me?",
        "i mean": "I understand. Please formulate your query clearly.",
        "just saying": "Got it. I'm waiting for a command that maps to GraphQL.",
        "you know": "I know what you mean. Focus on what data you need.",
        "hold on": "Okay, I'll hold. Let me know when you have a request.",
        "excuse me": "No problem. How can I help with the data?",
        "can you help me": "Absolutely! I can help by converting your request into a GraphQL query.",
        "can i ask": "You can ask. I can answer if it involves querying or mutating job portal data.",
    }
    
    default_response_payload = {
        "graphql": "Small talk handled by service logic", 
        "result": {
            "response": (
                "Hello! I'm your GraphQL assistant. I can help with job portal data. "
                "Try asking me to:\n- **Find** jobs: *find jobs for Java developer in London*\n"
                "- **Update** your profile: *update my professional title to Senior Developer*"
            )
        }
    }
    
    # 1. Check for Direct Matches
    if clean_text in small_talk_map:
        return {"graphql": "Small talk handled by service logic", "result": {"response": small_talk_map[clean_text]}}, 200
        
    # 2. Check for Keyword Matches
    for key, response in keyword_responses.items():
        if key in clean_text:
            return {"graphql": "Small talk handled by service logic", "result": {"response": response}}, 200

    # 3. Check for short multi-word greetings or questions to the bot
    if words:
        is_greeting = words[0] in ["hi", "hello", "hey"]
        is_vocative = "assistant" in words or "bot" in words or "jobchat" in words
        
        if (is_greeting or is_vocative) and len(words) <= 5:
            # Return the default, guiding response for these cases
            return default_response_payload, 200
        
    return None

# --- UPDATED Prompt Builder (Keeps the userContext logic) ---
def build_nl2gql_prompt(user_text: str, schema_sdl: str, user_context: Optional[dict]) -> str:
    context_str = ""
    if user_context and user_context.get("UserID"):
        user_id = user_context["UserID"]
        first_name = user_context.get("firstName", "the user")
        context_str = (
            f"\n\nContext:\n"
            f"- The request is from a logged-in user named '{first_name}' with UserID: {user_id}.\n"
            f"- When the user refers to 'me', 'my', or 'I', you MUST use their UserID ({user_id}) to target the operation (e.g., in an `updateUser` mutation).\n"
        )

    return (
        "You are an expert GraphQL assistant. Your task is to convert the user's natural language request "
        "into a single, valid GraphQL operation that adheres strictly to the provided schema. "
        "Return ONLY the GraphQL operation with no explanations or markdown fences."
        f"{context_str}"
        "\n\nKey Instructions:\n"
         "- When a user asks **'how many applications'** or for a **'count of applicants'**, you **MUST** query the relevant job and include the `applicationCount` field.\n"
        "- When a user wants to **UPDATE the STATUS** of an application (e.g., 'interview', 'reject', 'hire'), you **MUST** use the `updateApplicationStatusByNames` mutation.\n"
        "- When a user wants to see **applicants**, **candidates**, or people who **applied** for a job, you **MUST** query the `jobs` field with a filter and request the nested `applicants` field within it.\n"
        "- When a user wants to **ADD** skills to a job, you **MUST** use the `addSkillsToJob` mutation. For all other job updates, use the `updateJob` mutation.\n"
        "- When the user wants to 'apply' a person to a job, ALWAYS use the `apply` mutation.\n"
        "- When a user wants to **DELETE** or **REMOVE** a job using its title and company, you **MUST** use the `deleteJobByFields` mutation.\n"
        "- When the user wants to 'apply' a person to a job, ALWAYS use the `apply` mutation.\n"
        "- For other actions, use the appropriate query or mutation.\n"
        "- If the user's request cannot be mapped to any field in the schema, return the single word: INVALID.\n"
        "- Do not make up fields or assume logic not present in the schema.\n\n"
        "Schema:\n"
        f"{schema_sdl}\n\n"
        "User request:\n"
        f"\"{user_text}\""
    )

def extract_graphql(text: str) -> str:
    """Extracts a GraphQL query from a markdown block or plain text."""
    if "```" in text:
        parts = text.split("```")
        for part in parts:
            if "query" in part or "mutation" in part or "{" in part:
                return part.replace("graphql", "").strip()
    return text.strip()

# --- UPDATED Service Processor (Keeps the userContext logic) ---
def process_nl2gql_request(user_text: str, schema_sdl: str, run_graphql: bool, graphql_executor_fn, user_context: Optional[dict]):
    small_talk_response = handle_small_talk(user_text)
    if small_talk_response:
        return small_talk_response
    
    if not OLLAMA_API_KEY:
        return json_error("NL2GQL Service Error: OLLAMA_API_KEY is missing in environment configuration.", 500)
        
    prompt = build_nl2gql_prompt(user_text, schema_sdl, user_context)

    headers = {"Authorization": f"Bearer {OLLAMA_API_KEY}"}

    try:
        resp = requests.post(
            OLLAMA_GENERATE_URL,
            json={"model": OLLAMA_MODEL, "prompt": prompt, "stream": False},
            headers=headers,
            timeout=90,
        )
    except requests.exceptions.RequestException as e:
        return json_error(f"Ollama network error: {e}", 502)

    if not resp.ok:
        try:
            err_details = resp.json().get("error", resp.text)
            return json_error(f"LLM Error {resp.status_code}: {err_details}", 502)
        except (json.JSONDecodeError, ValueError):
            return json_error(f"Ollama returned a non-JSON error (Status: {resp.status_code}).", 502)

    try:
        gen_body = resp.json()
        gen = gen_body.get("response", "")
        gql = extract_graphql(gen)
    except (ValueError, IndexError):
        return json_error("Failed to parse the response from the LLM.", 502)

    if not gql or gql.strip().upper() == "INVALID":
        return json_error("Your request could not be mapped to a valid operation. Please try rephrasing.", 400)

    if not run_graphql:
        return {"graphql": gql}, 200

    success, result = graphql_executor_fn({"query": gql})
    
    wrapped_error = unwrap_graphql_errors(result)
    if wrapped_error:
        return wrapped_error 

    return {"graphql": gql, "result": result}, (200 if success else 400)
</file>

<file path="src/frontend-react/src/App.js">
// src/frontend-react/src/App.js
import React, { useState, useEffect } from 'react';
import { Routes, Route, Navigate, useNavigate } from 'react-router-dom';
import './App.css';
import LoginPage from './LoginPage';
import ResultsDisplay from './ResultsDisplay';
import apiClient from './api'; // Import our new centralized API client

function ChatPage() {
  const navigate = useNavigate();
  const [user, setUser] = useState(null);

  // --- This effect checks for a valid, non-expired session on component load ---
  useEffect(() => {
    const sessionJSON = localStorage.getItem('session');
    
    if (sessionJSON) {
      const session = JSON.parse(sessionJSON);
      const now = new Date().getTime();

      // Check if the session has expired
      if (now > session.expiresAt) {
        localStorage.removeItem('session');
        navigate('/login');
      } else {
        setUser(session.user);
      }
    } else {
      navigate('/login');
    }
  }, [navigate]);

  const handleLogout = () => {
    localStorage.removeItem('session');
    setUser(null);
    navigate('/login');
  };

  // --- State and handlers for chat functionality ---
  const [messages, setMessages] = useState([
    { type: 'text', role: 'assistant', payload: { text: "Hi! Ask me anything about users or jobs." } }
  ]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [theme, setTheme] = useState(() => localStorage.getItem('theme') || 'light');

  // Effect to apply the theme to the document
  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
  }, [theme]);

  const toggleTheme = () => setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));

  const formatContentForDisplay = (content) => {
    return content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  };

  const handleSend = async (e) => {
    e.preventDefault();
    if (!input.trim() || loading) return;

    const userPrompt = input.trim();
    setMessages(prev => [...prev, { type: 'text', role: 'user', payload: { text: userPrompt } }]);
    setInput('');
    setLoading(true);

    try {
      const payload = { 
        query: userPrompt,
        userContext: user // The apiClient will automatically add the role header
      };
      
      // Use the new apiClient, which automatically adds headers
      const response = await apiClient.post('/nl2gql', payload);
      const { graphql = "", result = {} } = response.data;

      if (graphql === "Small talk handled by service logic" && result.response) {
        setMessages(prev => [...prev, { type: 'text', role: 'assistant', payload: { text: result.response } }]);
      } else {
        setMessages(prev => [...prev, { type: 'results', role: 'assistant', payload: { rawGql: graphql, rawJson: result } }]);
      }
    } catch (error) {
      const err_msg = error.response?.data?.error?.message || "An unexpected error occurred while connecting to the service.";
      setMessages(prev => [...prev, { type: 'text', role: 'assistant', payload: { text: `**Error:** ${err_msg}` } }]);
    } finally {
      setLoading(false);
    }
  };

  // Render nothing until the authentication check is complete
  if (!user) {
    return null;
  }

  // --- JSX for the ChatPage component ---
  return (
    <div className="App">
      <div className="header-container">
        <h1>JobChat.AI</h1>
        <div className="header-controls">
          <span className="user-greeting">Hi, {user.firstName}! ({user.role})</span>
          <button onClick={toggleTheme} className="theme-toggle">
            {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
          </button>
          <button onClick={handleLogout} className="logout-button" title="Logout">
            Logout
          </button>
        </div>
      </div>

      {/* Conditionally render a special panel for users with the 'Recruiter' role */}
      {user.role === 'Recruiter' && (
        <div className="recruiter-panel">
          <p>Recruiter Tools: You can now post jobs. Try asking: "create a job for a Senior Python Developer at Google..."</p>
        </div>
      )}

      <div className="message-container">
        {messages.map((m, index) => (
          <div key={index} className={`message ${m.role}-message`}>
            {m.type === 'results' ? (
              <ResultsDisplay rawGql={m.payload.rawGql} rawJson={m.payload.rawJson} />
            ) : (
              <div
                className="message-bubble"
                dangerouslySetInnerHTML={{ __html: formatContentForDisplay(m.payload.text) }}
              />
            )}
          </div>
        ))}
      </div>
      
      <form onSubmit={handleSend} className="input-form">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type a request like 'find jobs in London'..."
          disabled={loading}
        />
        <button type="submit" disabled={loading}>
          {loading ? '...' : 'Send'}
        </button>
      </form>
    </div>
  );
}


// --- Main App Component for Routing ---
function App() {
  return (
    <Routes>
      <Route path="/login" element={<LoginPage />} />
      <Route path="/chat" element={<ChatPage />} />
      
      {/* Set the default route to redirect to the chat page */}
      <Route path="/" element={<Navigate to="/chat" />} />
    </Routes>
  );
}

export default App;
</file>

</files>
